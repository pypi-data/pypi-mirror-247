# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['SubscriptionDatabaseArgs', 'SubscriptionDatabase']

@pulumi.input_type
class SubscriptionDatabaseArgs:
    def __init__(__self__, *,
                 memory_limit_in_gb: pulumi.Input[float],
                 subscription_id: pulumi.Input[str],
                 throughput_measurement_by: pulumi.Input[str],
                 throughput_measurement_value: pulumi.Input[int],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]]] = None,
                 average_item_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 client_ssl_certificate: Optional[pulumi.Input[str]] = None,
                 data_eviction: Optional[pulumi.Input[str]] = None,
                 data_persistence: Optional[pulumi.Input[str]] = None,
                 enable_tls: Optional[pulumi.Input[bool]] = None,
                 external_endpoint_for_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 hashing_policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 modules: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 periodic_backup_path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 remote_backup: Optional[pulumi.Input['SubscriptionDatabaseRemoteBackupArgs']] = None,
                 replica_ofs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replication: Optional[pulumi.Input[bool]] = None,
                 source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_oss_cluster_api: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a SubscriptionDatabase resource.
        :param pulumi.Input[float] memory_limit_in_gb: Maximum memory usage for this specific database
        :param pulumi.Input[str] subscription_id: The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] throughput_measurement_by: Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        :param pulumi.Input[int] throughput_measurement_value: Throughput value (as applies to selected measurement method)
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]] alerts: A block defining Redis database alert, documented below, can be specified multiple times
        :param pulumi.Input[int] average_item_size_in_bytes: Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
               of the items stored in the database. Default: 1000
        :param pulumi.Input[str] client_ssl_certificate: SSL certificate to authenticate user connections
        :param pulumi.Input[str] data_eviction: The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        :param pulumi.Input[str] data_persistence: Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        :param pulumi.Input[bool] enable_tls: Use TLS for authentication. Default: ‘false’
        :param pulumi.Input[bool] external_endpoint_for_oss_cluster_api: Should use the external endpoint for open-source (OSS) Cluster API.
               Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hashing_policies: List of regular expression rules to shard the database by. See
               [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
               hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]] modules: A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] name: A meaningful name to identify the database
        :param pulumi.Input[str] password: Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        :param pulumi.Input[str] periodic_backup_path: Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        :param pulumi.Input[int] port: TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] protocol: The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input['SubscriptionDatabaseRemoteBackupArgs'] remote_backup: Specifies the backup options for the database, documented below
        :param pulumi.Input[Sequence[pulumi.Input[str]]] replica_ofs: Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
               database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
               Cannot be enabled when `support_oss_cluster_api` is enabled.
        :param pulumi.Input[bool] replication: Databases replication. Default: ‘true’
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ips: List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        :param pulumi.Input[bool] support_oss_cluster_api: Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        pulumi.set(__self__, "memory_limit_in_gb", memory_limit_in_gb)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "throughput_measurement_by", throughput_measurement_by)
        pulumi.set(__self__, "throughput_measurement_value", throughput_measurement_value)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if average_item_size_in_bytes is not None:
            pulumi.set(__self__, "average_item_size_in_bytes", average_item_size_in_bytes)
        if client_ssl_certificate is not None:
            pulumi.set(__self__, "client_ssl_certificate", client_ssl_certificate)
        if data_eviction is not None:
            pulumi.set(__self__, "data_eviction", data_eviction)
        if data_persistence is not None:
            pulumi.set(__self__, "data_persistence", data_persistence)
        if enable_tls is not None:
            pulumi.set(__self__, "enable_tls", enable_tls)
        if external_endpoint_for_oss_cluster_api is not None:
            pulumi.set(__self__, "external_endpoint_for_oss_cluster_api", external_endpoint_for_oss_cluster_api)
        if hashing_policies is not None:
            pulumi.set(__self__, "hashing_policies", hashing_policies)
        if modules is not None:
            pulumi.set(__self__, "modules", modules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if periodic_backup_path is not None:
            warnings.warn("""Use `remote_backup` block instead""", DeprecationWarning)
            pulumi.log.warn("""periodic_backup_path is deprecated: Use `remote_backup` block instead""")
        if periodic_backup_path is not None:
            pulumi.set(__self__, "periodic_backup_path", periodic_backup_path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if remote_backup is not None:
            pulumi.set(__self__, "remote_backup", remote_backup)
        if replica_ofs is not None:
            pulumi.set(__self__, "replica_ofs", replica_ofs)
        if replication is not None:
            pulumi.set(__self__, "replication", replication)
        if source_ips is not None:
            pulumi.set(__self__, "source_ips", source_ips)
        if support_oss_cluster_api is not None:
            pulumi.set(__self__, "support_oss_cluster_api", support_oss_cluster_api)

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> pulumi.Input[float]:
        """
        Maximum memory usage for this specific database
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @memory_limit_in_gb.setter
    def memory_limit_in_gb(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory_limit_in_gb", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="throughputMeasurementBy")
    def throughput_measurement_by(self) -> pulumi.Input[str]:
        """
        Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        """
        return pulumi.get(self, "throughput_measurement_by")

    @throughput_measurement_by.setter
    def throughput_measurement_by(self, value: pulumi.Input[str]):
        pulumi.set(self, "throughput_measurement_by", value)

    @property
    @pulumi.getter(name="throughputMeasurementValue")
    def throughput_measurement_value(self) -> pulumi.Input[int]:
        """
        Throughput value (as applies to selected measurement method)
        """
        return pulumi.get(self, "throughput_measurement_value")

    @throughput_measurement_value.setter
    def throughput_measurement_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "throughput_measurement_value", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]]]:
        """
        A block defining Redis database alert, documented below, can be specified multiple times
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="averageItemSizeInBytes")
    def average_item_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
        of the items stored in the database. Default: 1000
        """
        return pulumi.get(self, "average_item_size_in_bytes")

    @average_item_size_in_bytes.setter
    def average_item_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "average_item_size_in_bytes", value)

    @property
    @pulumi.getter(name="clientSslCertificate")
    def client_ssl_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        SSL certificate to authenticate user connections
        """
        return pulumi.get(self, "client_ssl_certificate")

    @client_ssl_certificate.setter
    def client_ssl_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_ssl_certificate", value)

    @property
    @pulumi.getter(name="dataEviction")
    def data_eviction(self) -> Optional[pulumi.Input[str]]:
        """
        The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        """
        return pulumi.get(self, "data_eviction")

    @data_eviction.setter
    def data_eviction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_eviction", value)

    @property
    @pulumi.getter(name="dataPersistence")
    def data_persistence(self) -> Optional[pulumi.Input[str]]:
        """
        Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        """
        return pulumi.get(self, "data_persistence")

    @data_persistence.setter
    def data_persistence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_persistence", value)

    @property
    @pulumi.getter(name="enableTls")
    def enable_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Use TLS for authentication. Default: ‘false’
        """
        return pulumi.get(self, "enable_tls")

    @enable_tls.setter
    def enable_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_tls", value)

    @property
    @pulumi.getter(name="externalEndpointForOssClusterApi")
    def external_endpoint_for_oss_cluster_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Should use the external endpoint for open-source (OSS) Cluster API.
        Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        """
        return pulumi.get(self, "external_endpoint_for_oss_cluster_api")

    @external_endpoint_for_oss_cluster_api.setter
    def external_endpoint_for_oss_cluster_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external_endpoint_for_oss_cluster_api", value)

    @property
    @pulumi.getter(name="hashingPolicies")
    def hashing_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expression rules to shard the database by. See
        [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
        hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        """
        return pulumi.get(self, "hashing_policies")

    @hashing_policies.setter
    def hashing_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hashing_policies", value)

    @property
    @pulumi.getter
    def modules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]]]:
        """
        A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "modules")

    @modules.setter
    def modules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]]]):
        pulumi.set(self, "modules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A meaningful name to identify the database
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="periodicBackupPath")
    def periodic_backup_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        """
        warnings.warn("""Use `remote_backup` block instead""", DeprecationWarning)
        pulumi.log.warn("""periodic_backup_path is deprecated: Use `remote_backup` block instead""")

        return pulumi.get(self, "periodic_backup_path")

    @periodic_backup_path.setter
    def periodic_backup_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "periodic_backup_path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="remoteBackup")
    def remote_backup(self) -> Optional[pulumi.Input['SubscriptionDatabaseRemoteBackupArgs']]:
        """
        Specifies the backup options for the database, documented below
        """
        return pulumi.get(self, "remote_backup")

    @remote_backup.setter
    def remote_backup(self, value: Optional[pulumi.Input['SubscriptionDatabaseRemoteBackupArgs']]):
        pulumi.set(self, "remote_backup", value)

    @property
    @pulumi.getter(name="replicaOfs")
    def replica_ofs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
        database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
        Cannot be enabled when `support_oss_cluster_api` is enabled.
        """
        return pulumi.get(self, "replica_ofs")

    @replica_ofs.setter
    def replica_ofs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "replica_ofs", value)

    @property
    @pulumi.getter
    def replication(self) -> Optional[pulumi.Input[bool]]:
        """
        Databases replication. Default: ‘true’
        """
        return pulumi.get(self, "replication")

    @replication.setter
    def replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replication", value)

    @property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        """
        return pulumi.get(self, "source_ips")

    @source_ips.setter
    def source_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ips", value)

    @property
    @pulumi.getter(name="supportOssClusterApi")
    def support_oss_cluster_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        return pulumi.get(self, "support_oss_cluster_api")

    @support_oss_cluster_api.setter
    def support_oss_cluster_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_oss_cluster_api", value)


@pulumi.input_type
class _SubscriptionDatabaseState:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]]] = None,
                 average_item_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 client_ssl_certificate: Optional[pulumi.Input[str]] = None,
                 data_eviction: Optional[pulumi.Input[str]] = None,
                 data_persistence: Optional[pulumi.Input[str]] = None,
                 db_id: Optional[pulumi.Input[int]] = None,
                 enable_tls: Optional[pulumi.Input[bool]] = None,
                 external_endpoint_for_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 hashing_policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 memory_limit_in_gb: Optional[pulumi.Input[float]] = None,
                 modules: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 periodic_backup_path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 private_endpoint: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 public_endpoint: Optional[pulumi.Input[str]] = None,
                 remote_backup: Optional[pulumi.Input['SubscriptionDatabaseRemoteBackupArgs']] = None,
                 replica_ofs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replication: Optional[pulumi.Input[bool]] = None,
                 source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 support_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 throughput_measurement_by: Optional[pulumi.Input[str]] = None,
                 throughput_measurement_value: Optional[pulumi.Input[int]] = None):
        """
        Input properties used for looking up and filtering SubscriptionDatabase resources.
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]] alerts: A block defining Redis database alert, documented below, can be specified multiple times
        :param pulumi.Input[int] average_item_size_in_bytes: Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
               of the items stored in the database. Default: 1000
        :param pulumi.Input[str] client_ssl_certificate: SSL certificate to authenticate user connections
        :param pulumi.Input[str] data_eviction: The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        :param pulumi.Input[str] data_persistence: Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        :param pulumi.Input[int] db_id: Identifier of the database created
        :param pulumi.Input[bool] enable_tls: Use TLS for authentication. Default: ‘false’
        :param pulumi.Input[bool] external_endpoint_for_oss_cluster_api: Should use the external endpoint for open-source (OSS) Cluster API.
               Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hashing_policies: List of regular expression rules to shard the database by. See
               [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
               hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        :param pulumi.Input[float] memory_limit_in_gb: Maximum memory usage for this specific database
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]] modules: A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] name: A meaningful name to identify the database
        :param pulumi.Input[str] password: Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        :param pulumi.Input[str] periodic_backup_path: Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        :param pulumi.Input[int] port: TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] private_endpoint: Private endpoint to access the database
        :param pulumi.Input[str] protocol: The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] public_endpoint: Public endpoint to access the database
        :param pulumi.Input['SubscriptionDatabaseRemoteBackupArgs'] remote_backup: Specifies the backup options for the database, documented below
        :param pulumi.Input[Sequence[pulumi.Input[str]]] replica_ofs: Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
               database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
               Cannot be enabled when `support_oss_cluster_api` is enabled.
        :param pulumi.Input[bool] replication: Databases replication. Default: ‘true’
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ips: List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        :param pulumi.Input[str] subscription_id: The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[bool] support_oss_cluster_api: Support Redis open-source (OSS) Cluster API. Default: ‘false’
        :param pulumi.Input[str] throughput_measurement_by: Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        :param pulumi.Input[int] throughput_measurement_value: Throughput value (as applies to selected measurement method)
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if average_item_size_in_bytes is not None:
            pulumi.set(__self__, "average_item_size_in_bytes", average_item_size_in_bytes)
        if client_ssl_certificate is not None:
            pulumi.set(__self__, "client_ssl_certificate", client_ssl_certificate)
        if data_eviction is not None:
            pulumi.set(__self__, "data_eviction", data_eviction)
        if data_persistence is not None:
            pulumi.set(__self__, "data_persistence", data_persistence)
        if db_id is not None:
            pulumi.set(__self__, "db_id", db_id)
        if enable_tls is not None:
            pulumi.set(__self__, "enable_tls", enable_tls)
        if external_endpoint_for_oss_cluster_api is not None:
            pulumi.set(__self__, "external_endpoint_for_oss_cluster_api", external_endpoint_for_oss_cluster_api)
        if hashing_policies is not None:
            pulumi.set(__self__, "hashing_policies", hashing_policies)
        if memory_limit_in_gb is not None:
            pulumi.set(__self__, "memory_limit_in_gb", memory_limit_in_gb)
        if modules is not None:
            pulumi.set(__self__, "modules", modules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if periodic_backup_path is not None:
            warnings.warn("""Use `remote_backup` block instead""", DeprecationWarning)
            pulumi.log.warn("""periodic_backup_path is deprecated: Use `remote_backup` block instead""")
        if periodic_backup_path is not None:
            pulumi.set(__self__, "periodic_backup_path", periodic_backup_path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)
        if remote_backup is not None:
            pulumi.set(__self__, "remote_backup", remote_backup)
        if replica_ofs is not None:
            pulumi.set(__self__, "replica_ofs", replica_ofs)
        if replication is not None:
            pulumi.set(__self__, "replication", replication)
        if source_ips is not None:
            pulumi.set(__self__, "source_ips", source_ips)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if support_oss_cluster_api is not None:
            pulumi.set(__self__, "support_oss_cluster_api", support_oss_cluster_api)
        if throughput_measurement_by is not None:
            pulumi.set(__self__, "throughput_measurement_by", throughput_measurement_by)
        if throughput_measurement_value is not None:
            pulumi.set(__self__, "throughput_measurement_value", throughput_measurement_value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]]]:
        """
        A block defining Redis database alert, documented below, can be specified multiple times
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="averageItemSizeInBytes")
    def average_item_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
        of the items stored in the database. Default: 1000
        """
        return pulumi.get(self, "average_item_size_in_bytes")

    @average_item_size_in_bytes.setter
    def average_item_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "average_item_size_in_bytes", value)

    @property
    @pulumi.getter(name="clientSslCertificate")
    def client_ssl_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        SSL certificate to authenticate user connections
        """
        return pulumi.get(self, "client_ssl_certificate")

    @client_ssl_certificate.setter
    def client_ssl_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_ssl_certificate", value)

    @property
    @pulumi.getter(name="dataEviction")
    def data_eviction(self) -> Optional[pulumi.Input[str]]:
        """
        The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        """
        return pulumi.get(self, "data_eviction")

    @data_eviction.setter
    def data_eviction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_eviction", value)

    @property
    @pulumi.getter(name="dataPersistence")
    def data_persistence(self) -> Optional[pulumi.Input[str]]:
        """
        Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        """
        return pulumi.get(self, "data_persistence")

    @data_persistence.setter
    def data_persistence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_persistence", value)

    @property
    @pulumi.getter(name="dbId")
    def db_id(self) -> Optional[pulumi.Input[int]]:
        """
        Identifier of the database created
        """
        return pulumi.get(self, "db_id")

    @db_id.setter
    def db_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "db_id", value)

    @property
    @pulumi.getter(name="enableTls")
    def enable_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Use TLS for authentication. Default: ‘false’
        """
        return pulumi.get(self, "enable_tls")

    @enable_tls.setter
    def enable_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_tls", value)

    @property
    @pulumi.getter(name="externalEndpointForOssClusterApi")
    def external_endpoint_for_oss_cluster_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Should use the external endpoint for open-source (OSS) Cluster API.
        Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        """
        return pulumi.get(self, "external_endpoint_for_oss_cluster_api")

    @external_endpoint_for_oss_cluster_api.setter
    def external_endpoint_for_oss_cluster_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external_endpoint_for_oss_cluster_api", value)

    @property
    @pulumi.getter(name="hashingPolicies")
    def hashing_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expression rules to shard the database by. See
        [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
        hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        """
        return pulumi.get(self, "hashing_policies")

    @hashing_policies.setter
    def hashing_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hashing_policies", value)

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum memory usage for this specific database
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @memory_limit_in_gb.setter
    def memory_limit_in_gb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_limit_in_gb", value)

    @property
    @pulumi.getter
    def modules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]]]:
        """
        A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "modules")

    @modules.setter
    def modules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionDatabaseModuleArgs']]]]):
        pulumi.set(self, "modules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A meaningful name to identify the database
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="periodicBackupPath")
    def periodic_backup_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        """
        warnings.warn("""Use `remote_backup` block instead""", DeprecationWarning)
        pulumi.log.warn("""periodic_backup_path is deprecated: Use `remote_backup` block instead""")

        return pulumi.get(self, "periodic_backup_path")

    @periodic_backup_path.setter
    def periodic_backup_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "periodic_backup_path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Private endpoint to access the database
        """
        return pulumi.get(self, "private_endpoint")

    @private_endpoint.setter
    def private_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_endpoint", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Public endpoint to access the database
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_endpoint", value)

    @property
    @pulumi.getter(name="remoteBackup")
    def remote_backup(self) -> Optional[pulumi.Input['SubscriptionDatabaseRemoteBackupArgs']]:
        """
        Specifies the backup options for the database, documented below
        """
        return pulumi.get(self, "remote_backup")

    @remote_backup.setter
    def remote_backup(self, value: Optional[pulumi.Input['SubscriptionDatabaseRemoteBackupArgs']]):
        pulumi.set(self, "remote_backup", value)

    @property
    @pulumi.getter(name="replicaOfs")
    def replica_ofs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
        database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
        Cannot be enabled when `support_oss_cluster_api` is enabled.
        """
        return pulumi.get(self, "replica_ofs")

    @replica_ofs.setter
    def replica_ofs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "replica_ofs", value)

    @property
    @pulumi.getter
    def replication(self) -> Optional[pulumi.Input[bool]]:
        """
        Databases replication. Default: ‘true’
        """
        return pulumi.get(self, "replication")

    @replication.setter
    def replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replication", value)

    @property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        """
        return pulumi.get(self, "source_ips")

    @source_ips.setter
    def source_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ips", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="supportOssClusterApi")
    def support_oss_cluster_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        return pulumi.get(self, "support_oss_cluster_api")

    @support_oss_cluster_api.setter
    def support_oss_cluster_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_oss_cluster_api", value)

    @property
    @pulumi.getter(name="throughputMeasurementBy")
    def throughput_measurement_by(self) -> Optional[pulumi.Input[str]]:
        """
        Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        """
        return pulumi.get(self, "throughput_measurement_by")

    @throughput_measurement_by.setter
    def throughput_measurement_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "throughput_measurement_by", value)

    @property
    @pulumi.getter(name="throughputMeasurementValue")
    def throughput_measurement_value(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput value (as applies to selected measurement method)
        """
        return pulumi.get(self, "throughput_measurement_value")

    @throughput_measurement_value.setter
    def throughput_measurement_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput_measurement_value", value)


class SubscriptionDatabase(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseAlertArgs']]]]] = None,
                 average_item_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 client_ssl_certificate: Optional[pulumi.Input[str]] = None,
                 data_eviction: Optional[pulumi.Input[str]] = None,
                 data_persistence: Optional[pulumi.Input[str]] = None,
                 enable_tls: Optional[pulumi.Input[bool]] = None,
                 external_endpoint_for_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 hashing_policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 memory_limit_in_gb: Optional[pulumi.Input[float]] = None,
                 modules: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseModuleArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 periodic_backup_path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 remote_backup: Optional[pulumi.Input[pulumi.InputType['SubscriptionDatabaseRemoteBackupArgs']]] = None,
                 replica_ofs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replication: Optional[pulumi.Input[bool]] = None,
                 source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 support_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 throughput_measurement_by: Optional[pulumi.Input[str]] = None,
                 throughput_measurement_value: Optional[pulumi.Input[int]] = None,
                 __props__=None):
        """
        Creates a Database within a specified Subscription in your Redis Enterprise Cloud Account.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_rediscloud as rediscloud

        card = rediscloud.get_payment_method(card_type="Visa")
        subscription_resource = rediscloud.Subscription("subscription-resource",
            payment_method="credit-card",
            payment_method_id=card.id,
            memory_storage="ram",
            cloud_provider=rediscloud.SubscriptionCloudProviderArgs(
                provider=data["rediscloud_cloud_account"]["account"]["provider_type"],
                regions=[rediscloud.SubscriptionCloudProviderRegionArgs(
                    region="eu-west-1",
                    multiple_availability_zones=True,
                    networking_deployment_cidr="10.0.0.0/24",
                    preferred_availability_zones=["euw1-az1, euw1-az2, euw1-az3"],
                )],
            ),
            creation_plan=rediscloud.SubscriptionCreationPlanArgs(
                memory_limit_in_gb=15,
                quantity=1,
                replication=True,
                throughput_measurement_by="operations-per-second",
                throughput_measurement_value=20000,
                modules=["RedisJSON"],
            ))
        # The primary database to provision
        database_resource = rediscloud.SubscriptionDatabase("database-resource",
            subscription_id=subscription_resource.id,
            memory_limit_in_gb=15,
            data_persistence="aof-every-write",
            throughput_measurement_by="operations-per-second",
            throughput_measurement_value=20000,
            replication=True,
            modules=[rediscloud.SubscriptionDatabaseModuleArgs(
                name="RedisJSON",
            )],
            alerts=[rediscloud.SubscriptionDatabaseAlertArgs(
                name="dataset-size",
                value=40,
            )],
            opts=pulumi.ResourceOptions(depends_on=[subscription_resource]))
        ```

        ## Import

        `rediscloud_subscription_database` can be imported using the ID of the subscription and the ID of the database in the format {subscription ID}/{database ID}, e.g.

        ```sh
         $ pulumi import rediscloud:index/subscriptionDatabase:SubscriptionDatabase database-resource 123456/12345678
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseAlertArgs']]]] alerts: A block defining Redis database alert, documented below, can be specified multiple times
        :param pulumi.Input[int] average_item_size_in_bytes: Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
               of the items stored in the database. Default: 1000
        :param pulumi.Input[str] client_ssl_certificate: SSL certificate to authenticate user connections
        :param pulumi.Input[str] data_eviction: The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        :param pulumi.Input[str] data_persistence: Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        :param pulumi.Input[bool] enable_tls: Use TLS for authentication. Default: ‘false’
        :param pulumi.Input[bool] external_endpoint_for_oss_cluster_api: Should use the external endpoint for open-source (OSS) Cluster API.
               Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hashing_policies: List of regular expression rules to shard the database by. See
               [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
               hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        :param pulumi.Input[float] memory_limit_in_gb: Maximum memory usage for this specific database
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseModuleArgs']]]] modules: A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] name: A meaningful name to identify the database
        :param pulumi.Input[str] password: Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        :param pulumi.Input[str] periodic_backup_path: Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        :param pulumi.Input[int] port: TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] protocol: The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[pulumi.InputType['SubscriptionDatabaseRemoteBackupArgs']] remote_backup: Specifies the backup options for the database, documented below
        :param pulumi.Input[Sequence[pulumi.Input[str]]] replica_ofs: Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
               database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
               Cannot be enabled when `support_oss_cluster_api` is enabled.
        :param pulumi.Input[bool] replication: Databases replication. Default: ‘true’
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ips: List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        :param pulumi.Input[str] subscription_id: The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[bool] support_oss_cluster_api: Support Redis open-source (OSS) Cluster API. Default: ‘false’
        :param pulumi.Input[str] throughput_measurement_by: Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        :param pulumi.Input[int] throughput_measurement_value: Throughput value (as applies to selected measurement method)
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: SubscriptionDatabaseArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Creates a Database within a specified Subscription in your Redis Enterprise Cloud Account.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_rediscloud as rediscloud

        card = rediscloud.get_payment_method(card_type="Visa")
        subscription_resource = rediscloud.Subscription("subscription-resource",
            payment_method="credit-card",
            payment_method_id=card.id,
            memory_storage="ram",
            cloud_provider=rediscloud.SubscriptionCloudProviderArgs(
                provider=data["rediscloud_cloud_account"]["account"]["provider_type"],
                regions=[rediscloud.SubscriptionCloudProviderRegionArgs(
                    region="eu-west-1",
                    multiple_availability_zones=True,
                    networking_deployment_cidr="10.0.0.0/24",
                    preferred_availability_zones=["euw1-az1, euw1-az2, euw1-az3"],
                )],
            ),
            creation_plan=rediscloud.SubscriptionCreationPlanArgs(
                memory_limit_in_gb=15,
                quantity=1,
                replication=True,
                throughput_measurement_by="operations-per-second",
                throughput_measurement_value=20000,
                modules=["RedisJSON"],
            ))
        # The primary database to provision
        database_resource = rediscloud.SubscriptionDatabase("database-resource",
            subscription_id=subscription_resource.id,
            memory_limit_in_gb=15,
            data_persistence="aof-every-write",
            throughput_measurement_by="operations-per-second",
            throughput_measurement_value=20000,
            replication=True,
            modules=[rediscloud.SubscriptionDatabaseModuleArgs(
                name="RedisJSON",
            )],
            alerts=[rediscloud.SubscriptionDatabaseAlertArgs(
                name="dataset-size",
                value=40,
            )],
            opts=pulumi.ResourceOptions(depends_on=[subscription_resource]))
        ```

        ## Import

        `rediscloud_subscription_database` can be imported using the ID of the subscription and the ID of the database in the format {subscription ID}/{database ID}, e.g.

        ```sh
         $ pulumi import rediscloud:index/subscriptionDatabase:SubscriptionDatabase database-resource 123456/12345678
        ```

        :param str resource_name: The name of the resource.
        :param SubscriptionDatabaseArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(SubscriptionDatabaseArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseAlertArgs']]]]] = None,
                 average_item_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 client_ssl_certificate: Optional[pulumi.Input[str]] = None,
                 data_eviction: Optional[pulumi.Input[str]] = None,
                 data_persistence: Optional[pulumi.Input[str]] = None,
                 enable_tls: Optional[pulumi.Input[bool]] = None,
                 external_endpoint_for_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 hashing_policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 memory_limit_in_gb: Optional[pulumi.Input[float]] = None,
                 modules: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseModuleArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 periodic_backup_path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 remote_backup: Optional[pulumi.Input[pulumi.InputType['SubscriptionDatabaseRemoteBackupArgs']]] = None,
                 replica_ofs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replication: Optional[pulumi.Input[bool]] = None,
                 source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 support_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
                 throughput_measurement_by: Optional[pulumi.Input[str]] = None,
                 throughput_measurement_value: Optional[pulumi.Input[int]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = SubscriptionDatabaseArgs.__new__(SubscriptionDatabaseArgs)

            __props__.__dict__["alerts"] = alerts
            __props__.__dict__["average_item_size_in_bytes"] = average_item_size_in_bytes
            __props__.__dict__["client_ssl_certificate"] = client_ssl_certificate
            __props__.__dict__["data_eviction"] = data_eviction
            __props__.__dict__["data_persistence"] = data_persistence
            __props__.__dict__["enable_tls"] = enable_tls
            __props__.__dict__["external_endpoint_for_oss_cluster_api"] = external_endpoint_for_oss_cluster_api
            __props__.__dict__["hashing_policies"] = hashing_policies
            if memory_limit_in_gb is None and not opts.urn:
                raise TypeError("Missing required property 'memory_limit_in_gb'")
            __props__.__dict__["memory_limit_in_gb"] = memory_limit_in_gb
            __props__.__dict__["modules"] = modules
            __props__.__dict__["name"] = name
            __props__.__dict__["password"] = None if password is None else pulumi.Output.secret(password)
            if periodic_backup_path is not None and not opts.urn:
                warnings.warn("""Use `remote_backup` block instead""", DeprecationWarning)
                pulumi.log.warn("""periodic_backup_path is deprecated: Use `remote_backup` block instead""")
            __props__.__dict__["periodic_backup_path"] = periodic_backup_path
            __props__.__dict__["port"] = port
            __props__.__dict__["protocol"] = protocol
            __props__.__dict__["remote_backup"] = remote_backup
            __props__.__dict__["replica_ofs"] = replica_ofs
            __props__.__dict__["replication"] = replication
            __props__.__dict__["source_ips"] = source_ips
            if subscription_id is None and not opts.urn:
                raise TypeError("Missing required property 'subscription_id'")
            __props__.__dict__["subscription_id"] = subscription_id
            __props__.__dict__["support_oss_cluster_api"] = support_oss_cluster_api
            if throughput_measurement_by is None and not opts.urn:
                raise TypeError("Missing required property 'throughput_measurement_by'")
            __props__.__dict__["throughput_measurement_by"] = throughput_measurement_by
            if throughput_measurement_value is None and not opts.urn:
                raise TypeError("Missing required property 'throughput_measurement_value'")
            __props__.__dict__["throughput_measurement_value"] = throughput_measurement_value
            __props__.__dict__["db_id"] = None
            __props__.__dict__["private_endpoint"] = None
            __props__.__dict__["public_endpoint"] = None
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["password"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(SubscriptionDatabase, __self__).__init__(
            'rediscloud:index/subscriptionDatabase:SubscriptionDatabase',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            alerts: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseAlertArgs']]]]] = None,
            average_item_size_in_bytes: Optional[pulumi.Input[int]] = None,
            client_ssl_certificate: Optional[pulumi.Input[str]] = None,
            data_eviction: Optional[pulumi.Input[str]] = None,
            data_persistence: Optional[pulumi.Input[str]] = None,
            db_id: Optional[pulumi.Input[int]] = None,
            enable_tls: Optional[pulumi.Input[bool]] = None,
            external_endpoint_for_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
            hashing_policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            memory_limit_in_gb: Optional[pulumi.Input[float]] = None,
            modules: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseModuleArgs']]]]] = None,
            name: Optional[pulumi.Input[str]] = None,
            password: Optional[pulumi.Input[str]] = None,
            periodic_backup_path: Optional[pulumi.Input[str]] = None,
            port: Optional[pulumi.Input[int]] = None,
            private_endpoint: Optional[pulumi.Input[str]] = None,
            protocol: Optional[pulumi.Input[str]] = None,
            public_endpoint: Optional[pulumi.Input[str]] = None,
            remote_backup: Optional[pulumi.Input[pulumi.InputType['SubscriptionDatabaseRemoteBackupArgs']]] = None,
            replica_ofs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            replication: Optional[pulumi.Input[bool]] = None,
            source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            subscription_id: Optional[pulumi.Input[str]] = None,
            support_oss_cluster_api: Optional[pulumi.Input[bool]] = None,
            throughput_measurement_by: Optional[pulumi.Input[str]] = None,
            throughput_measurement_value: Optional[pulumi.Input[int]] = None) -> 'SubscriptionDatabase':
        """
        Get an existing SubscriptionDatabase resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseAlertArgs']]]] alerts: A block defining Redis database alert, documented below, can be specified multiple times
        :param pulumi.Input[int] average_item_size_in_bytes: Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
               of the items stored in the database. Default: 1000
        :param pulumi.Input[str] client_ssl_certificate: SSL certificate to authenticate user connections
        :param pulumi.Input[str] data_eviction: The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        :param pulumi.Input[str] data_persistence: Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        :param pulumi.Input[int] db_id: Identifier of the database created
        :param pulumi.Input[bool] enable_tls: Use TLS for authentication. Default: ‘false’
        :param pulumi.Input[bool] external_endpoint_for_oss_cluster_api: Should use the external endpoint for open-source (OSS) Cluster API.
               Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hashing_policies: List of regular expression rules to shard the database by. See
               [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
               hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        :param pulumi.Input[float] memory_limit_in_gb: Maximum memory usage for this specific database
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SubscriptionDatabaseModuleArgs']]]] modules: A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] name: A meaningful name to identify the database
        :param pulumi.Input[str] password: Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        :param pulumi.Input[str] periodic_backup_path: Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        :param pulumi.Input[int] port: TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] private_endpoint: Private endpoint to access the database
        :param pulumi.Input[str] protocol: The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] public_endpoint: Public endpoint to access the database
        :param pulumi.Input[pulumi.InputType['SubscriptionDatabaseRemoteBackupArgs']] remote_backup: Specifies the backup options for the database, documented below
        :param pulumi.Input[Sequence[pulumi.Input[str]]] replica_ofs: Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
               database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
               Cannot be enabled when `support_oss_cluster_api` is enabled.
        :param pulumi.Input[bool] replication: Databases replication. Default: ‘true’
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ips: List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        :param pulumi.Input[str] subscription_id: The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[bool] support_oss_cluster_api: Support Redis open-source (OSS) Cluster API. Default: ‘false’
        :param pulumi.Input[str] throughput_measurement_by: Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        :param pulumi.Input[int] throughput_measurement_value: Throughput value (as applies to selected measurement method)
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _SubscriptionDatabaseState.__new__(_SubscriptionDatabaseState)

        __props__.__dict__["alerts"] = alerts
        __props__.__dict__["average_item_size_in_bytes"] = average_item_size_in_bytes
        __props__.__dict__["client_ssl_certificate"] = client_ssl_certificate
        __props__.__dict__["data_eviction"] = data_eviction
        __props__.__dict__["data_persistence"] = data_persistence
        __props__.__dict__["db_id"] = db_id
        __props__.__dict__["enable_tls"] = enable_tls
        __props__.__dict__["external_endpoint_for_oss_cluster_api"] = external_endpoint_for_oss_cluster_api
        __props__.__dict__["hashing_policies"] = hashing_policies
        __props__.__dict__["memory_limit_in_gb"] = memory_limit_in_gb
        __props__.__dict__["modules"] = modules
        __props__.__dict__["name"] = name
        __props__.__dict__["password"] = password
        __props__.__dict__["periodic_backup_path"] = periodic_backup_path
        __props__.__dict__["port"] = port
        __props__.__dict__["private_endpoint"] = private_endpoint
        __props__.__dict__["protocol"] = protocol
        __props__.__dict__["public_endpoint"] = public_endpoint
        __props__.__dict__["remote_backup"] = remote_backup
        __props__.__dict__["replica_ofs"] = replica_ofs
        __props__.__dict__["replication"] = replication
        __props__.__dict__["source_ips"] = source_ips
        __props__.__dict__["subscription_id"] = subscription_id
        __props__.__dict__["support_oss_cluster_api"] = support_oss_cluster_api
        __props__.__dict__["throughput_measurement_by"] = throughput_measurement_by
        __props__.__dict__["throughput_measurement_value"] = throughput_measurement_value
        return SubscriptionDatabase(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def alerts(self) -> pulumi.Output[Optional[Sequence['outputs.SubscriptionDatabaseAlert']]]:
        """
        A block defining Redis database alert, documented below, can be specified multiple times
        """
        return pulumi.get(self, "alerts")

    @property
    @pulumi.getter(name="averageItemSizeInBytes")
    def average_item_size_in_bytes(self) -> pulumi.Output[Optional[int]]:
        """
        Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes)
        of the items stored in the database. Default: 1000
        """
        return pulumi.get(self, "average_item_size_in_bytes")

    @property
    @pulumi.getter(name="clientSslCertificate")
    def client_ssl_certificate(self) -> pulumi.Output[Optional[str]]:
        """
        SSL certificate to authenticate user connections
        """
        return pulumi.get(self, "client_ssl_certificate")

    @property
    @pulumi.getter(name="dataEviction")
    def data_eviction(self) -> pulumi.Output[Optional[str]]:
        """
        The data items eviction policy (either: 'allkeys-lru', 'allkeys-lfu', 'allkeys-random', 'volatile-lru', 'volatile-lfu', 'volatile-random', 'volatile-ttl' or 'noeviction'). Default: 'volatile-lru'
        """
        return pulumi.get(self, "data_eviction")

    @property
    @pulumi.getter(name="dataPersistence")
    def data_persistence(self) -> pulumi.Output[Optional[str]]:
        """
        Rate of database's storage data persistence (either: 'none', 'aof-every-1-second', 'aof-every-write', 'snapshot-every-1-hour', 'snapshot-every-6-hours' or 'snapshot-every-12-hours'). Default: ‘none’
        """
        return pulumi.get(self, "data_persistence")

    @property
    @pulumi.getter(name="dbId")
    def db_id(self) -> pulumi.Output[int]:
        """
        Identifier of the database created
        """
        return pulumi.get(self, "db_id")

    @property
    @pulumi.getter(name="enableTls")
    def enable_tls(self) -> pulumi.Output[Optional[bool]]:
        """
        Use TLS for authentication. Default: ‘false’
        """
        return pulumi.get(self, "enable_tls")

    @property
    @pulumi.getter(name="externalEndpointForOssClusterApi")
    def external_endpoint_for_oss_cluster_api(self) -> pulumi.Output[Optional[bool]]:
        """
        Should use the external endpoint for open-source (OSS) Cluster API.
        Can only be enabled if OSS Cluster API support is enabled. Default: 'false'
        """
        return pulumi.get(self, "external_endpoint_for_oss_cluster_api")

    @property
    @pulumi.getter(name="hashingPolicies")
    def hashing_policies(self) -> pulumi.Output[Sequence[str]]:
        """
        List of regular expression rules to shard the database by. See
        [the documentation on clustering](https://docs.redislabs.com/latest/rc/concepts/clustering/) for more information on the
        hashing policy. This cannot be set when `support_oss_cluster_api` is set to true.
        """
        return pulumi.get(self, "hashing_policies")

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> pulumi.Output[float]:
        """
        Maximum memory usage for this specific database
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @property
    @pulumi.getter
    def modules(self) -> pulumi.Output[Optional[Sequence['outputs.SubscriptionDatabaseModule']]]:
        """
        A list of modules objects, documented below. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "modules")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        A meaningful name to identify the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> pulumi.Output[str]:
        """
        Password to access the database. If omitted, a random 32 character long alphanumeric password will be automatically generated
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="periodicBackupPath")
    def periodic_backup_path(self) -> pulumi.Output[Optional[str]]:
        """
        Path that will be used to store database backup files. **Deprecated: Use `remote_backup` block instead**
        """
        warnings.warn("""Use `remote_backup` block instead""", DeprecationWarning)
        pulumi.log.warn("""periodic_backup_path is deprecated: Use `remote_backup` block instead""")

        return pulumi.get(self, "periodic_backup_path")

    @property
    @pulumi.getter
    def port(self) -> pulumi.Output[Optional[int]]:
        """
        TCP port on which the database is available - must be between 10000 and 19999. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> pulumi.Output[str]:
        """
        Private endpoint to access the database
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Output[Optional[str]]:
        """
        The protocol that will be used to access the database, (either ‘redis’ or ‘memcached’) Default: ‘redis’. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> pulumi.Output[str]:
        """
        Public endpoint to access the database
        """
        return pulumi.get(self, "public_endpoint")

    @property
    @pulumi.getter(name="remoteBackup")
    def remote_backup(self) -> pulumi.Output[Optional['outputs.SubscriptionDatabaseRemoteBackup']]:
        """
        Specifies the backup options for the database, documented below
        """
        return pulumi.get(self, "remote_backup")

    @property
    @pulumi.getter(name="replicaOfs")
    def replica_ofs(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        Set of Redis database URIs, in the format `redis://user:password@host:port`, that this
        database will be a replica of. If the URI provided is Redis Labs Cloud instance, only host and port should be provided.
        Cannot be enabled when `support_oss_cluster_api` is enabled.
        """
        return pulumi.get(self, "replica_ofs")

    @property
    @pulumi.getter
    def replication(self) -> pulumi.Output[Optional[bool]]:
        """
        Databases replication. Default: ‘true’
        """
        return pulumi.get(self, "replication")

    @property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        List of source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: [‘192.168.10.0/32’, ‘192.168.12.0/24’])
        """
        return pulumi.get(self, "source_ips")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Output[str]:
        """
        The ID of the subscription to create the database in. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="supportOssClusterApi")
    def support_oss_cluster_api(self) -> pulumi.Output[Optional[bool]]:
        """
        Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        return pulumi.get(self, "support_oss_cluster_api")

    @property
    @pulumi.getter(name="throughputMeasurementBy")
    def throughput_measurement_by(self) -> pulumi.Output[str]:
        """
        Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
        """
        return pulumi.get(self, "throughput_measurement_by")

    @property
    @pulumi.getter(name="throughputMeasurementValue")
    def throughput_measurement_value(self) -> pulumi.Output[int]:
        """
        Throughput value (as applies to selected measurement method)
        """
        return pulumi.get(self, "throughput_measurement_value")

