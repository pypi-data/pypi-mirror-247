# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AclRoleRuleArgs',
    'AclRoleRuleDatabaseArgs',
    'ActiveActiveSubscriptionCreationPlanArgs',
    'ActiveActiveSubscriptionCreationPlanRegionArgs',
    'ActiveActiveSubscriptionDatabaseGlobalAlertArgs',
    'ActiveActiveSubscriptionDatabaseOverrideRegionArgs',
    'ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs',
    'ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackupArgs',
    'ActiveActiveSubscriptionRegionsRegionArgs',
    'ActiveActiveSubscriptionRegionsRegionDatabaseArgs',
    'SubscriptionAllowlistArgs',
    'SubscriptionCloudProviderArgs',
    'SubscriptionCloudProviderRegionArgs',
    'SubscriptionCloudProviderRegionNetworkArgs',
    'SubscriptionCreationPlanArgs',
    'SubscriptionDatabaseAlertArgs',
    'SubscriptionDatabaseModuleArgs',
    'SubscriptionDatabaseRemoteBackupArgs',
]

@pulumi.input_type
class AclRoleRuleArgs:
    def __init__(__self__, *,
                 databases: pulumi.Input[Sequence[pulumi.Input['AclRoleRuleDatabaseArgs']]],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AclRoleRuleDatabaseArgs']]] databases: a set of database association objects, documented below.
        :param pulumi.Input[str] name: Name of the Rule.
        """
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def databases(self) -> pulumi.Input[Sequence[pulumi.Input['AclRoleRuleDatabaseArgs']]]:
        """
        a set of database association objects, documented below.
        """
        return pulumi.get(self, "databases")

    @databases.setter
    def databases(self, value: pulumi.Input[Sequence[pulumi.Input['AclRoleRuleDatabaseArgs']]]):
        pulumi.set(self, "databases", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AclRoleRuleDatabaseArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[int],
                 subscription: pulumi.Input[int],
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] database: ID of the database to which the Rule should apply.
        :param pulumi.Input[int] subscription: ID of the subscription containing the database.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: For databases in Active/Active subscriptions only, the regions to which the Rule should apply.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "subscription", subscription)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[int]:
        """
        ID of the database to which the Rule should apply.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[int]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def subscription(self) -> pulumi.Input[int]:
        """
        ID of the subscription containing the database.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: pulumi.Input[int]):
        pulumi.set(self, "subscription", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        For databases in Active/Active subscriptions only, the regions to which the Rule should apply.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "regions", value)


@pulumi.input_type
class ActiveActiveSubscriptionCreationPlanArgs:
    def __init__(__self__, *,
                 memory_limit_in_gb: pulumi.Input[float],
                 quantity: pulumi.Input[int],
                 regions: pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionCreationPlanRegionArgs']]]):
        """
        :param pulumi.Input[float] memory_limit_in_gb: Maximum memory usage that will be used for your largest planned database, including replication and other overhead
        :param pulumi.Input[int] quantity: The planned number of databases in the subscription.
        """
        pulumi.set(__self__, "memory_limit_in_gb", memory_limit_in_gb)
        pulumi.set(__self__, "quantity", quantity)
        pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> pulumi.Input[float]:
        """
        Maximum memory usage that will be used for your largest planned database, including replication and other overhead
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @memory_limit_in_gb.setter
    def memory_limit_in_gb(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory_limit_in_gb", value)

    @property
    @pulumi.getter
    def quantity(self) -> pulumi.Input[int]:
        """
        The planned number of databases in the subscription.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: pulumi.Input[int]):
        pulumi.set(self, "quantity", value)

    @property
    @pulumi.getter
    def regions(self) -> pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionCreationPlanRegionArgs']]]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionCreationPlanRegionArgs']]]):
        pulumi.set(self, "regions", value)


@pulumi.input_type
class ActiveActiveSubscriptionCreationPlanRegionArgs:
    def __init__(__self__, *,
                 networking_deployment_cidr: pulumi.Input[str],
                 read_operations_per_second: pulumi.Input[int],
                 region: pulumi.Input[str],
                 write_operations_per_second: pulumi.Input[int]):
        """
        :param pulumi.Input[str] networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        :param pulumi.Input[int] read_operations_per_second: Throughput measurement for an active-active subscription
               
               > **Note:** If changes are made to attributes in the subscription which require the subscription to be recreated (such as `cloud_provider` or `payment_method`), the creation_plan will need to be defined in order to change these attributes. This is because the creation_plan is always required when a subscription is created.
        :param pulumi.Input[str] region: Deployment region as defined by cloud provider
        :param pulumi.Input[int] write_operations_per_second: Throughput measurement for an active-active subscription
        """
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "read_operations_per_second", read_operations_per_second)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "write_operations_per_second", write_operations_per_second)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> pulumi.Input[str]:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @networking_deployment_cidr.setter
    def networking_deployment_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "networking_deployment_cidr", value)

    @property
    @pulumi.getter(name="readOperationsPerSecond")
    def read_operations_per_second(self) -> pulumi.Input[int]:
        """
        Throughput measurement for an active-active subscription

        > **Note:** If changes are made to attributes in the subscription which require the subscription to be recreated (such as `cloud_provider` or `payment_method`), the creation_plan will need to be defined in order to change these attributes. This is because the creation_plan is always required when a subscription is created.
        """
        return pulumi.get(self, "read_operations_per_second")

    @read_operations_per_second.setter
    def read_operations_per_second(self, value: pulumi.Input[int]):
        pulumi.set(self, "read_operations_per_second", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Deployment region as defined by cloud provider
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="writeOperationsPerSecond")
    def write_operations_per_second(self) -> pulumi.Input[int]:
        """
        Throughput measurement for an active-active subscription
        """
        return pulumi.get(self, "write_operations_per_second")

    @write_operations_per_second.setter
    def write_operations_per_second(self, value: pulumi.Input[int]):
        pulumi.set(self, "write_operations_per_second", value)


@pulumi.input_type
class ActiveActiveSubscriptionDatabaseGlobalAlertArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] name: A meaningful name to identify the database. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[int] value: Alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A meaningful name to identify the database. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Alert value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ActiveActiveSubscriptionDatabaseOverrideRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 override_global_alerts: Optional[pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs']]]] = None,
                 override_global_data_persistence: Optional[pulumi.Input[str]] = None,
                 override_global_password: Optional[pulumi.Input[str]] = None,
                 override_global_source_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 remote_backup: Optional[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackupArgs']] = None):
        """
        :param pulumi.Input[str] name: Region name.
        :param pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs']]] override_global_alerts: A block defining Redis regional instance of an Active-Active database alert, documented below, can be specified multiple times
        :param pulumi.Input[str] override_global_data_persistence: Regional instance of an Active-Active database data persistence rate (in persistent storage)
        :param pulumi.Input[str] override_global_password: If specified, this regional instance of an Active-Active database password will be used to access the database
        :param pulumi.Input[Sequence[pulumi.Input[str]]] override_global_source_ips: List of regional instance of an Active-Active database source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: ['192.168.10.0/32', '192.168.12.0/24'] )
        :param pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackupArgs'] remote_backup: Specifies the backup options for the database in this region, documented below
        """
        pulumi.set(__self__, "name", name)
        if override_global_alerts is not None:
            pulumi.set(__self__, "override_global_alerts", override_global_alerts)
        if override_global_data_persistence is not None:
            pulumi.set(__self__, "override_global_data_persistence", override_global_data_persistence)
        if override_global_password is not None:
            pulumi.set(__self__, "override_global_password", override_global_password)
        if override_global_source_ips is not None:
            pulumi.set(__self__, "override_global_source_ips", override_global_source_ips)
        if remote_backup is not None:
            pulumi.set(__self__, "remote_backup", remote_backup)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Region name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideGlobalAlerts")
    def override_global_alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs']]]]:
        """
        A block defining Redis regional instance of an Active-Active database alert, documented below, can be specified multiple times
        """
        return pulumi.get(self, "override_global_alerts")

    @override_global_alerts.setter
    def override_global_alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs']]]]):
        pulumi.set(self, "override_global_alerts", value)

    @property
    @pulumi.getter(name="overrideGlobalDataPersistence")
    def override_global_data_persistence(self) -> Optional[pulumi.Input[str]]:
        """
        Regional instance of an Active-Active database data persistence rate (in persistent storage)
        """
        return pulumi.get(self, "override_global_data_persistence")

    @override_global_data_persistence.setter
    def override_global_data_persistence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_global_data_persistence", value)

    @property
    @pulumi.getter(name="overrideGlobalPassword")
    def override_global_password(self) -> Optional[pulumi.Input[str]]:
        """
        If specified, this regional instance of an Active-Active database password will be used to access the database
        """
        return pulumi.get(self, "override_global_password")

    @override_global_password.setter
    def override_global_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_global_password", value)

    @property
    @pulumi.getter(name="overrideGlobalSourceIps")
    def override_global_source_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regional instance of an Active-Active database source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: ['192.168.10.0/32', '192.168.12.0/24'] )
        """
        return pulumi.get(self, "override_global_source_ips")

    @override_global_source_ips.setter
    def override_global_source_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "override_global_source_ips", value)

    @property
    @pulumi.getter(name="remoteBackup")
    def remote_backup(self) -> Optional[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackupArgs']]:
        """
        Specifies the backup options for the database in this region, documented below
        """
        return pulumi.get(self, "remote_backup")

    @remote_backup.setter
    def remote_backup(self, value: Optional[pulumi.Input['ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackupArgs']]):
        pulumi.set(self, "remote_backup", value)


@pulumi.input_type
class ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] name: Alert name
        :param pulumi.Input[int] value: Alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Alert name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Alert value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackupArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 storage_path: pulumi.Input[str],
                 storage_type: pulumi.Input[str],
                 time_utc: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] interval: Defines the interval between backups. Should be in the following format 'every-x-hours'. x is one of [24,12,6,4,2,1]. For example: 'every-4-hours'
        :param pulumi.Input[str] storage_path: Defines a URI representing the backup storage location
        :param pulumi.Input[str] storage_type: Defines the provider of the storage location
        :param pulumi.Input[str] time_utc: Defines the hour automatic backups are made - only applicable when the interval is `every-12-hours` or `every-24-hours`. For example: '14:00'
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "storage_path", storage_path)
        pulumi.set(__self__, "storage_type", storage_type)
        if time_utc is not None:
            pulumi.set(__self__, "time_utc", time_utc)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        Defines the interval between backups. Should be in the following format 'every-x-hours'. x is one of [24,12,6,4,2,1]. For example: 'every-4-hours'
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> pulumi.Input[str]:
        """
        Defines a URI representing the backup storage location
        """
        return pulumi.get(self, "storage_path")

    @storage_path.setter
    def storage_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_path", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[str]:
        """
        Defines the provider of the storage location
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter(name="timeUtc")
    def time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the hour automatic backups are made - only applicable when the interval is `every-12-hours` or `every-24-hours`. For example: '14:00'
        """
        return pulumi.get(self, "time_utc")

    @time_utc.setter
    def time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_utc", value)


@pulumi.input_type
class ActiveActiveSubscriptionRegionsRegionArgs:
    def __init__(__self__, *,
                 databases: pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionRegionsRegionDatabaseArgs']]],
                 networking_deployment_cidr: pulumi.Input[str],
                 region: pulumi.Input[str],
                 recreate_region: Optional[pulumi.Input[bool]] = None,
                 region_id: Optional[pulumi.Input[int]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionRegionsRegionDatabaseArgs']]] databases: A block defining the write and read operations in the region, per database, documented below
        :param pulumi.Input[str] networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        :param pulumi.Input[str] region: Region name
        :param pulumi.Input[bool] recreate_region: Protection flag, needs to be set if a region has to be re-created. A region will need to be re-created in the case of a change on the `networking_deployment_cidr` field. During re-create, the region will be deleted (so the `delete_regions` flag also needs to be set) and then created again. Default: 'false'
        :param pulumi.Input[int] region_id: The ID of the region, as created by the API
        :param pulumi.Input[str] vpc_id: Identifier of the VPC to be peered, set by the API
        """
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "region", region)
        if recreate_region is not None:
            pulumi.set(__self__, "recreate_region", recreate_region)
        if region_id is not None:
            pulumi.set(__self__, "region_id", region_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def databases(self) -> pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionRegionsRegionDatabaseArgs']]]:
        """
        A block defining the write and read operations in the region, per database, documented below
        """
        return pulumi.get(self, "databases")

    @databases.setter
    def databases(self, value: pulumi.Input[Sequence[pulumi.Input['ActiveActiveSubscriptionRegionsRegionDatabaseArgs']]]):
        pulumi.set(self, "databases", value)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> pulumi.Input[str]:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @networking_deployment_cidr.setter
    def networking_deployment_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "networking_deployment_cidr", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Region name
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="recreateRegion")
    def recreate_region(self) -> Optional[pulumi.Input[bool]]:
        """
        Protection flag, needs to be set if a region has to be re-created. A region will need to be re-created in the case of a change on the `networking_deployment_cidr` field. During re-create, the region will be deleted (so the `delete_regions` flag also needs to be set) and then created again. Default: 'false'
        """
        return pulumi.get(self, "recreate_region")

    @recreate_region.setter
    def recreate_region(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "recreate_region", value)

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the region, as created by the API
        """
        return pulumi.get(self, "region_id")

    @region_id.setter
    def region_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "region_id", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the VPC to be peered, set by the API
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


@pulumi.input_type
class ActiveActiveSubscriptionRegionsRegionDatabaseArgs:
    def __init__(__self__, *,
                 database_id: pulumi.Input[int],
                 database_name: pulumi.Input[str],
                 local_read_operations_per_second: pulumi.Input[int],
                 local_write_operations_per_second: pulumi.Input[int]):
        """
        :param pulumi.Input[int] database_id: Database ID belonging to the subscription
        :param pulumi.Input[str] database_name: Database name belonging to the subscription
        :param pulumi.Input[int] local_read_operations_per_second: Local read operations per second for this active-active region
        :param pulumi.Input[int] local_write_operations_per_second: Local write operations per second for this active-active region
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "local_read_operations_per_second", local_read_operations_per_second)
        pulumi.set(__self__, "local_write_operations_per_second", local_write_operations_per_second)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> pulumi.Input[int]:
        """
        Database ID belonging to the subscription
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Database name belonging to the subscription
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="localReadOperationsPerSecond")
    def local_read_operations_per_second(self) -> pulumi.Input[int]:
        """
        Local read operations per second for this active-active region
        """
        return pulumi.get(self, "local_read_operations_per_second")

    @local_read_operations_per_second.setter
    def local_read_operations_per_second(self, value: pulumi.Input[int]):
        pulumi.set(self, "local_read_operations_per_second", value)

    @property
    @pulumi.getter(name="localWriteOperationsPerSecond")
    def local_write_operations_per_second(self) -> pulumi.Input[int]:
        """
        Local write operations per second for this active-active region
        """
        return pulumi.get(self, "local_write_operations_per_second")

    @local_write_operations_per_second.setter
    def local_write_operations_per_second(self, value: pulumi.Input[int]):
        pulumi.set(self, "local_write_operations_per_second", value)


@pulumi.input_type
class SubscriptionAllowlistArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Set of security groups that are allowed to access the databases associated with this subscription
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidrs: Set of CIDR ranges that are allowed to access the databases associated with this subscription
               
               > **Note:** `allowlist` is only available when you run on your own cloud account, and not one that Redis provided (i.e `cloud_account_id` != 1)
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of security groups that are allowed to access the databases associated with this subscription
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of CIDR ranges that are allowed to access the databases associated with this subscription

        > **Note:** `allowlist` is only available when you run on your own cloud account, and not one that Redis provided (i.e `cloud_account_id` != 1)
        """
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidrs", value)


@pulumi.input_type
class SubscriptionCloudProviderArgs:
    def __init__(__self__, *,
                 regions: pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionArgs']]],
                 cloud_account_id: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionArgs']]] regions: A region object, documented below. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] cloud_account_id: Cloud account identifier. Default: Redis Labs internal cloud account. **Modifying this attribute will force creation of a new resource.**
               (using Cloud Account ID = 1 implies using Redis Labs internal cloud account). Note that a GCP subscription can be created
               only with Redis Labs internal cloud account
        :param pulumi.Input[str] provider: The cloud provider to use with the subscription, (either `AWS` or `GCP`). Default: ‘AWS’. **Modifying this attribute will force creation of a new resource.**
        """
        pulumi.set(__self__, "regions", regions)
        if cloud_account_id is not None:
            pulumi.set(__self__, "cloud_account_id", cloud_account_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def regions(self) -> pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionArgs']]]:
        """
        A region object, documented below. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionArgs']]]):
        pulumi.set(self, "regions", value)

    @property
    @pulumi.getter(name="cloudAccountId")
    def cloud_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud account identifier. Default: Redis Labs internal cloud account. **Modifying this attribute will force creation of a new resource.**
        (using Cloud Account ID = 1 implies using Redis Labs internal cloud account). Note that a GCP subscription can be created
        only with Redis Labs internal cloud account
        """
        return pulumi.get(self, "cloud_account_id")

    @cloud_account_id.setter
    def cloud_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_account_id", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud provider to use with the subscription, (either `AWS` or `GCP`). Default: ‘AWS’. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)


@pulumi.input_type
class SubscriptionCloudProviderRegionArgs:
    def __init__(__self__, *,
                 networking_deployment_cidr: pulumi.Input[str],
                 region: pulumi.Input[str],
                 multiple_availability_zones: Optional[pulumi.Input[bool]] = None,
                 networking_vpc_id: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionNetworkArgs']]]] = None,
                 preferred_availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24). **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] region: Deployment region as defined by cloud provider. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[bool] multiple_availability_zones: Support deployment on multiple availability zones within the selected region. Default: ‘false’. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] networking_vpc_id: Either an existing VPC Id (already exists in the specific region) or create a new VPC
               (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
               within the hosting account. **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionNetworkArgs']]] networks: List of generated network configuration
        """
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "region", region)
        if multiple_availability_zones is not None:
            pulumi.set(__self__, "multiple_availability_zones", multiple_availability_zones)
        if networking_vpc_id is not None:
            pulumi.set(__self__, "networking_vpc_id", networking_vpc_id)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if preferred_availability_zones is not None:
            pulumi.set(__self__, "preferred_availability_zones", preferred_availability_zones)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> pulumi.Input[str]:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24). **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @networking_deployment_cidr.setter
    def networking_deployment_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "networking_deployment_cidr", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Deployment region as defined by cloud provider. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="multipleAvailabilityZones")
    def multiple_availability_zones(self) -> Optional[pulumi.Input[bool]]:
        """
        Support deployment on multiple availability zones within the selected region. Default: ‘false’. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "multiple_availability_zones")

    @multiple_availability_zones.setter
    def multiple_availability_zones(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multiple_availability_zones", value)

    @property
    @pulumi.getter(name="networkingVpcId")
    def networking_vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Either an existing VPC Id (already exists in the specific region) or create a new VPC
        (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
        within the hosting account. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "networking_vpc_id")

    @networking_vpc_id.setter
    def networking_vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "networking_vpc_id", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionNetworkArgs']]]]:
        """
        List of generated network configuration
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCloudProviderRegionNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="preferredAvailabilityZones")
    def preferred_availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preferred_availability_zones")

    @preferred_availability_zones.setter
    def preferred_availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preferred_availability_zones", value)


@pulumi.input_type
class SubscriptionCloudProviderRegionNetworkArgs:
    def __init__(__self__, *,
                 networking_deployment_cidr: Optional[pulumi.Input[str]] = None,
                 networking_subnet_id: Optional[pulumi.Input[str]] = None,
                 networking_vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24). **Modifying this attribute will force creation of a new resource.**
        :param pulumi.Input[str] networking_subnet_id: The subnet that the subscription deploys into
        :param pulumi.Input[str] networking_vpc_id: Either an existing VPC Id (already exists in the specific region) or create a new VPC
               (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
               within the hosting account. **Modifying this attribute will force creation of a new resource.**
        """
        if networking_deployment_cidr is not None:
            pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        if networking_subnet_id is not None:
            pulumi.set(__self__, "networking_subnet_id", networking_subnet_id)
        if networking_vpc_id is not None:
            pulumi.set(__self__, "networking_vpc_id", networking_vpc_id)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24). **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @networking_deployment_cidr.setter
    def networking_deployment_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "networking_deployment_cidr", value)

    @property
    @pulumi.getter(name="networkingSubnetId")
    def networking_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet that the subscription deploys into
        """
        return pulumi.get(self, "networking_subnet_id")

    @networking_subnet_id.setter
    def networking_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "networking_subnet_id", value)

    @property
    @pulumi.getter(name="networkingVpcId")
    def networking_vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Either an existing VPC Id (already exists in the specific region) or create a new VPC
        (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
        within the hosting account. **Modifying this attribute will force creation of a new resource.**
        """
        return pulumi.get(self, "networking_vpc_id")

    @networking_vpc_id.setter
    def networking_vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "networking_vpc_id", value)


@pulumi.input_type
class SubscriptionCreationPlanArgs:
    def __init__(__self__, *,
                 memory_limit_in_gb: pulumi.Input[float],
                 quantity: pulumi.Input[int],
                 replication: pulumi.Input[bool],
                 throughput_measurement_by: pulumi.Input[str],
                 throughput_measurement_value: pulumi.Input[int],
                 average_item_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 modules: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_oss_cluster_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] memory_limit_in_gb: Maximum memory usage that will be used for your largest planned database.
        :param pulumi.Input[int] quantity: The planned number of databases in the subscription
        :param pulumi.Input[bool] replication: Databases replication. Default: ‘true’
        :param pulumi.Input[str] throughput_measurement_by: Throughput measurement method that will be used by your databases, (either ‘number-of-shards’ or ‘operations-per-second’)
        :param pulumi.Input[int] throughput_measurement_value: Throughput value that will be used by your databases (as applies to selected measurement method). The value needs to be the maximum throughput measurement value defined in one of your databases
        :param pulumi.Input[int] average_item_size_in_bytes: Relevant only to ram-and-flash clusters
               Estimated average size (measured in bytes) of the items stored in the database. The value needs to
               be the maximum average item size defined in one of your databases.  Default: 1000
               
               ~>**Note:** If the number of modules exceeds the `quantity` then additional creation-plan databases will be created with the modules defined in the `modules` block.
               
               > **Note:** If changes are made to attributes in the subscription which require the subscription to be recreated (such as `memory_storage`, `cloud_provider` or `payment_method`), the creation_plan will need to be defined in order to change these attributes. This is because the creation_plan is always required when a subscription is created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] modules: a list of modules that will be used by the databases in this subscription. Not currently compatible with ‘ram-and-flash’ memory storage.
               Example: `modules = ["RedisJSON", RedisBloom"]`
        :param pulumi.Input[bool] support_oss_cluster_api: Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        pulumi.set(__self__, "memory_limit_in_gb", memory_limit_in_gb)
        pulumi.set(__self__, "quantity", quantity)
        pulumi.set(__self__, "replication", replication)
        pulumi.set(__self__, "throughput_measurement_by", throughput_measurement_by)
        pulumi.set(__self__, "throughput_measurement_value", throughput_measurement_value)
        if average_item_size_in_bytes is not None:
            pulumi.set(__self__, "average_item_size_in_bytes", average_item_size_in_bytes)
        if modules is not None:
            pulumi.set(__self__, "modules", modules)
        if support_oss_cluster_api is not None:
            pulumi.set(__self__, "support_oss_cluster_api", support_oss_cluster_api)

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> pulumi.Input[float]:
        """
        Maximum memory usage that will be used for your largest planned database.
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @memory_limit_in_gb.setter
    def memory_limit_in_gb(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory_limit_in_gb", value)

    @property
    @pulumi.getter
    def quantity(self) -> pulumi.Input[int]:
        """
        The planned number of databases in the subscription
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: pulumi.Input[int]):
        pulumi.set(self, "quantity", value)

    @property
    @pulumi.getter
    def replication(self) -> pulumi.Input[bool]:
        """
        Databases replication. Default: ‘true’
        """
        return pulumi.get(self, "replication")

    @replication.setter
    def replication(self, value: pulumi.Input[bool]):
        pulumi.set(self, "replication", value)

    @property
    @pulumi.getter(name="throughputMeasurementBy")
    def throughput_measurement_by(self) -> pulumi.Input[str]:
        """
        Throughput measurement method that will be used by your databases, (either ‘number-of-shards’ or ‘operations-per-second’)
        """
        return pulumi.get(self, "throughput_measurement_by")

    @throughput_measurement_by.setter
    def throughput_measurement_by(self, value: pulumi.Input[str]):
        pulumi.set(self, "throughput_measurement_by", value)

    @property
    @pulumi.getter(name="throughputMeasurementValue")
    def throughput_measurement_value(self) -> pulumi.Input[int]:
        """
        Throughput value that will be used by your databases (as applies to selected measurement method). The value needs to be the maximum throughput measurement value defined in one of your databases
        """
        return pulumi.get(self, "throughput_measurement_value")

    @throughput_measurement_value.setter
    def throughput_measurement_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "throughput_measurement_value", value)

    @property
    @pulumi.getter(name="averageItemSizeInBytes")
    def average_item_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Relevant only to ram-and-flash clusters
        Estimated average size (measured in bytes) of the items stored in the database. The value needs to
        be the maximum average item size defined in one of your databases.  Default: 1000

        ~>**Note:** If the number of modules exceeds the `quantity` then additional creation-plan databases will be created with the modules defined in the `modules` block.

        > **Note:** If changes are made to attributes in the subscription which require the subscription to be recreated (such as `memory_storage`, `cloud_provider` or `payment_method`), the creation_plan will need to be defined in order to change these attributes. This is because the creation_plan is always required when a subscription is created.
        """
        return pulumi.get(self, "average_item_size_in_bytes")

    @average_item_size_in_bytes.setter
    def average_item_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "average_item_size_in_bytes", value)

    @property
    @pulumi.getter
    def modules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        a list of modules that will be used by the databases in this subscription. Not currently compatible with ‘ram-and-flash’ memory storage.
        Example: `modules = ["RedisJSON", RedisBloom"]`
        """
        return pulumi.get(self, "modules")

    @modules.setter
    def modules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "modules", value)

    @property
    @pulumi.getter(name="supportOssClusterApi")
    def support_oss_cluster_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        return pulumi.get(self, "support_oss_cluster_api")

    @support_oss_cluster_api.setter
    def support_oss_cluster_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_oss_cluster_api", value)


@pulumi.input_type
class SubscriptionDatabaseAlertArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] name: Alert name. (either: 'dataset-size', 'datasets-size', 'throughput-higher-than', 'throughput-lower-than', 'latency', 'syncsource-error', 'syncsource-lag' or 'connections-limit')
        :param pulumi.Input[int] value: Alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Alert name. (either: 'dataset-size', 'datasets-size', 'throughput-higher-than', 'throughput-lower-than', 'latency', 'syncsource-error', 'syncsource-lag' or 'connections-limit')
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Alert value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SubscriptionDatabaseModuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the Redis database module to enable. **Modifying this attribute will force creation of a new resource.**
               
               Example:
               
               ```python
               import pulumi
               
               modules = [
                   {
                       "name": "RedisJSON",
                   },
                   {
                       "name": "RedisBloom",
                   },
               ]
               ```
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Redis database module to enable. **Modifying this attribute will force creation of a new resource.**

        Example:

        ```python
        import pulumi

        modules = [
            {
                "name": "RedisJSON",
            },
            {
                "name": "RedisBloom",
            },
        ]
        ```
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SubscriptionDatabaseRemoteBackupArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 storage_path: pulumi.Input[str],
                 storage_type: pulumi.Input[str],
                 time_utc: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] interval: Defines the interval between backups. Should be in the following format 'every-x-hours'. x is one of [24,12,6,4,2,1]. For example: 'every-4-hours'
        :param pulumi.Input[str] storage_path: Defines a URI representing the backup storage location
        :param pulumi.Input[str] storage_type: Defines the provider of the storage location
        :param pulumi.Input[str] time_utc: Defines the hour automatic backups are made - only applicable when the interval is `every-12-hours` or `every-24-hours`. For example: '14:00'
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "storage_path", storage_path)
        pulumi.set(__self__, "storage_type", storage_type)
        if time_utc is not None:
            pulumi.set(__self__, "time_utc", time_utc)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        Defines the interval between backups. Should be in the following format 'every-x-hours'. x is one of [24,12,6,4,2,1]. For example: 'every-4-hours'
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> pulumi.Input[str]:
        """
        Defines a URI representing the backup storage location
        """
        return pulumi.get(self, "storage_path")

    @storage_path.setter
    def storage_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_path", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[str]:
        """
        Defines the provider of the storage location
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter(name="timeUtc")
    def time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the hour automatic backups are made - only applicable when the interval is `every-12-hours` or `every-24-hours`. For example: '14:00'
        """
        return pulumi.get(self, "time_utc")

    @time_utc.setter
    def time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_utc", value)


