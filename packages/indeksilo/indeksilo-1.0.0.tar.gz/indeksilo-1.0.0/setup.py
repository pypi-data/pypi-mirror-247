# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['indeksilo']

package_data = \
{'': ['*']}

install_requires = \
['numpy==1.24.4',
 'odfpy==1.4.1',
 'openpyxl==3.1.2',
 'pandas==2.0.3',
 'pyuca==1.2']

entry_points = \
{'console_scripts': ['indeksilo = indeksilo.cli:main']}

setup_kwargs = {
    'name': 'indeksilo',
    'version': '1.0.0',
    'description': 'generate a multi-level alphabetical index from text in tabular data format',
    'long_description': '<!--\nSPDX-FileCopyrightText: 2023 hugues de keyzer\n\nSPDX-License-Identifier: AGPL-3.0-or-later\n-->\n\n# indeksilo\n\nindeksilo allows to generate a multi-level alphabetical index from text in tabular data format.\n\n## introduction\n\ntext in tabular data format is text formatted as a table (usually stored as a spreadsheet file), where each row of the table contains one word of the text.\none column contains the actual word as it appears in the text, while other columns may contain more information about the word, like the page and line number where it appears, a cleaned-up form (with uniform casing and no punctuation), its lemma, its grammatical category,…\n\nfrom text in that format, indeksilo generates an alphabetical index (like the ones that appear at the end of books).\nsee the example section below for a concrete example.\n\n## features\n\n*   multi-level index generation\n*   alphabetical sorting using the unicode collation algorithm\n*   right-to-left text support\n*   multiple values in parent columns support for agglutinated forms\n*   multiple reference support (for example: page, line)\n*   grouping of identical references with count\n*   total count of form occurences at each parent level\n*   filtering with regular expressions\n\n## usage\n\nindeksilo takes an input filename and an output filename as arguments, as well as some options.\ninput and output files should be in opendocument (.ods) or office open xml (.xlsx) format.\nthe minimal usage is:\n\n```\nindeksilo --ref-col ref --form-col form input.ods output.ods\n```\nwhere `ref` is the title of the column (in `input.ods`) that contains the reference to use in the index (the page number, for example) and `form` is title of the column (in `input.ods`) that contains the form that will appear in the index.\n\nto display a full description of the usage syntax:\n\n```\nindeksilo --help\n```\n\n## example\n\nlet’s take the following example text, and say that it appears on line 1 and 2 of page 42:\n\n> la suno brilas hodiaŭ. hieraŭ estis malvarme, sed hodiaŭ estas varme.<br>\n> ni estas bonŝancaj!\n\nit must first be converted to this format as `input.ods`:\n\n| page | line | word       | form      | lemma      |\n| ---- | ---- | ---------- | --------- | ---------- |\n| 42   | 1    | la         | la        | la         |\n| 42   | 1    | suno       | suno      | suno       |\n| 42   | 1    | brilas     | brilas    | brili      |\n| 42   | 1    | hodiaŭ.    | hodiaŭ    | hodiaŭ     |\n| 42   | 1    | hieraŭ     | hieraŭ    | hieraŭ     |\n| 42   | 1    | estis      | estis     | esti       |\n| 42   | 1    | malvarme,  | malvarme  | varma      |\n| 42   | 1    | sed        | sed       | sed        |\n| 42   | 1    | hodiaŭ     | hodiaŭ    | hodiaŭ     |\n| 42   | 1    | estas      | estas     | esti       |\n| 42   | 1    | varme.     | varme     | varma      |\n| 42   | 2    | ni         | ni        | ni         |\n| 42   | 2    | estas      | estas     | esti       |\n| 42   | 2    | bonŝancaj! | bonŝancaj | bona+ŝanco |\n\nnow, let’s generate the index by calling:\n\n```\nindeksilo --ref-col page --ref-col line --parent-col lemma --form-col form --split-char + input.ods output.ods\n```\n\nthis will generate the following table as `output.ods`:\n\n|    | lemma_count | lemma  | form_count | form      | refs         |\n| -- | ----------- | ------ | ---------- | --------- | ------------ |\n| 0  | 1           | bona   | 1          | bonŝancaj | 42, 2        |\n| 1  | 1           | brili  | 1          | brilas    | 42, 1        |\n| 2  | 3           | esti   | 2          | estas     | 42, 1; 42, 2 |\n| 3  |             |        | 1          | estis     | 42, 1        |\n| 4  | 1           | hieraŭ | 1          | hieraŭ    | 42, 1        |\n| 5  | 2           | hodiaŭ | 2          | hodiaŭ    | 42, 1 (2)    |\n| 6  | 1           | la     | 1          | la        | 42, 1        |\n| 7  | 1           | ni     | 1          | ni        | 42, 2        |\n| 8  | 1           | ŝanco  | 1          | bonŝancaj | 42, 2        |\n| 9  | 1           | sed    | 1          | sed       | 42, 1        |\n| 10 | 1           | suno   | 1          | suno      | 42, 1        |\n| 11 | 2           | varma  | 1          | malvarme  | 42, 1        |\n| 12 |             |        | 1          | varme     | 42, 1        |\n\nnote that “bonŝancaj” appears twice in the index, once under the form “bona” and once under the form “ŝanco”.\nthis is because the lemma column contained two values, separated by the defined split character.\n\nnote that the word “hodiaŭ” appears twice on the same line.\nthis is why its reference has “(2)” appended to it.\n\n## filtering\n\nindeksilo allows to filter rows based on column values using regular expressions.\n\nfor example, using the same input file as in the previous example, let’s say that only noun lemmas should appear.\nin this case, they all end with “o”, so this command can be used:\n\n```\nindeksilo --ref-col page --ref-col line --parent-col lemma --form-col form --split-char + --filter "lemma:.*o" input.ods output.ods\n```\n\nin this example, the argument is quoted to avoid the `*` character to be interpreted by the shell.\nthis depends on the shell used.\n\nthis will generate the following table:\n\n|   | lemma_count | lemma | form_count | form      | refs  |\n| - | ----------- | ----- | ---------- | --------- | ----- |\n| 0 | 1           | ŝanco | 1          | bonŝancaj | 42, 2 |\n| 1 | 1           | suno  | 1          | suno      | 42, 1 |\n\nnote that “bonŝancaj” appears only once in this case, because the lemma “bona” was filtered out.\n\nmultiple filter arguments may be used.\nthe format of the filter expressions is `col:regex`, where `col` is a column name and `regex` is a regular expression matching the value (after splitting).\nany column of the input table can be used, even those not used by the index.\n\nby default, filtering is inclusive, which means that at least one expression should match for the row to be included.\nthis behavior can be reversed with `--filter-exclude`.\nin this case, any row matching an expression is excluded; only the rows not matching any of the expressions are included.\n\nfor example, still using the same input file, let’s say that forms with less than 4 letters should be excluded.\nthis command can be used:\n\n```\nindeksilo --ref-col page --ref-col line --parent-col lemma --form-col form --split-char + --filter "form:.{1,3}" --filter-exclude input.ods output.ods\n```\n\nthis will generate the following table:\n\n|   | lemma_count | lemma  | form_count | form      | refs         |\n| - | ----------- | ------ | ---------- | --------- | ------------ |\n| 0 | 1           | bona   | 1          | bonŝancaj | 42, 2        |\n| 1 | 1           | brili  | 1          | brilas    | 42, 1        |\n| 2 | 3           | esti   | 2          | estas     | 42, 1; 42, 2 |\n| 3 |             |        | 1          | estis     | 42, 1        |\n| 4 | 1           | hieraŭ | 1          | hieraŭ    | 42, 1        |\n| 5 | 2           | hodiaŭ | 2          | hodiaŭ    | 42, 1 (2)    |\n| 6 | 1           | ŝanco  | 1          | bonŝancaj | 42, 2        |\n| 7 | 1           | suno   | 1          | suno      | 42, 1        |\n| 8 | 2           | varma  | 1          | malvarme  | 42, 1        |\n| 9 |             |        | 1          | varme     | 42, 1        |\n\nindeksilo uses python’s regular expressions.\ntheir documentation is [here](https://docs.python.org/3/library/re.html).\n\n## credits\n\nThis development was funded by Bastien Kindt for the GREgORI Project.<br>\n<https://uclouvain.be/fr/instituts-recherche/incal/ciol/gregori-project.html><br>\n<https://www.v2.gregoriproject.com/>\n',
    'author': 'hugues de keyzer',
    'author_email': None,
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
