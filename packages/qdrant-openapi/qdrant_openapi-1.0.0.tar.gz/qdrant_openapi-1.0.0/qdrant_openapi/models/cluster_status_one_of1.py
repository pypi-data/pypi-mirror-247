# coding: utf-8

"""
    Qdrant API

    API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let's create a collection with dot-production metric. ``` curl -X PUT 'http://localhost:6333/collections/test_collection' \\   -H 'Content-Type: application/json' \\   --data-raw '{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl 'http://localhost:6333/collections/test_collection' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let's now add vectors with some payload: ``` curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ --data-raw '{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let's start with a basic request: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ``` 

    The version of the OpenAPI document: v1.7.x
    Contact: andrey@vasnetsov.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Dict
from pydantic import BaseModel, Field, StrictStr, conint, validator
from qdrant_openapi.models.consensus_thread_status import ConsensusThreadStatus
from qdrant_openapi.models.message_send_errors import MessageSendErrors
from qdrant_openapi.models.peer_info import PeerInfo
from qdrant_openapi.models.raft_info import RaftInfo

class ClusterStatusOneOf1(BaseModel):
    """
    Description of enabled cluster  # noqa: E501
    """
    status: StrictStr = Field(...)
    peer_id: conint(strict=True, ge=0) = Field(..., description="ID of this peer")
    peers: Dict[str, PeerInfo] = Field(..., description="Peers composition of the cluster with main information")
    raft_info: RaftInfo = Field(...)
    consensus_thread_status: ConsensusThreadStatus = Field(...)
    message_send_failures: Dict[str, MessageSendErrors] = Field(..., description="Consequent failures of message send operations in consensus by peer address. On the first success to send to that peer - entry is removed from this hashmap.")
    __properties = ["status", "peer_id", "peers", "raft_info", "consensus_thread_status", "message_send_failures"]

    @validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('enabled'):
            raise ValueError("must be one of enum values ('enabled')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ClusterStatusOneOf1:
        """Create an instance of ClusterStatusOneOf1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each value in peers (dict)
        _field_dict = {}
        if self.peers:
            for _key in self.peers:
                if self.peers[_key]:
                    _field_dict[_key] = self.peers[_key].to_dict()
            _dict['peers'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of raft_info
        if self.raft_info:
            _dict['raft_info'] = self.raft_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of consensus_thread_status
        if self.consensus_thread_status:
            _dict['consensus_thread_status'] = self.consensus_thread_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in message_send_failures (dict)
        _field_dict = {}
        if self.message_send_failures:
            for _key in self.message_send_failures:
                if self.message_send_failures[_key]:
                    _field_dict[_key] = self.message_send_failures[_key].to_dict()
            _dict['message_send_failures'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ClusterStatusOneOf1:
        """Create an instance of ClusterStatusOneOf1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ClusterStatusOneOf1.parse_obj(obj)

        _obj = ClusterStatusOneOf1.parse_obj({
            "status": obj.get("status"),
            "peer_id": obj.get("peer_id"),
            "peers": dict(
                (_k, PeerInfo.from_dict(_v))
                for _k, _v in obj.get("peers").items()
            )
            if obj.get("peers") is not None
            else None,
            "raft_info": RaftInfo.from_dict(obj.get("raft_info")) if obj.get("raft_info") is not None else None,
            "consensus_thread_status": ConsensusThreadStatus.from_dict(obj.get("consensus_thread_status")) if obj.get("consensus_thread_status") is not None else None,
            "message_send_failures": dict(
                (_k, MessageSendErrors.from_dict(_v))
                for _k, _v in obj.get("message_send_failures").items()
            )
            if obj.get("message_send_failures") is not None
            else None
        })
        return _obj


