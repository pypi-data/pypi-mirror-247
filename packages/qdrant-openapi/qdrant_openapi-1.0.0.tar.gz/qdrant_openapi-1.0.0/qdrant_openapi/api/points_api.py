# coding: utf-8

"""
    Qdrant API

    API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let's create a collection with dot-production metric. ``` curl -X PUT 'http://localhost:6333/collections/test_collection' \\   -H 'Content-Type: application/json' \\   --data-raw '{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl 'http://localhost:6333/collections/test_collection' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let's now add vectors with some payload: ``` curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ --data-raw '{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let's start with a basic request: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ``` 

    The version of the OpenAPI document: v1.7.x
    Contact: andrey@vasnetsov.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictStr, conint

from typing import Any, Optional

from qdrant_openapi.models.batch_update200_response import BatchUpdate200Response
from qdrant_openapi.models.count_points200_response import CountPoints200Response
from qdrant_openapi.models.count_request import CountRequest
from qdrant_openapi.models.create_field_index200_response import CreateFieldIndex200Response
from qdrant_openapi.models.delete_payload import DeletePayload
from qdrant_openapi.models.delete_vectors import DeleteVectors
from qdrant_openapi.models.discover_request import DiscoverRequest
from qdrant_openapi.models.discover_request_batch import DiscoverRequestBatch
from qdrant_openapi.models.get_point200_response import GetPoint200Response
from qdrant_openapi.models.get_points200_response import GetPoints200Response
from qdrant_openapi.models.point_insert_operations import PointInsertOperations
from qdrant_openapi.models.point_request import PointRequest
from qdrant_openapi.models.points_selector import PointsSelector
from qdrant_openapi.models.recommend_groups_request import RecommendGroupsRequest
from qdrant_openapi.models.recommend_request import RecommendRequest
from qdrant_openapi.models.recommend_request_batch import RecommendRequestBatch
from qdrant_openapi.models.scroll_points200_response import ScrollPoints200Response
from qdrant_openapi.models.scroll_request import ScrollRequest
from qdrant_openapi.models.search_batch_points200_response import SearchBatchPoints200Response
from qdrant_openapi.models.search_groups_request import SearchGroupsRequest
from qdrant_openapi.models.search_point_groups200_response import SearchPointGroups200Response
from qdrant_openapi.models.search_points200_response import SearchPoints200Response
from qdrant_openapi.models.search_request import SearchRequest
from qdrant_openapi.models.search_request_batch import SearchRequestBatch
from qdrant_openapi.models.set_payload import SetPayload
from qdrant_openapi.models.update_operations import UpdateOperations
from qdrant_openapi.models.update_vectors import UpdateVectors
from qdrant_openapi.models.write_ordering import WriteOrdering

from qdrant_openapi.api_client import ApiClient
from qdrant_openapi.api_response import ApiResponse
from qdrant_openapi.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class PointsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def batch_update(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to apply operations on")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, update_operations : Annotated[Optional[UpdateOperations], Field(description="update operations")] = None, **kwargs) -> BatchUpdate200Response:  # noqa: E501
        """Batch update points  # noqa: E501

        Apply a series of update operations for points, vectors and payloads  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.batch_update(collection_name, wait, ordering, update_operations, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to apply operations on (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param update_operations: update operations
        :type update_operations: UpdateOperations
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchUpdate200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the batch_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.batch_update_with_http_info(collection_name, wait, ordering, update_operations, **kwargs)  # noqa: E501

    @validate_arguments
    def batch_update_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to apply operations on")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, update_operations : Annotated[Optional[UpdateOperations], Field(description="update operations")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Batch update points  # noqa: E501

        Apply a series of update operations for points, vectors and payloads  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.batch_update_with_http_info(collection_name, wait, ordering, update_operations, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to apply operations on (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param update_operations: update operations
        :type update_operations: UpdateOperations
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchUpdate200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'update_operations'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_operations'] is not None:
            _body_params = _params['update_operations']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "BatchUpdate200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/batch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def clear_payload(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to clear payload from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, points_selector : Annotated[Optional[PointsSelector], Field(description="clear payload on points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Clear payload  # noqa: E501

        Remove all payload for specified points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.clear_payload(collection_name, wait, ordering, points_selector, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to clear payload from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param points_selector: clear payload on points
        :type points_selector: PointsSelector
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the clear_payload_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.clear_payload_with_http_info(collection_name, wait, ordering, points_selector, **kwargs)  # noqa: E501

    @validate_arguments
    def clear_payload_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to clear payload from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, points_selector : Annotated[Optional[PointsSelector], Field(description="clear payload on points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Clear payload  # noqa: E501

        Remove all payload for specified points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.clear_payload_with_http_info(collection_name, wait, ordering, points_selector, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to clear payload from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param points_selector: clear payload on points
        :type points_selector: PointsSelector
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'points_selector'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_payload" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['points_selector'] is not None:
            _body_params = _params['points_selector']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/payload/clear', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def count_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to count in")], count_request : Annotated[Optional[CountRequest], Field(description="Request counts of points which matches given filtering condition")] = None, **kwargs) -> CountPoints200Response:  # noqa: E501
        """Count points  # noqa: E501

        Count points which matches given filtering condition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.count_points(collection_name, count_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to count in (required)
        :type collection_name: str
        :param count_request: Request counts of points which matches given filtering condition
        :type count_request: CountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CountPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the count_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.count_points_with_http_info(collection_name, count_request, **kwargs)  # noqa: E501

    @validate_arguments
    def count_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to count in")], count_request : Annotated[Optional[CountRequest], Field(description="Request counts of points which matches given filtering condition")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Count points  # noqa: E501

        Count points which matches given filtering condition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.count_points_with_http_info(collection_name, count_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to count in (required)
        :type collection_name: str
        :param count_request: Request counts of points which matches given filtering condition
        :type count_request: CountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CountPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'count_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['count_request'] is not None:
            _body_params = _params['count_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CountPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/count', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_payload(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to delete from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, delete_payload : Annotated[Optional[DeletePayload], Field(description="delete payload on points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Delete payload  # noqa: E501

        Delete specified key payload for points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_payload(collection_name, wait, ordering, delete_payload, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to delete from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param delete_payload: delete payload on points
        :type delete_payload: DeletePayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_payload_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_payload_with_http_info(collection_name, wait, ordering, delete_payload, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_payload_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to delete from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, delete_payload : Annotated[Optional[DeletePayload], Field(description="delete payload on points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete payload  # noqa: E501

        Delete specified key payload for points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_payload_with_http_info(collection_name, wait, ordering, delete_payload, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to delete from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param delete_payload: delete payload on points
        :type delete_payload: DeletePayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'delete_payload'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_payload" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['delete_payload'] is not None:
            _body_params = _params['delete_payload']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/payload/delete', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to delete from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, points_selector : Annotated[Optional[PointsSelector], Field(description="Operation to perform on points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Delete points  # noqa: E501

        Delete points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_points(collection_name, wait, ordering, points_selector, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to delete from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param points_selector: Operation to perform on points
        :type points_selector: PointsSelector
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_points_with_http_info(collection_name, wait, ordering, points_selector, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to delete from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, points_selector : Annotated[Optional[PointsSelector], Field(description="Operation to perform on points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete points  # noqa: E501

        Delete points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_points_with_http_info(collection_name, wait, ordering, points_selector, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to delete from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param points_selector: Operation to perform on points
        :type points_selector: PointsSelector
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'points_selector'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['points_selector'] is not None:
            _body_params = _params['points_selector']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/delete', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_vectors(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to delete from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, delete_vectors : Annotated[Optional[DeleteVectors], Field(description="Delete named vectors from points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Delete vectors  # noqa: E501

        Delete named vectors from the given points.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_vectors(collection_name, wait, ordering, delete_vectors, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to delete from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param delete_vectors: Delete named vectors from points
        :type delete_vectors: DeleteVectors
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_vectors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_vectors_with_http_info(collection_name, wait, ordering, delete_vectors, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_vectors_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to delete from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, delete_vectors : Annotated[Optional[DeleteVectors], Field(description="Delete named vectors from points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete vectors  # noqa: E501

        Delete named vectors from the given points.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_vectors_with_http_info(collection_name, wait, ordering, delete_vectors, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to delete from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param delete_vectors: Delete named vectors from points
        :type delete_vectors: DeleteVectors
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'delete_vectors'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_vectors" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['delete_vectors'] is not None:
            _body_params = _params['delete_vectors']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/vectors/delete', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def discover_batch_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, discover_request_batch : Annotated[Optional[DiscoverRequestBatch], Field(description="Batch request points based on { positive, negative } pairs of examples, and/or a target.")] = None, **kwargs) -> SearchBatchPoints200Response:  # noqa: E501
        """Discover batch points  # noqa: E501

        Look for points based on target and/or positive and negative example pairs, in batch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.discover_batch_points(collection_name, consistency, timeout, discover_request_batch, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param discover_request_batch: Batch request points based on { positive, negative } pairs of examples, and/or a target.
        :type discover_request_batch: DiscoverRequestBatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchBatchPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the discover_batch_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.discover_batch_points_with_http_info(collection_name, consistency, timeout, discover_request_batch, **kwargs)  # noqa: E501

    @validate_arguments
    def discover_batch_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, discover_request_batch : Annotated[Optional[DiscoverRequestBatch], Field(description="Batch request points based on { positive, negative } pairs of examples, and/or a target.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Discover batch points  # noqa: E501

        Look for points based on target and/or positive and negative example pairs, in batch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.discover_batch_points_with_http_info(collection_name, consistency, timeout, discover_request_batch, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param discover_request_batch: Batch request points based on { positive, negative } pairs of examples, and/or a target.
        :type discover_request_batch: DiscoverRequestBatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchBatchPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'discover_request_batch'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method discover_batch_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['discover_request_batch'] is not None:
            _body_params = _params['discover_request_batch']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchBatchPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/discover/batch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def discover_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, discover_request : Annotated[Optional[DiscoverRequest], Field(description="Request points based on {positive, negative} pairs of examples, and/or a target")] = None, **kwargs) -> SearchPoints200Response:  # noqa: E501
        """Discover points  # noqa: E501

        Use context and a target to find the most similar points to the target, constrained by the context. When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair. Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0. When using target (with or without context), the score behaves a little different: The  integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target. The context part of the score for  each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair,  and -1 otherwise.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.discover_points(collection_name, consistency, timeout, discover_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param discover_request: Request points based on {positive, negative} pairs of examples, and/or a target
        :type discover_request: DiscoverRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the discover_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.discover_points_with_http_info(collection_name, consistency, timeout, discover_request, **kwargs)  # noqa: E501

    @validate_arguments
    def discover_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, discover_request : Annotated[Optional[DiscoverRequest], Field(description="Request points based on {positive, negative} pairs of examples, and/or a target")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Discover points  # noqa: E501

        Use context and a target to find the most similar points to the target, constrained by the context. When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair. Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0. When using target (with or without context), the score behaves a little different: The  integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target. The context part of the score for  each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair,  and -1 otherwise.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.discover_points_with_http_info(collection_name, consistency, timeout, discover_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param discover_request: Request points based on {positive, negative} pairs of examples, and/or a target
        :type discover_request: DiscoverRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'discover_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method discover_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['discover_request'] is not None:
            _body_params = _params['discover_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/discover', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_point(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to retrieve from")], id : Annotated[Any, Field(..., description="Id of the point")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, **kwargs) -> GetPoint200Response:  # noqa: E501
        """Get point  # noqa: E501

        Retrieve full information of single point by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_point(collection_name, id, consistency, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to retrieve from (required)
        :type collection_name: str
        :param id: Id of the point (required)
        :type id: ExtendedPointId
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetPoint200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_point_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_point_with_http_info(collection_name, id, consistency, **kwargs)  # noqa: E501

    @validate_arguments
    def get_point_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to retrieve from")], id : Annotated[Any, Field(..., description="Id of the point")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get point  # noqa: E501

        Retrieve full information of single point by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_point_with_http_info(collection_name, id, consistency, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to retrieve from (required)
        :type collection_name: str
        :param id: Id of the point (required)
        :type id: ExtendedPointId
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetPoint200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'id',
            'consistency'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_point" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']

        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "GetPoint200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to retrieve from")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, point_request : Annotated[Optional[PointRequest], Field(description="List of points to retrieve")] = None, **kwargs) -> GetPoints200Response:  # noqa: E501
        """Get points  # noqa: E501

        Retrieve multiple points by specified IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_points(collection_name, consistency, point_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to retrieve from (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param point_request: List of points to retrieve
        :type point_request: PointRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_points_with_http_info(collection_name, consistency, point_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to retrieve from")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, point_request : Annotated[Optional[PointRequest], Field(description="List of points to retrieve")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get points  # noqa: E501

        Retrieve multiple points by specified IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_points_with_http_info(collection_name, consistency, point_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to retrieve from (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param point_request: List of points to retrieve
        :type point_request: PointRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'point_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['point_request'] is not None:
            _body_params = _params['point_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "GetPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def overwrite_payload(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to set from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, set_payload : Annotated[Optional[SetPayload], Field(description="Payload and points selector")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Overwrite payload  # noqa: E501

        Replace full payload of points with new one  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.overwrite_payload(collection_name, wait, ordering, set_payload, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to set from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param set_payload: Payload and points selector
        :type set_payload: SetPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the overwrite_payload_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.overwrite_payload_with_http_info(collection_name, wait, ordering, set_payload, **kwargs)  # noqa: E501

    @validate_arguments
    def overwrite_payload_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to set from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, set_payload : Annotated[Optional[SetPayload], Field(description="Payload and points selector")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Overwrite payload  # noqa: E501

        Replace full payload of points with new one  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.overwrite_payload_with_http_info(collection_name, wait, ordering, set_payload, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to set from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param set_payload: Payload and points selector
        :type set_payload: SetPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'set_payload'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method overwrite_payload" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_payload'] is not None:
            _body_params = _params['set_payload']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/payload', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def recommend_batch_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, recommend_request_batch : Annotated[Optional[RecommendRequestBatch], Field(description="Request points based on positive and negative examples.")] = None, **kwargs) -> SearchBatchPoints200Response:  # noqa: E501
        """Recommend batch points  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_batch_points(collection_name, consistency, timeout, recommend_request_batch, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param recommend_request_batch: Request points based on positive and negative examples.
        :type recommend_request_batch: RecommendRequestBatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchBatchPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the recommend_batch_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.recommend_batch_points_with_http_info(collection_name, consistency, timeout, recommend_request_batch, **kwargs)  # noqa: E501

    @validate_arguments
    def recommend_batch_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, recommend_request_batch : Annotated[Optional[RecommendRequestBatch], Field(description="Request points based on positive and negative examples.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Recommend batch points  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_batch_points_with_http_info(collection_name, consistency, timeout, recommend_request_batch, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param recommend_request_batch: Request points based on positive and negative examples.
        :type recommend_request_batch: RecommendRequestBatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchBatchPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'recommend_request_batch'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recommend_batch_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['recommend_request_batch'] is not None:
            _body_params = _params['recommend_request_batch']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchBatchPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/recommend/batch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def recommend_point_groups(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, recommend_groups_request : Annotated[Optional[RecommendGroupsRequest], Field(description="Request points based on positive and negative examples, grouped by a payload field.")] = None, **kwargs) -> SearchPointGroups200Response:  # noqa: E501
        """Recommend point groups  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_point_groups(collection_name, consistency, timeout, recommend_groups_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param recommend_groups_request: Request points based on positive and negative examples, grouped by a payload field.
        :type recommend_groups_request: RecommendGroupsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchPointGroups200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the recommend_point_groups_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.recommend_point_groups_with_http_info(collection_name, consistency, timeout, recommend_groups_request, **kwargs)  # noqa: E501

    @validate_arguments
    def recommend_point_groups_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, recommend_groups_request : Annotated[Optional[RecommendGroupsRequest], Field(description="Request points based on positive and negative examples, grouped by a payload field.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Recommend point groups  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_point_groups_with_http_info(collection_name, consistency, timeout, recommend_groups_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param recommend_groups_request: Request points based on positive and negative examples, grouped by a payload field.
        :type recommend_groups_request: RecommendGroupsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchPointGroups200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'recommend_groups_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recommend_point_groups" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['recommend_groups_request'] is not None:
            _body_params = _params['recommend_groups_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchPointGroups200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/recommend/groups', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def recommend_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, recommend_request : Annotated[Optional[RecommendRequest], Field(description="Request points based on positive and negative examples.")] = None, **kwargs) -> SearchPoints200Response:  # noqa: E501
        """Recommend points  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_points(collection_name, consistency, timeout, recommend_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param recommend_request: Request points based on positive and negative examples.
        :type recommend_request: RecommendRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the recommend_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.recommend_points_with_http_info(collection_name, consistency, timeout, recommend_request, **kwargs)  # noqa: E501

    @validate_arguments
    def recommend_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, recommend_request : Annotated[Optional[RecommendRequest], Field(description="Request points based on positive and negative examples.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Recommend points  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_points_with_http_info(collection_name, consistency, timeout, recommend_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param recommend_request: Request points based on positive and negative examples.
        :type recommend_request: RecommendRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'recommend_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recommend_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['recommend_request'] is not None:
            _body_params = _params['recommend_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/recommend', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def scroll_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to retrieve from")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, scroll_request : Annotated[Optional[ScrollRequest], Field(description="Pagination and filter parameters")] = None, **kwargs) -> ScrollPoints200Response:  # noqa: E501
        """Scroll points  # noqa: E501

        Scroll request - paginate over all points which matches given filtering condition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.scroll_points(collection_name, consistency, scroll_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to retrieve from (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param scroll_request: Pagination and filter parameters
        :type scroll_request: ScrollRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ScrollPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the scroll_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.scroll_points_with_http_info(collection_name, consistency, scroll_request, **kwargs)  # noqa: E501

    @validate_arguments
    def scroll_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to retrieve from")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, scroll_request : Annotated[Optional[ScrollRequest], Field(description="Pagination and filter parameters")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Scroll points  # noqa: E501

        Scroll request - paginate over all points which matches given filtering condition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.scroll_points_with_http_info(collection_name, consistency, scroll_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to retrieve from (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param scroll_request: Pagination and filter parameters
        :type scroll_request: ScrollRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ScrollPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'scroll_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scroll_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['scroll_request'] is not None:
            _body_params = _params['scroll_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ScrollPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/scroll', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_batch_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, search_request_batch : Annotated[Optional[SearchRequestBatch], Field(description="Search batch request")] = None, **kwargs) -> SearchBatchPoints200Response:  # noqa: E501
        """Search batch points  # noqa: E501

        Retrieve by batch the closest points based on vector similarity and given filtering conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_batch_points(collection_name, consistency, timeout, search_request_batch, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param search_request_batch: Search batch request
        :type search_request_batch: SearchRequestBatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchBatchPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_batch_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_batch_points_with_http_info(collection_name, consistency, timeout, search_request_batch, **kwargs)  # noqa: E501

    @validate_arguments
    def search_batch_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, search_request_batch : Annotated[Optional[SearchRequestBatch], Field(description="Search batch request")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search batch points  # noqa: E501

        Retrieve by batch the closest points based on vector similarity and given filtering conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_batch_points_with_http_info(collection_name, consistency, timeout, search_request_batch, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param search_request_batch: Search batch request
        :type search_request_batch: SearchRequestBatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchBatchPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'search_request_batch'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_batch_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['search_request_batch'] is not None:
            _body_params = _params['search_request_batch']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchBatchPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/search/batch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_point_groups(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, search_groups_request : Annotated[Optional[SearchGroupsRequest], Field(description="Search request with optional filtering, grouped by a given payload field")] = None, **kwargs) -> SearchPointGroups200Response:  # noqa: E501
        """Search point groups  # noqa: E501

        Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_point_groups(collection_name, consistency, timeout, search_groups_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param search_groups_request: Search request with optional filtering, grouped by a given payload field
        :type search_groups_request: SearchGroupsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchPointGroups200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_point_groups_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_point_groups_with_http_info(collection_name, consistency, timeout, search_groups_request, **kwargs)  # noqa: E501

    @validate_arguments
    def search_point_groups_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, search_groups_request : Annotated[Optional[SearchGroupsRequest], Field(description="Search request with optional filtering, grouped by a given payload field")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search point groups  # noqa: E501

        Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_point_groups_with_http_info(collection_name, consistency, timeout, search_groups_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param search_groups_request: Search request with optional filtering, grouped by a given payload field
        :type search_groups_request: SearchGroupsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchPointGroups200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'search_groups_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_point_groups" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['search_groups_request'] is not None:
            _body_params = _params['search_groups_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchPointGroups200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/search/groups', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, search_request : Annotated[Optional[SearchRequest], Field(description="Search request with optional filtering")] = None, **kwargs) -> SearchPoints200Response:  # noqa: E501
        """Search points  # noqa: E501

        Retrieve closest points based on vector similarity and given filtering conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_points(collection_name, consistency, timeout, search_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param search_request: Search request with optional filtering
        :type search_request: SearchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchPoints200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_points_with_http_info(collection_name, consistency, timeout, search_request, **kwargs)  # noqa: E501

    @validate_arguments
    def search_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to search in")], consistency : Annotated[Optional[Any], Field(description="Define read consistency guarantees for the operation")] = None, timeout : Annotated[Optional[conint(strict=True, ge=1)], Field(description="If set, overrides global timeout for this request. Unit is seconds.")] = None, search_request : Annotated[Optional[SearchRequest], Field(description="Search request with optional filtering")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search points  # noqa: E501

        Retrieve closest points based on vector similarity and given filtering conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_points_with_http_info(collection_name, consistency, timeout, search_request, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to search in (required)
        :type collection_name: str
        :param consistency: Define read consistency guarantees for the operation
        :type consistency: ReadConsistency
        :param timeout: If set, overrides global timeout for this request. Unit is seconds.
        :type timeout: int
        :param search_request: Search request with optional filtering
        :type search_request: SearchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchPoints200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'consistency',
            'timeout',
            'search_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('consistency') is not None:  # noqa: E501
            _query_params.append(('consistency', _params['consistency']))

        if _params.get('timeout') is not None:  # noqa: E501
            _query_params.append(('timeout', _params['timeout']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['search_request'] is not None:
            _body_params = _params['search_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "SearchPoints200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/search', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def set_payload(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to set from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, set_payload : Annotated[Optional[SetPayload], Field(description="Set payload on points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Set payload  # noqa: E501

        Set payload values for points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_payload(collection_name, wait, ordering, set_payload, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to set from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param set_payload: Set payload on points
        :type set_payload: SetPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the set_payload_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.set_payload_with_http_info(collection_name, wait, ordering, set_payload, **kwargs)  # noqa: E501

    @validate_arguments
    def set_payload_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to set from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, set_payload : Annotated[Optional[SetPayload], Field(description="Set payload on points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Set payload  # noqa: E501

        Set payload values for points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_payload_with_http_info(collection_name, wait, ordering, set_payload, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to set from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param set_payload: Set payload on points
        :type set_payload: SetPayload
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'set_payload'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_payload" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_payload'] is not None:
            _body_params = _params['set_payload']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/payload', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_vectors(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to update from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, update_vectors : Annotated[Optional[UpdateVectors], Field(description="Update named vectors on points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Update vectors  # noqa: E501

        Update specified named vectors on points, keep unspecified vectors intact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_vectors(collection_name, wait, ordering, update_vectors, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to update from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param update_vectors: Update named vectors on points
        :type update_vectors: UpdateVectors
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_vectors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_vectors_with_http_info(collection_name, wait, ordering, update_vectors, **kwargs)  # noqa: E501

    @validate_arguments
    def update_vectors_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to update from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, update_vectors : Annotated[Optional[UpdateVectors], Field(description="Update named vectors on points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update vectors  # noqa: E501

        Update specified named vectors on points, keep unspecified vectors intact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_vectors_with_http_info(collection_name, wait, ordering, update_vectors, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to update from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param update_vectors: Update named vectors on points
        :type update_vectors: UpdateVectors
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'update_vectors'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vectors" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_vectors'] is not None:
            _body_params = _params['update_vectors']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points/vectors', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def upsert_points(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to update from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, point_insert_operations : Annotated[Optional[PointInsertOperations], Field(description="Operation to perform on points")] = None, **kwargs) -> CreateFieldIndex200Response:  # noqa: E501
        """Upsert points  # noqa: E501

        Perform insert + updates on points. If point with given ID already exists - it will be overwritten.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upsert_points(collection_name, wait, ordering, point_insert_operations, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to update from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param point_insert_operations: Operation to perform on points
        :type point_insert_operations: PointInsertOperations
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateFieldIndex200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the upsert_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.upsert_points_with_http_info(collection_name, wait, ordering, point_insert_operations, **kwargs)  # noqa: E501

    @validate_arguments
    def upsert_points_with_http_info(self, collection_name : Annotated[StrictStr, Field(..., description="Name of the collection to update from")], wait : Annotated[Optional[StrictBool], Field(description="If true, wait for changes to actually happen")] = None, ordering : Annotated[Optional[WriteOrdering], Field(description="define ordering guarantees for the operation")] = None, point_insert_operations : Annotated[Optional[PointInsertOperations], Field(description="Operation to perform on points")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Upsert points  # noqa: E501

        Perform insert + updates on points. If point with given ID already exists - it will be overwritten.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upsert_points_with_http_info(collection_name, wait, ordering, point_insert_operations, async_req=True)
        >>> result = thread.get()

        :param collection_name: Name of the collection to update from (required)
        :type collection_name: str
        :param wait: If true, wait for changes to actually happen
        :type wait: bool
        :param ordering: define ordering guarantees for the operation
        :type ordering: WriteOrdering
        :param point_insert_operations: Operation to perform on points
        :type point_insert_operations: PointInsertOperations
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateFieldIndex200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'collection_name',
            'wait',
            'ordering',
            'point_insert_operations'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['collection_name'] is not None:
            _path_params['collection_name'] = _params['collection_name']


        # process the query parameters
        _query_params = []
        if _params.get('wait') is not None:  # noqa: E501
            _query_params.append(('wait', _params['wait']))

        if _params.get('ordering') is not None:  # noqa: E501
            _query_params.append(('ordering', _params['ordering'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['point_insert_operations'] is not None:
            _body_params = _params['point_insert_operations']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api-key', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CreateFieldIndex200Response",
            '4XX': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/collections/{collection_name}/points', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
