"use strict";(self.webpackChunk_jupyterlite_litegitpuller=self.webpackChunk_jupyterlite_litegitpuller||[]).push([[389],{389:(e,t,a)=>{a.r(t),a.d(t,{default:()=>l});var n=a(749),r=a(419);class i{constructor(e){this._errors=new Map,this._defaultFileBrowser=e.defaultFileBrowser,this._contents=e.contents}async clone(e,t,a){await this.createTree([a]);const r=await this.getFileList(e,t);return await this.createTree(r.directories,a).then((async()=>{for(const i of r.files){const r=a?n.PathExt.join(a,i):i;if(await this.fileExists(r)){this.addUploadError("File already exist",r);continue}const s=await this.getFile(e,i,t);await this.createFile(r,s.blob,s.type)}})),this._errors.forEach(((e,t)=>{console.warn(`The following files have not been uploaded.\nCAUSE: ${t}\nFILES: `,e)})),a}async createTree(e,t=null){e.sort();for(let a of e){a=t?n.PathExt.join(t,a):a;const e={type:"directory",path:n.PathExt.dirname(a)};await this._contents.get(a,{content:!1}).catch((()=>{this._contents.newUntitled(e).then((async e=>{await this._contents.rename(e.path,a)}))}))}}async fileExists(e){return this._contents.get(e,{content:!1}).then((()=>!0)).catch((()=>!1))}async createFile(e,t,a){let r=n.PathExt.basename(e),i=0,s=!1;for(;!s;)await this._contents.get(r,{content:!1}).then((()=>{r=`${r}_${i}`,i++})).catch((e=>{s=!0}));const o=new File([t],r,{type:a});await this._defaultFileBrowser.model.upload(o).then((async t=>{t.path!==e&&await this._contents.rename(t.path,e)}))}addUploadError(e,t){var a;const n=null!==(a=this._errors.get(e))&&void 0!==a?a:[];this._errors.set(e,[...n,t])}}class s extends i{async getFileList(e,t){const a=`${e}/git/trees/${t}?recursive=true`,n=await fetch(a,{method:"GET",headers:{Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28","User-Agent":"request"}}).then((e=>e.json())).then((e=>e.tree));return{directories:Object.values(n).filter((e=>"tree"===e.type)).map((e=>e.path)),files:Object.values(n).filter((e=>"blob"===e.type)).map((e=>e.path))}}async getFile(e,t,a){var n;const r=`${e}/contents/${t}?ref=${a}`,i=await fetch(r,{method:"GET",headers:{Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28","User-Agent":"request"}}).then((e=>e.json())).then((e=>e.download_url)),s=await fetch(i);return{blob:await s.blob(),type:null!==(n=s.headers.get("Content-Type"))&&void 0!==n?n:""}}}class o extends i{async getFileList(e,t){const a=`${e}/repository/tree?ref=${t}&recursive=true`,n=await fetch(a,{method:"GET"}).then((e=>e.json())).then((e=>e));return{directories:Object.values(n).filter((e=>"tree"===e.type)).map((e=>e.path)),files:Object.values(n).filter((e=>"blob"===e.type)).map((e=>e.path))}}async getFile(e,t,a){var n;const r=`${e}/repository/files/${encodeURIComponent(t)}/raw?ref=${a}`,i=await fetch(r);return{blob:await i.blob(),type:null!==(n=i.headers.get("Content-Type"))&&void 0!==n?n:""}}}const l={id:"@jupyterlite/litegitpuller:plugin",autoStart:!0,requires:[r.IDefaultFileBrowser],activate:(e,t)=>{if(console.log("JupyterLab extension @jupyterlite/litegitpuller is activated!"),"JupyterLite"!==e.name)return;const a=new URLSearchParams(window.location.search),r=a.get("repo");if(!r)return;let i=null;const l=n.PathExt.basename(r),c=a.get("branch")||"main",h=a.get("provider")||"github";let p=a.get("urlpath");const u=new URL(r);if("github"===h){if("github.com"!==u.hostname)return void console.warn("litegitpuller: the URL does not match with a GITHUB repository");u.hostname="api.github.com",u.pathname=`/repos${u.pathname}`,i=new s({defaultFileBrowser:t,contents:e.serviceManager.contents})}else"gitlab"===h&&(u.pathname=`/api/v4/projects/${encodeURIComponent(u.pathname.slice(1))}`,i=new o({defaultFileBrowser:t,contents:e.serviceManager.contents}));i&&i.clone(u.href,c,l).then((async t=>{p&&(p=n.PathExt.relative("tree/",p),e.commands.execute("filebrowser:open-path",{path:p}))}))}}}}]);