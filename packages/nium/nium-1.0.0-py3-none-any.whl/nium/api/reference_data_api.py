# coding: utf-8

"""
    NIUM Platform

    NIUM Platform

    Contact: experience@nium.com
    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictStr

from typing import List, Optional

from nium.models.partial_search_bank_name_response_dto import PartialSearchBankNameResponseDTO
from nium.models.partial_search_branch_name_response_dto import PartialSearchBranchNameResponseDTO
from nium.models.partial_search_dto import PartialSearchDTO
from nium.models.resource import Resource
from nium.models.supported_corridors_response_dto import SupportedCorridorsResponseDTO

# from nium.api_client import ApiClient
import nium.api_client
from nium.api_response import ApiResponse
from nium.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ReferenceDataApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = nium.api_client.ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def fetch_bank_detailsusing_routing_code(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], country_code : Annotated[StrictStr, Field(..., description="This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) of a beneficiary.")], customer_hash_id : Annotated[StrictStr, Field(..., description="This field accepts the unique customer identifier generated on customer creation.")], routing_code_type : Annotated[StrictStr, Field(..., description="This field accepts the routing code type 1. The possible values are: SWIFT for all cases where SWIFT is applicable IFSC (relevant for India) ACH CODE (relevant for USA) BSB CODE (relevant for Australia) SORT CODE (relevant for the UK) LOCATION ID (relevant for Nepal) BANK CODE (relevant for few countries including Canada, Hong Kong, Sri Lanka, South Korea, Pakistan, Brazil, and some more) TRANSIT NUMBER (relevant for Canada) BRANCH CODE (relevant for Sri Lanka, Vietnam, Brazil, Uruguay, Kenya and some more) Given that the routing_code_type_1 is a PATH parameter, please apply URL encoding. For example, when you want to pass ACH CODE, after URL encoding you will pass it as ACH%20CODE")], routing_code_value : Annotated[StrictStr, Field(..., description="This field accepts the routing code value 1. Refer to the [Examples of Routing Codes](https://docs.nium.com/baas/fetch-bank-details-using-routing-code#examples-of-routing-codes).")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> Resource:  # noqa: E501
        """Fetch Bank Details using Routing Code  # noqa: E501

        This API allows you to fetch the bank details against the routing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.fetch_bank_detailsusing_routing_code(client_hash_id, country_code, customer_hash_id, routing_code_type, routing_code_value, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param country_code: This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) of a beneficiary. (required)
        :type country_code: str
        :param customer_hash_id: This field accepts the unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param routing_code_type: This field accepts the routing code type 1. The possible values are: SWIFT for all cases where SWIFT is applicable IFSC (relevant for India) ACH CODE (relevant for USA) BSB CODE (relevant for Australia) SORT CODE (relevant for the UK) LOCATION ID (relevant for Nepal) BANK CODE (relevant for few countries including Canada, Hong Kong, Sri Lanka, South Korea, Pakistan, Brazil, and some more) TRANSIT NUMBER (relevant for Canada) BRANCH CODE (relevant for Sri Lanka, Vietnam, Brazil, Uruguay, Kenya and some more) Given that the routing_code_type_1 is a PATH parameter, please apply URL encoding. For example, when you want to pass ACH CODE, after URL encoding you will pass it as ACH%20CODE (required)
        :type routing_code_type: str
        :param routing_code_value: This field accepts the routing code value 1. Refer to the [Examples of Routing Codes](https://docs.nium.com/baas/fetch-bank-details-using-routing-code#examples-of-routing-codes). (required)
        :type routing_code_value: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Resource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the fetch_bank_detailsusing_routing_code_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.fetch_bank_detailsusing_routing_code_with_http_info(client_hash_id, country_code, customer_hash_id, routing_code_type, routing_code_value, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def fetch_bank_detailsusing_routing_code_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], country_code : Annotated[StrictStr, Field(..., description="This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) of a beneficiary.")], customer_hash_id : Annotated[StrictStr, Field(..., description="This field accepts the unique customer identifier generated on customer creation.")], routing_code_type : Annotated[StrictStr, Field(..., description="This field accepts the routing code type 1. The possible values are: SWIFT for all cases where SWIFT is applicable IFSC (relevant for India) ACH CODE (relevant for USA) BSB CODE (relevant for Australia) SORT CODE (relevant for the UK) LOCATION ID (relevant for Nepal) BANK CODE (relevant for few countries including Canada, Hong Kong, Sri Lanka, South Korea, Pakistan, Brazil, and some more) TRANSIT NUMBER (relevant for Canada) BRANCH CODE (relevant for Sri Lanka, Vietnam, Brazil, Uruguay, Kenya and some more) Given that the routing_code_type_1 is a PATH parameter, please apply URL encoding. For example, when you want to pass ACH CODE, after URL encoding you will pass it as ACH%20CODE")], routing_code_value : Annotated[StrictStr, Field(..., description="This field accepts the routing code value 1. Refer to the [Examples of Routing Codes](https://docs.nium.com/baas/fetch-bank-details-using-routing-code#examples-of-routing-codes).")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch Bank Details using Routing Code  # noqa: E501

        This API allows you to fetch the bank details against the routing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.fetch_bank_detailsusing_routing_code_with_http_info(client_hash_id, country_code, customer_hash_id, routing_code_type, routing_code_value, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param country_code: This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) of a beneficiary. (required)
        :type country_code: str
        :param customer_hash_id: This field accepts the unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param routing_code_type: This field accepts the routing code type 1. The possible values are: SWIFT for all cases where SWIFT is applicable IFSC (relevant for India) ACH CODE (relevant for USA) BSB CODE (relevant for Australia) SORT CODE (relevant for the UK) LOCATION ID (relevant for Nepal) BANK CODE (relevant for few countries including Canada, Hong Kong, Sri Lanka, South Korea, Pakistan, Brazil, and some more) TRANSIT NUMBER (relevant for Canada) BRANCH CODE (relevant for Sri Lanka, Vietnam, Brazil, Uruguay, Kenya and some more) Given that the routing_code_type_1 is a PATH parameter, please apply URL encoding. For example, when you want to pass ACH CODE, after URL encoding you will pass it as ACH%20CODE (required)
        :type routing_code_type: str
        :param routing_code_value: This field accepts the routing code value 1. Refer to the [Examples of Routing Codes](https://docs.nium.com/baas/fetch-bank-details-using-routing-code#examples-of-routing-codes). (required)
        :type routing_code_value: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Resource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'country_code',
            'customer_hash_id',
            'routing_code_type',
            'routing_code_value',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_bank_detailsusing_routing_code" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['country_code']:
            _path_params['countryCode'] = _params['country_code']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['routing_code_type']:
            _path_params['routingCodeType'] = _params['routing_code_type']

        if _params['routing_code_value']:
            _path_params['routingCodeValue'] = _params['routing_code_value']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "Resource",
            '400': "CustomerApiError",
            '401': "str",
            '403': "str",
            '404': "CustomerApiError",
            '500': "CustomerApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/country/{countryCode}/routingCodeType/{routingCodeType}/routingCodeValue/{routingCodeValue}/routingCode', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def fetch_supported_corridors(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> Resource:  # noqa: E501
        """Fetch Supported Corridors  # noqa: E501

        This API will allow you to fetch the supported corridors for remittance with details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.fetch_supported_corridors(client_hash_id, customer_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Resource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the fetch_supported_corridors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.fetch_supported_corridors_with_http_info(client_hash_id, customer_hash_id, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def fetch_supported_corridors_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch Supported Corridors  # noqa: E501

        This API will allow you to fetch the supported corridors for remittance with details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.fetch_supported_corridors_with_http_info(client_hash_id, customer_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Resource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'customer_hash_id',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_supported_corridors" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "Resource",
            '400': "CustomerApiError",
            '401': "str",
            '403': "str",
            '404': "CustomerApiError",
            '500': "CustomerApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/supportedCorridors', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def fetch_supported_corridors_v2(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], beneficiary_account_type : Annotated[Optional[StrictStr], Field(description="This field accepts the beneficiary account type.")] = None, client_type : Annotated[Optional[StrictStr], Field(description="This field accepts type of Client e.g. FI, NonFI, default NonFI.")] = None, customer_type : Annotated[Optional[StrictStr], Field(description="This field accepts the type of customer.")] = None, destination_country : Annotated[Optional[StrictStr], Field(description="This field accepts the [2-letter ISO-2 destination country code](https://docs.nium.com/apis/docs/currency-and-country-codes).")] = None, destination_currency : Annotated[Optional[StrictStr], Field(description="This field accepts the [3-letter ISO-4217 currency code](https://docs.nium.com/apis/docs/currency-and-country-codes) which will be used to filter the user selected currency and get the payout method.")] = None, payout_method : Annotated[Optional[StrictStr], Field(description="This field accepts the different modes of payout.")] = None, routing_code_type : Annotated[Optional[StrictStr], Field(description="This field determines the routing code type for the currency.")] = None, x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> List[SupportedCorridorsResponseDTO]:  # noqa: E501
        """Fetch Supported Corridors V2  # noqa: E501

        This API will allow you to fetch the supported corridors for remittance with details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.fetch_supported_corridors_v2(client_hash_id, beneficiary_account_type, client_type, customer_type, destination_country, destination_currency, payout_method, routing_code_type, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param beneficiary_account_type: This field accepts the beneficiary account type.
        :type beneficiary_account_type: str
        :param client_type: This field accepts type of Client e.g. FI, NonFI, default NonFI.
        :type client_type: str
        :param customer_type: This field accepts the type of customer.
        :type customer_type: str
        :param destination_country: This field accepts the [2-letter ISO-2 destination country code](https://docs.nium.com/apis/docs/currency-and-country-codes).
        :type destination_country: str
        :param destination_currency: This field accepts the [3-letter ISO-4217 currency code](https://docs.nium.com/apis/docs/currency-and-country-codes) which will be used to filter the user selected currency and get the payout method.
        :type destination_currency: str
        :param payout_method: This field accepts the different modes of payout.
        :type payout_method: str
        :param routing_code_type: This field determines the routing code type for the currency.
        :type routing_code_type: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[SupportedCorridorsResponseDTO]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the fetch_supported_corridors_v2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.fetch_supported_corridors_v2_with_http_info(client_hash_id, beneficiary_account_type, client_type, customer_type, destination_country, destination_currency, payout_method, routing_code_type, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def fetch_supported_corridors_v2_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], beneficiary_account_type : Annotated[Optional[StrictStr], Field(description="This field accepts the beneficiary account type.")] = None, client_type : Annotated[Optional[StrictStr], Field(description="This field accepts type of Client e.g. FI, NonFI, default NonFI.")] = None, customer_type : Annotated[Optional[StrictStr], Field(description="This field accepts the type of customer.")] = None, destination_country : Annotated[Optional[StrictStr], Field(description="This field accepts the [2-letter ISO-2 destination country code](https://docs.nium.com/apis/docs/currency-and-country-codes).")] = None, destination_currency : Annotated[Optional[StrictStr], Field(description="This field accepts the [3-letter ISO-4217 currency code](https://docs.nium.com/apis/docs/currency-and-country-codes) which will be used to filter the user selected currency and get the payout method.")] = None, payout_method : Annotated[Optional[StrictStr], Field(description="This field accepts the different modes of payout.")] = None, routing_code_type : Annotated[Optional[StrictStr], Field(description="This field determines the routing code type for the currency.")] = None, x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch Supported Corridors V2  # noqa: E501

        This API will allow you to fetch the supported corridors for remittance with details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.fetch_supported_corridors_v2_with_http_info(client_hash_id, beneficiary_account_type, client_type, customer_type, destination_country, destination_currency, payout_method, routing_code_type, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param beneficiary_account_type: This field accepts the beneficiary account type.
        :type beneficiary_account_type: str
        :param client_type: This field accepts type of Client e.g. FI, NonFI, default NonFI.
        :type client_type: str
        :param customer_type: This field accepts the type of customer.
        :type customer_type: str
        :param destination_country: This field accepts the [2-letter ISO-2 destination country code](https://docs.nium.com/apis/docs/currency-and-country-codes).
        :type destination_country: str
        :param destination_currency: This field accepts the [3-letter ISO-4217 currency code](https://docs.nium.com/apis/docs/currency-and-country-codes) which will be used to filter the user selected currency and get the payout method.
        :type destination_currency: str
        :param payout_method: This field accepts the different modes of payout.
        :type payout_method: str
        :param routing_code_type: This field determines the routing code type for the currency.
        :type routing_code_type: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[SupportedCorridorsResponseDTO], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'beneficiary_account_type',
            'client_type',
            'customer_type',
            'destination_country',
            'destination_currency',
            'payout_method',
            'routing_code_type',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_supported_corridors_v2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']


        # process the query parameters
        _query_params = []
        if _params.get('beneficiary_account_type') is not None:  # noqa: E501
            _query_params.append(('beneficiaryAccountType', _params['beneficiary_account_type']))

        if _params.get('client_type') is not None:  # noqa: E501
            _query_params.append(('clientType', _params['client_type']))

        if _params.get('customer_type') is not None:  # noqa: E501
            _query_params.append(('customerType', _params['customer_type']))

        if _params.get('destination_country') is not None:  # noqa: E501
            _query_params.append(('destinationCountry', _params['destination_country']))

        if _params.get('destination_currency') is not None:  # noqa: E501
            _query_params.append(('destinationCurrency', _params['destination_currency']))

        if _params.get('payout_method') is not None:  # noqa: E501
            _query_params.append(('payoutMethod', _params['payout_method']))

        if _params.get('routing_code_type') is not None:  # noqa: E501
            _query_params.append(('routingCodeType', _params['routing_code_type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "List[SupportedCorridorsResponseDTO]",
            '400': "CustomerApiError",
            '401': "str",
            '403': "str",
            '404': "CustomerApiError",
            '500': "CustomerApiError",
        }

        return self.api_client.call_api(
            '/api/v2/client/{clientHashId}/supportedCorridors', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_routing_code_using_bank_name(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], country_code : Annotated[StrictStr, Field(..., description="This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated.")], routing_code_type : Annotated[StrictStr, Field(..., description="This field determines the routing code type for the search.")], search_value : Annotated[StrictStr, Field(..., description="This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS.")], bank_code : Annotated[Optional[StrictStr], Field(description="This field can accept the bank code of specified branch and country.")] = None, bank_name : Annotated[Optional[StrictStr], Field(description="This field can accept the bank name associated with country.")] = None, currency_code : Annotated[Optional[StrictStr], Field(description="This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.")] = None, payout_method : Annotated[Optional[StrictStr], Field(description="This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.")] = None, x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> List[PartialSearchBankNameResponseDTO]:  # noqa: E501
        """Search Routing Code Using Bank Name  # noqa: E501

        This API will allow you to search the routing code details using bank name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_routing_code_using_bank_name(client_hash_id, country_code, routing_code_type, search_value, bank_code, bank_name, currency_code, payout_method, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param country_code: This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated. (required)
        :type country_code: str
        :param routing_code_type: This field determines the routing code type for the search. (required)
        :type routing_code_type: str
        :param search_value: This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS. (required)
        :type search_value: str
        :param bank_code: This field can accept the bank code of specified branch and country.
        :type bank_code: str
        :param bank_name: This field can accept the bank name associated with country.
        :type bank_name: str
        :param currency_code: This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.
        :type currency_code: str
        :param payout_method: This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.
        :type payout_method: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PartialSearchBankNameResponseDTO]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_routing_code_using_bank_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_routing_code_using_bank_name_with_http_info(client_hash_id, country_code, routing_code_type, search_value, bank_code, bank_name, currency_code, payout_method, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def search_routing_code_using_bank_name_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], country_code : Annotated[StrictStr, Field(..., description="This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated.")], routing_code_type : Annotated[StrictStr, Field(..., description="This field determines the routing code type for the search.")], search_value : Annotated[StrictStr, Field(..., description="This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS.")], bank_code : Annotated[Optional[StrictStr], Field(description="This field can accept the bank code of specified branch and country.")] = None, bank_name : Annotated[Optional[StrictStr], Field(description="This field can accept the bank name associated with country.")] = None, currency_code : Annotated[Optional[StrictStr], Field(description="This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.")] = None, payout_method : Annotated[Optional[StrictStr], Field(description="This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.")] = None, x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search Routing Code Using Bank Name  # noqa: E501

        This API will allow you to search the routing code details using bank name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_routing_code_using_bank_name_with_http_info(client_hash_id, country_code, routing_code_type, search_value, bank_code, bank_name, currency_code, payout_method, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param country_code: This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated. (required)
        :type country_code: str
        :param routing_code_type: This field determines the routing code type for the search. (required)
        :type routing_code_type: str
        :param search_value: This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS. (required)
        :type search_value: str
        :param bank_code: This field can accept the bank code of specified branch and country.
        :type bank_code: str
        :param bank_name: This field can accept the bank name associated with country.
        :type bank_name: str
        :param currency_code: This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.
        :type currency_code: str
        :param payout_method: This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.
        :type payout_method: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PartialSearchBankNameResponseDTO], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'country_code',
            'routing_code_type',
            'search_value',
            'bank_code',
            'bank_name',
            'currency_code',
            'payout_method',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_routing_code_using_bank_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']


        # process the query parameters
        _query_params = []
        if _params.get('bank_code') is not None:  # noqa: E501
            _query_params.append(('bankCode', _params['bank_code']))

        if _params.get('bank_name') is not None:  # noqa: E501
            _query_params.append(('bankName', _params['bank_name']))

        if _params.get('country_code') is not None:  # noqa: E501
            _query_params.append(('countryCode', _params['country_code']))

        if _params.get('currency_code') is not None:  # noqa: E501
            _query_params.append(('currencyCode', _params['currency_code']))

        if _params.get('payout_method') is not None:  # noqa: E501
            _query_params.append(('payoutMethod', _params['payout_method']))

        if _params.get('routing_code_type') is not None:  # noqa: E501
            _query_params.append(('routingCodeType', _params['routing_code_type']))

        if _params.get('search_value') is not None:  # noqa: E501
            _query_params.append(('searchValue', _params['search_value']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "List[PartialSearchBankNameResponseDTO]",
            '400': "CustomerApiError",
            '401': "str",
            '403': "str",
            '404': "CustomerApiError",
            '500': "CustomerApiError",
        }

        return self.api_client.call_api(
            '/api/v2/client/{clientHashId}/payout/banks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_routing_code_using_branch_name(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], country_code : Annotated[StrictStr, Field(..., description="This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated.")], routing_code_type : Annotated[StrictStr, Field(..., description="This field determines the routing code type for the search.")], search_value : Annotated[StrictStr, Field(..., description="This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS.")], bank_code : Annotated[Optional[StrictStr], Field(description="This field can accept the bank code of specified branch and country.")] = None, bank_name : Annotated[Optional[StrictStr], Field(description="This field can accept the bank name associated with country.")] = None, currency_code : Annotated[Optional[StrictStr], Field(description="This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.")] = None, payout_method : Annotated[Optional[StrictStr], Field(description="This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.")] = None, x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> List[PartialSearchBranchNameResponseDTO]:  # noqa: E501
        """Search Routing Code Using Branch Name  # noqa: E501

        This API will allow you to search the routing code details using branch name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_routing_code_using_branch_name(client_hash_id, country_code, routing_code_type, search_value, bank_code, bank_name, currency_code, payout_method, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param country_code: This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated. (required)
        :type country_code: str
        :param routing_code_type: This field determines the routing code type for the search. (required)
        :type routing_code_type: str
        :param search_value: This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS. (required)
        :type search_value: str
        :param bank_code: This field can accept the bank code of specified branch and country.
        :type bank_code: str
        :param bank_name: This field can accept the bank name associated with country.
        :type bank_name: str
        :param currency_code: This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.
        :type currency_code: str
        :param payout_method: This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.
        :type payout_method: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PartialSearchBranchNameResponseDTO]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_routing_code_using_branch_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_routing_code_using_branch_name_with_http_info(client_hash_id, country_code, routing_code_type, search_value, bank_code, bank_name, currency_code, payout_method, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def search_routing_code_using_branch_name_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], country_code : Annotated[StrictStr, Field(..., description="This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated.")], routing_code_type : Annotated[StrictStr, Field(..., description="This field determines the routing code type for the search.")], search_value : Annotated[StrictStr, Field(..., description="This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS.")], bank_code : Annotated[Optional[StrictStr], Field(description="This field can accept the bank code of specified branch and country.")] = None, bank_name : Annotated[Optional[StrictStr], Field(description="This field can accept the bank name associated with country.")] = None, currency_code : Annotated[Optional[StrictStr], Field(description="This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.")] = None, payout_method : Annotated[Optional[StrictStr], Field(description="This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.")] = None, x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search Routing Code Using Branch Name  # noqa: E501

        This API will allow you to search the routing code details using branch name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_routing_code_using_branch_name_with_http_info(client_hash_id, country_code, routing_code_type, search_value, bank_code, bank_name, currency_code, payout_method, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param country_code: This field accepts the [2-letter ISO-2 country code](https://nium-documents.s3-eu-west-1.amazonaws.com/spend-documents/Country+Code.pdf) for which routing code search is initiated. (required)
        :type country_code: str
        :param routing_code_type: This field determines the routing code type for the search. (required)
        :type routing_code_type: str
        :param search_value: This field accepts the partial or full value of the Bank Name on which the search is initiated, for example, it could be DBS. (required)
        :type search_value: str
        :param bank_code: This field can accept the bank code of specified branch and country.
        :type bank_code: str
        :param bank_name: This field can accept the bank name associated with country.
        :type bank_name: str
        :param currency_code: This field accepts the [3-letter ISO-4217 currency code](https://www.iso.org/iso-4217-currency-codes.html) for which routing code search is to be initiated.
        :type currency_code: str
        :param payout_method: This field can accept the different modes of payout. This field can accept one of the following values: LOCAL SWIFT WALLET CARD PROXY(upcoming feature) Default value of the parameter is LOCAL.
        :type payout_method: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PartialSearchBranchNameResponseDTO], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'country_code',
            'routing_code_type',
            'search_value',
            'bank_code',
            'bank_name',
            'currency_code',
            'payout_method',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_routing_code_using_branch_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']


        # process the query parameters
        _query_params = []
        if _params.get('bank_code') is not None:  # noqa: E501
            _query_params.append(('bankCode', _params['bank_code']))

        if _params.get('bank_name') is not None:  # noqa: E501
            _query_params.append(('bankName', _params['bank_name']))

        if _params.get('country_code') is not None:  # noqa: E501
            _query_params.append(('countryCode', _params['country_code']))

        if _params.get('currency_code') is not None:  # noqa: E501
            _query_params.append(('currencyCode', _params['currency_code']))

        if _params.get('payout_method') is not None:  # noqa: E501
            _query_params.append(('payoutMethod', _params['payout_method']))

        if _params.get('routing_code_type') is not None:  # noqa: E501
            _query_params.append(('routingCodeType', _params['routing_code_type']))

        if _params.get('search_value') is not None:  # noqa: E501
            _query_params.append(('searchValue', _params['search_value']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "List[PartialSearchBranchNameResponseDTO]",
            '400': "CustomerApiError",
            '401': "str",
            '403': "str",
            '404': "CustomerApiError",
            '500': "CustomerApiError",
        }

        return self.api_client.call_api(
            '/api/v2/client/{clientHashId}/payout/branches', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_routing_codeusingbanknamebranchname(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], partial_search_dto : Annotated[PartialSearchDTO, Field(..., description="partialSearchDTO")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> Resource:  # noqa: E501
        """Search Routing Code (using bank name/branch name)  # noqa: E501

        This API will allow you to search the routing code details of a bank based on certain parameters - i.e., by using bank name or branch name. This API will help you to build a user experience where you can help your users to locate a specific routing code (that could be SWIFT, IFSC, SORT CODE, ACH CODE, etc., - see the list below) by using full or partial name search of bank name or branch name. For example, if your user is looking for SWIFT CODE for HSBC in the UK, then this API can be used to search for the SORT CODE by searching using the bank name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_routing_codeusingbanknamebranchname(client_hash_id, customer_hash_id, partial_search_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param partial_search_dto: partialSearchDTO (required)
        :type partial_search_dto: PartialSearchDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Resource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_routing_codeusingbanknamebranchname_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_routing_codeusingbanknamebranchname_with_http_info(client_hash_id, customer_hash_id, partial_search_dto, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def search_routing_codeusingbanknamebranchname_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], partial_search_dto : Annotated[PartialSearchDTO, Field(..., description="partialSearchDTO")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search Routing Code (using bank name/branch name)  # noqa: E501

        This API will allow you to search the routing code details of a bank based on certain parameters - i.e., by using bank name or branch name. This API will help you to build a user experience where you can help your users to locate a specific routing code (that could be SWIFT, IFSC, SORT CODE, ACH CODE, etc., - see the list below) by using full or partial name search of bank name or branch name. For example, if your user is looking for SWIFT CODE for HSBC in the UK, then this API can be used to search for the SORT CODE by searching using the bank name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_routing_codeusingbanknamebranchname_with_http_info(client_hash_id, customer_hash_id, partial_search_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param partial_search_dto: partialSearchDTO (required)
        :type partial_search_dto: PartialSearchDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Resource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'customer_hash_id',
            'partial_search_dto',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_routing_codeusingbanknamebranchname" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['partial_search_dto'] is not None:
            _body_params = _params['partial_search_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "Resource",
            '400': "CustomerApiError",
            '401': "str",
            '403': "str",
            '404': "CustomerApiError",
            '500': "CustomerApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/partialSearch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
