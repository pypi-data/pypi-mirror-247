# coding: utf-8

"""
    NIUM Platform

    NIUM Platform

    Contact: experience@nium.com
    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictStr

from typing import Optional

from nium.models.api_response_of_transaction_channels_response_dto import ApiResponseOfTransactionChannelsResponseDTO
from nium.models.channel_action_request_dto import ChannelActionRequestDTO
from nium.models.mcc_restriction_dto import MCCRestrictionDTO
from nium.models.transaction_limits_dto import TransactionLimitsDTO
from nium.models.transaction_wallet_limits_dto import TransactionWalletLimitsDTO
from nium.models.wallet_api_response2 import WalletApiResponse2
from nium.models.wallet_api_response_ofstring import WalletApiResponseOfstring

# from nium.api_client import ApiClient
import nium.api_client
from nium.api_response import ApiResponse
from nium.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ControlsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = nium.api_client.ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_card_limits(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> TransactionLimitsDTO:  # noqa: E501
        """Fetch Card Limits  # noqa: E501

        This API allows you to fetch card limits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_card_limits(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransactionLimitsDTO
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_card_limits_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_card_limits_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_card_limits_with_http_info(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch Card Limits  # noqa: E501

        This API allows you to fetch card limits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_card_limits_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransactionLimitsDTO, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'card_hash_id',
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_card_limits" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['card_hash_id']:
            _path_params['cardHashId'] = _params['card_hash_id']

        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "TransactionLimitsDTO",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/card/{cardHashId}/limits', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_channel_restriction(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponseOfTransactionChannelsResponseDTO:  # noqa: E501
        """Get Channel Restriction  # noqa: E501

        This API will get the restriction set at card level for all the channels, for example, instore, online, ATM, cross border, and magnetic stripe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_channel_restriction(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiResponseOfTransactionChannelsResponseDTO
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_channel_restriction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_channel_restriction_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_channel_restriction_with_http_info(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Channel Restriction  # noqa: E501

        This API will get the restriction set at card level for all the channels, for example, instore, online, ATM, cross border, and magnetic stripe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_channel_restriction_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiResponseOfTransactionChannelsResponseDTO, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'card_hash_id',
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channel_restriction" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['card_hash_id']:
            _path_params['cardHashId'] = _params['card_hash_id']

        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "ApiResponseOfTransactionChannelsResponseDTO",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/card/{cardHashId}/channels', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_mcc_channel_restrictions(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> MCCRestrictionDTO:  # noqa: E501
        """Get MCC Channel Restrictions  # noqa: E501

        This API allows you to fetch MCC based channel restrictions at the card level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_mcc_channel_restrictions(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MCCRestrictionDTO
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_mcc_channel_restrictions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_mcc_channel_restrictions_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_mcc_channel_restrictions_with_http_info(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get MCC Channel Restrictions  # noqa: E501

        This API allows you to fetch MCC based channel restrictions at the card level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_mcc_channel_restrictions_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MCCRestrictionDTO, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'card_hash_id',
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mcc_channel_restrictions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['card_hash_id']:
            _path_params['cardHashId'] = _params['card_hash_id']

        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "MCCRestrictionDTO",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/card/{cardHashId}/channels/mcc', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def limits_for_all_cards_for_a_customer(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> TransactionWalletLimitsDTO:  # noqa: E501
        """Limits For All Cards For A Customer  # noqa: E501

        This API allows you to fetch card level limits for all cards belonging to a customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.limits_for_all_cards_for_a_customer(client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransactionWalletLimitsDTO
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the limits_for_all_cards_for_a_customer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.limits_for_all_cards_for_a_customer_with_http_info(client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def limits_for_all_cards_for_a_customer_with_http_info(self, client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Limits For All Cards For A Customer  # noqa: E501

        This API allows you to fetch card level limits for all cards belonging to a customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.limits_for_all_cards_for_a_customer_with_http_info(client_hash_id, customer_hash_id, wallet_hash_id, x_request_id, async_req=True)
        >>> result = thread.get()

        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransactionWalletLimitsDTO, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method limits_for_all_cards_for_a_customer" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "TransactionWalletLimitsDTO",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/limits', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def set_card_limits(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], transaction_limits_dto : Annotated[TransactionLimitsDTO, Field(..., description="transactionLimitsDTO")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> WalletApiResponse2:  # noqa: E501
        """Card Limits  # noqa: E501

        This API allows you to set card limits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_card_limits(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, transaction_limits_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param transaction_limits_dto: transactionLimitsDTO (required)
        :type transaction_limits_dto: TransactionLimitsDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WalletApiResponse2
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the set_card_limits_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.set_card_limits_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, transaction_limits_dto, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def set_card_limits_with_http_info(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], transaction_limits_dto : Annotated[TransactionLimitsDTO, Field(..., description="transactionLimitsDTO")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Card Limits  # noqa: E501

        This API allows you to set card limits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_card_limits_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, transaction_limits_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param transaction_limits_dto: transactionLimitsDTO (required)
        :type transaction_limits_dto: TransactionLimitsDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WalletApiResponse2, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'card_hash_id',
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'transaction_limits_dto',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_card_limits" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['card_hash_id']:
            _path_params['cardHashId'] = _params['card_hash_id']

        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['transaction_limits_dto'] is not None:
            _body_params = _params['transaction_limits_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "WalletApiResponse2",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/card/{cardHashId}/limits', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_channel_restriction(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], channel_action_request_dto : Annotated[ChannelActionRequestDTO, Field(..., description="channelActionRequestDTO")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> WalletApiResponseOfstring:  # noqa: E501
        """Update Channel Restriction  # noqa: E501

        This API will restrict transaction at card level for a given channel, for example, in instore, online, ATM, cross border and magnetic stripe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_channel_restriction(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, channel_action_request_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param channel_action_request_dto: channelActionRequestDTO (required)
        :type channel_action_request_dto: ChannelActionRequestDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WalletApiResponseOfstring
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_channel_restriction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_channel_restriction_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, channel_action_request_dto, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def update_channel_restriction_with_http_info(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], channel_action_request_dto : Annotated[ChannelActionRequestDTO, Field(..., description="channelActionRequestDTO")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update Channel Restriction  # noqa: E501

        This API will restrict transaction at card level for a given channel, for example, in instore, online, ATM, cross border and magnetic stripe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_channel_restriction_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, channel_action_request_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param channel_action_request_dto: channelActionRequestDTO (required)
        :type channel_action_request_dto: ChannelActionRequestDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WalletApiResponseOfstring, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'card_hash_id',
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'channel_action_request_dto',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_channel_restriction" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['card_hash_id']:
            _path_params['cardHashId'] = _params['card_hash_id']

        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['channel_action_request_dto'] is not None:
            _body_params = _params['channel_action_request_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "WalletApiResponseOfstring",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/card/{cardHashId}/channels', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_mcc_channel_restrictions(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], mcc_restriction_dto : Annotated[MCCRestrictionDTO, Field(..., description="The API will work as below:  If the status is Active and channelStrategy is WHITE_LIST, then the MCC in the list only gets processed and the rest will be blocked  If the status is Inactive then the MCC whitelist restriction will be Inactive.  If the status is Active and channelStrategy is BLACK_LIST then only the MCC in the list will get blocked and the rest will be allowed.  If the status is Inactive then the MCC blacklist restriction will be Inactive  Either blacklist or whitelist can be enabled at one point in time.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> WalletApiResponse2:  # noqa: E501
        """Update MCC Channel Restrictions  # noqa: E501

        This API allows you to create MCC based channel restrictions at the card level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_mcc_channel_restrictions(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, mcc_restriction_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param mcc_restriction_dto: The API will work as below:  If the status is Active and channelStrategy is WHITE_LIST, then the MCC in the list only gets processed and the rest will be blocked  If the status is Inactive then the MCC whitelist restriction will be Inactive.  If the status is Active and channelStrategy is BLACK_LIST then only the MCC in the list will get blocked and the rest will be allowed.  If the status is Inactive then the MCC blacklist restriction will be Inactive  Either blacklist or whitelist can be enabled at one point in time. (required)
        :type mcc_restriction_dto: MCCRestrictionDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WalletApiResponse2
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_mcc_channel_restrictions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_mcc_channel_restrictions_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, mcc_restriction_dto, x_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def update_mcc_channel_restrictions_with_http_info(self, card_hash_id : Annotated[StrictStr, Field(..., description="Unique card identifier generated while new/add-on card issuance.")], client_hash_id : Annotated[StrictStr, Field(..., description="Unique client identifier generated and shared before API handshake.")], customer_hash_id : Annotated[StrictStr, Field(..., description="Unique customer identifier generated on customer creation.")], wallet_hash_id : Annotated[StrictStr, Field(..., description="Unique wallet identifier generated simultaneously with customer creation.")], mcc_restriction_dto : Annotated[MCCRestrictionDTO, Field(..., description="The API will work as below:  If the status is Active and channelStrategy is WHITE_LIST, then the MCC in the list only gets processed and the rest will be blocked  If the status is Inactive then the MCC whitelist restriction will be Inactive.  If the status is Active and channelStrategy is BLACK_LIST then only the MCC in the list will get blocked and the rest will be allowed.  If the status is Inactive then the MCC blacklist restriction will be Inactive  Either blacklist or whitelist can be enabled at one point in time.")], x_request_id : Annotated[Optional[StrictStr], Field(description="Enter a unique UUID value.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update MCC Channel Restrictions  # noqa: E501

        This API allows you to create MCC based channel restrictions at the card level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_mcc_channel_restrictions_with_http_info(card_hash_id, client_hash_id, customer_hash_id, wallet_hash_id, mcc_restriction_dto, x_request_id, async_req=True)
        >>> result = thread.get()

        :param card_hash_id: Unique card identifier generated while new/add-on card issuance. (required)
        :type card_hash_id: str
        :param client_hash_id: Unique client identifier generated and shared before API handshake. (required)
        :type client_hash_id: str
        :param customer_hash_id: Unique customer identifier generated on customer creation. (required)
        :type customer_hash_id: str
        :param wallet_hash_id: Unique wallet identifier generated simultaneously with customer creation. (required)
        :type wallet_hash_id: str
        :param mcc_restriction_dto: The API will work as below:  If the status is Active and channelStrategy is WHITE_LIST, then the MCC in the list only gets processed and the rest will be blocked  If the status is Inactive then the MCC whitelist restriction will be Inactive.  If the status is Active and channelStrategy is BLACK_LIST then only the MCC in the list will get blocked and the rest will be allowed.  If the status is Inactive then the MCC blacklist restriction will be Inactive  Either blacklist or whitelist can be enabled at one point in time. (required)
        :type mcc_restriction_dto: MCCRestrictionDTO
        :param x_request_id: Enter a unique UUID value.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WalletApiResponse2, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'card_hash_id',
            'client_hash_id',
            'customer_hash_id',
            'wallet_hash_id',
            'mcc_restriction_dto',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mcc_channel_restrictions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['card_hash_id']:
            _path_params['cardHashId'] = _params['card_hash_id']

        if _params['client_hash_id']:
            _path_params['clientHashId'] = _params['client_hash_id']

        if _params['customer_hash_id']:
            _path_params['customerHashId'] = _params['customer_hash_id']

        if _params['wallet_hash_id']:
            _path_params['walletHashId'] = _params['wallet_hash_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id']:
            _header_params['x-request-id'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['mcc_restriction_dto'] is not None:
            _body_params = _params['mcc_restriction_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['default']  # noqa: E501

        _response_types_map = {
            '200': "WalletApiResponse2",
            '400': "WalletApiError",
            '401': "str",
            '403': "str",
            '404': "WalletApiError",
            '500': "WalletApiError",
        }

        return self.api_client.call_api(
            '/api/v1/client/{clientHashId}/customer/{customerHashId}/wallet/{walletHashId}/card/{cardHashId}/channels/mcc', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
