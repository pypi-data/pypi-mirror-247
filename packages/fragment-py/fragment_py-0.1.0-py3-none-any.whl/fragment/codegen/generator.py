from typing import Dict, List

from fragment.types import SchemaLedgerEntry


def add_padded_lines(lines: int = 1) -> List[str]:
    return [""] * lines


def indented_line(line: str, *, level: int = 0) -> str:
    indentation = " " * 4 * level
    return f"{indentation}{line}"


def get_imports() -> List[str]:
    import_lines = [
        "from dataclasses import dataclass",
    ]
    import_lines.extend(add_padded_lines(lines=1))
    import_lines.extend(
        [
            "from fragment.types import BaseEntry",
            "from strenum import StrEnum",
        ]
    )
    return import_lines


def get_entry_type_dataclass_name(entry_type: str) -> str:
    return entry_type.replace("_", "__").replace("-", "_")


def generate_entry_types_code(
    schemaKey: str, type_to_entry: Dict[str, SchemaLedgerEntry]
) -> str:
    lines = []
    # Generate the header for the file
    lines.append(indented_line(f"# AUTOGENERATED FROM {schemaKey} WITH fragment-py"))
    lines.append(indented_line("# DO NOT EDIT THIS FILE DIRECTLY"))
    # Write the imports
    lines.extend(get_imports())
    lines.extend(add_padded_lines(lines=2))
    # Write the entry type enum
    entry_types = list(type_to_entry.keys())
    if len(entry_types) > 0:
        lines.append("class EntryType(StrEnum):")
        for entry_type in type_to_entry.keys():
            formatted_type = get_entry_type_dataclass_name(entry_type)
            lines.append(indented_line(f"{formatted_type} = '{entry_type}'", level=1))
        lines.extend(add_padded_lines(lines=2))
    for type, entry in type_to_entry.items():
        formatted_type = get_entry_type_dataclass_name(type)
        hasParams = (
            entry.required_parameters is not None and len(entry.required_parameters) > 0
        )
        lines.append(indented_line(f"@dataclass(frozen=True, kw_only=True)"))
        lines.append(indented_line(f"class {formatted_type}_Entry(BaseEntry):"))
        lines.append(
            indented_line(
                f"__LEDGER_ENTRY_TYPE__: EntryType = EntryType.{formatted_type}",
                level=1,
            )
        )
        if hasParams:
            for parameter in sorted(entry.required_parameters):
                lines.append(indented_line(f"{parameter}: str", level=1))
        lines.extend(add_padded_lines(lines=2))
    return "\n".join(lines)
