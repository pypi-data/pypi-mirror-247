from typing import Dict, List, Set

from fragment.types import SchemaLedgerAccount, SchemaLedgerEntry


def add_padded_lines(lines: int = 1) -> List[str]:
    return [""] * lines


def indented_line(line: str, *, level: int = 0) -> str:
    indentation = " " * 4 * level
    return f"{indentation}{line}"


def get_imports() -> List[str]:
    import_lines = [
        "from dataclasses import dataclass",
    ]
    import_lines.extend(add_padded_lines(lines=1))
    import_lines.extend(
        [
            "from fragment.types import BaseEntry, BaseLedgerAccountFactory, SchemaLedgerAccount, CurrencyMode",
            "from strenum import StrEnum",
        ]
    )
    return import_lines


def format_python_class_name(class_name: str) -> str:
    return class_name.replace("_", "__").replace("-", "_")


def generate_code(
    schemaKey: str,
    type_to_entry: Dict[str, SchemaLedgerEntry],
    structural_path_to_accounts: Dict[str, SchemaLedgerAccount],
) -> str:
    lines = []
    # Generate the header for the file
    lines.append(indented_line(f"# AUTOGENERATED FROM {schemaKey} WITH fragment-py"))
    lines.append(indented_line("# DO NOT EDIT THIS FILE DIRECTLY"))
    # Write the imports
    lines.extend(get_imports())
    lines.extend(add_padded_lines(lines=2))
    # Write the entry type enum
    entry_types = list(type_to_entry.keys())
    if len(entry_types) > 0:
        lines.append("# Entry types")
        lines.extend(add_padded_lines(lines=1))
        lines.append("class EntryType(StrEnum):")
        for entry_type in type_to_entry.keys():
            formatted_type = format_python_class_name(entry_type)
            lines.append(indented_line(f"{formatted_type} = '{entry_type}'", level=1))
        lines.extend(add_padded_lines(lines=2))
    for type, entry in type_to_entry.items():
        formatted_type = format_python_class_name(type)
        hasParams = (
            entry.required_parameters is not None and len(entry.required_parameters) > 0
        )
        lines.append(indented_line(f"@dataclass(frozen=True, kw_only=True)"))
        lines.append(indented_line(f"class {formatted_type}_Entry(BaseEntry):"))
        lines.append(
            indented_line(
                f"__LEDGER_ENTRY_TYPE__: EntryType = EntryType.{formatted_type}",
                level=1,
            )
        )
        if hasParams:
            for parameter in sorted(entry.required_parameters):
                lines.append(indented_line(f"{parameter}: str", level=1))
        lines.extend(add_padded_lines(lines=2))

    structural_paths = list(structural_path_to_accounts.keys())
    if len(structural_paths) > 0:
        lines.append("# Ledger Accounts")
        lines.extend(add_padded_lines(lines=1))
        for structural_path in structural_paths:
            account = structural_path_to_accounts[structural_path]
            class_name = format_python_class_name(
                "_".join(
                    map(lambda x: x.capitalize(), account.structural_path.split("/"))
                )
            )
            lines.append(
                f"@dataclass(frozen=True, kw_only=True)",
            )
            lines.append(
                f"class {class_name}_LedgerAccount(BaseLedgerAccountFactory):",
            )
            lines.append(
                indented_line(
                    f"__STRUCTURAL_PATH__: str = '{structural_path}'", level=1
                )
            )
            lines.append(
                indented_line(
                    f"__LEDGER_ACCOUNT_SCHEMA__: SchemaLedgerAccount = {account}",
                    level=1,
                )
            )
            lines.extend(add_padded_lines(lines=1))

            parameterized_path = ""
            path_components = structural_path.split("/")
            # Parameter names
            parameter_names: Set[str] = set()
            for i in range(len(path_components)):
                if i > 0:
                    parameterized_path += "/"
                parent_path = "/".join(path_components[0 : i + 1])
                parent_account = structural_path_to_accounts[parent_path]
                parameterized_path += parent_account.key
                if parent_account.template:
                    parameter_name = f"{parent_account.key}_id"
                    if parameter_name in parameter_names:
                        raise Exception(
                            "Duplicate key names in single path. TODO: handle this"
                        )

                    lines.append(indented_line(f"{parameter_name}: str", level=1))

                    parameterized_path += f":{{self.{parameter_name}}}"

            lines.extend(add_padded_lines(lines=1))

            lines.append(indented_line("@property", level=1))

            lines.append(indented_line("def path(self) -> str:", level=1))

            lines.append(indented_line(f'return f"{parameterized_path}"', level=2))

            lines.extend(add_padded_lines(lines=1))

    return "\n".join(lines)
