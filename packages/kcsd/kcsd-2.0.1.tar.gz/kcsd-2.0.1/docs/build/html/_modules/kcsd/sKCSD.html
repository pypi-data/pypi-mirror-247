
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kcsd.sKCSD &#8212; kCSD-python rc documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for kcsd.sKCSD</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Following people have contributed code and/or ideas to the current version of kCSD</span>

<span class="sd">Chaitanya Chintaluri[1] Marta Kowalska[1] Michal Czerwinski[1] Joanna Jędrzejewska – Szmek[1] Władysław Średniawa[1]</span>

<span class="sd">Jan Mąka [1, 3*] Grzegorz Parka[2] Daniel K. Wojcik[1]</span>

<span class="sd">[1] Laboratory of Neuroinformatics, Nencki Institute of Experimental Biology, Warsaw, Poland [2] Google Summer of Code 2014, INCF/pykCSD [3] University of Warsaw, Poland</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">sKCSD_utils</span> <span class="k">as</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">basis_functions</span> <span class="k">as</span> <span class="n">basis</span>
<span class="kn">from</span> <span class="nn">.KCSD</span> <span class="kn">import</span> <span class="n">KCSD1D</span>

<span class="k">class</span> <span class="nc">sKCSDcell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sKCSDcell -- construction of the morphology loop for sKCSD method</span>
<span class="sd">    (Cserpan et al., 2017).</span>

<span class="sd">    This calculates the morphology loop and helps transform</span>
<span class="sd">    CSDestimates/potential estimates from loop/segment space to 3D.</span>
<span class="sd">    The method implented here is based on the original paper</span>
<span class="sd">    by Dorottya Cserpan et al., 2017.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">morphology</span><span class="p">,</span> <span class="n">ele_pos</span><span class="p">,</span> <span class="n">n_src</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize sKCSDcell class</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        morphology : np.array</span>
<span class="sd">            morphology array (swc format)</span>
<span class="sd">        ele_pos : np.array</span>
<span class="sd">            electrode positions</span>
<span class="sd">        n_src : int</span>
<span class="sd">            number of sources</span>
<span class="sd">        tolerance : float</span>
<span class="sd">            minimum size of dendrite used to calculate 3 D grid parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span> <span class="o">=</span> <span class="n">morphology</span>  <span class="c1"># morphology file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span> <span class="o">=</span> <span class="n">ele_pos</span>  <span class="c1"># electrode_positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_src</span> <span class="o">=</span> <span class="n">n_src</span>  <span class="c1"># number of sources</span>
        <span class="k">assert</span> <span class="n">n_src</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># maximum distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># segment dictionary with loops as keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment_counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># which segment we&#39;re on</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branching</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">rep</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">rep</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">morphology_loop</span><span class="p">()</span>  <span class="c1"># make the morphology loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_src</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># positions of sources on the morphology (1D),</span>
        <span class="c1"># necessary for source division</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span><span class="o">/</span><span class="n">n_src</span><span class="p">,</span> <span class="n">n_src</span><span class="p">)</span>
        <span class="c1"># Cartesian coordinates of the sources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_src</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="mf">2e-6</span><span class="p">)</span>  <span class="c1"># smallest dendrite used for visualisation</span>
        <span class="c1"># max and min points of the neuron&#39;s morphology, unless given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xmin&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xmax&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ymin&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ymax&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;zmin&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;zmax&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dxs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid keyword arguments:&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribute_srcs_3D_morph</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mp1</span><span class="p">,</span> <span class="n">mp2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add indices of morphology points defining a segment</span>
<span class="sd">        to a dictionary of segments.</span>

<span class="sd">        This dictionary is used for CSD/potential trasformation from</span>
<span class="sd">        loops to segments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mp1: int</span>
<span class="sd">        mp2: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key1</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mp1</span><span class="p">,</span> <span class="n">mp2</span><span class="p">)</span>
        <span class="n">key2</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mp2</span><span class="p">,</span> <span class="n">mp1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segment_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">add_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mp1</span><span class="p">,</span> <span class="n">mp2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add indices of morphology points defining a loop to list of loops.</span>
<span class="sd">        Increase maximum distance counter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mp1: int</span>
<span class="sd">        mp2: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">mp1</span><span class="p">,</span> <span class="n">mp2</span><span class="p">)</span>
        <span class="n">xyz1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">mp1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">xyz2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">mp2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mp2</span><span class="p">,</span> <span class="n">mp1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xyz1</span> <span class="o">-</span> <span class="n">xyz2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">morphology_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cover the morphology of the cell with loops.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop over morphology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">morph_pnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">morph_pnt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">morph_pnt</span><span class="p">,</span>
                                                                  <span class="mi">6</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_loop</span><span class="p">(</span><span class="n">morph_pnt</span><span class="p">,</span> <span class="n">morph_pnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">morph_pnt</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">branching</span><span class="p">:</span>
                <span class="n">last_branch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">morph_pnt</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">last_point</span> <span class="o">=</span> <span class="n">morph_pnt</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">last_point</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_loop</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">last_point</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">last_branch</span><span class="p">:</span>
                         <span class="k">break</span>
                    <span class="n">last_point</span> <span class="o">=</span> <span class="n">parent</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_loop</span><span class="p">(</span><span class="n">morph_pnt</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">morph_pnt</span><span class="p">,</span>
                                                             <span class="mi">6</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">last_point</span> <span class="o">=</span> <span class="n">morph_pnt</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">last_point</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_loop</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">last_point</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">parent</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">last_point</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="c1"># find estimation points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">calculate_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">loop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">est_pos</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">length</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">loop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">distribute_srcs_3D_morph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate 3D coordinates of sources placed on the morphology loop.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span>
    
    <span class="k">def</span> <span class="nf">get_src_ele_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">electrode_no</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate mesh with coordinates of sources and electrodes number</span>
<span class="sd">        for exact b_pot calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        electrode_no : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list, where list[0]: 1D source coordinates on the morphology loop,</span>
<span class="sd">        list[1]: electrode number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span><span class="p">,</span>
                           <span class="n">electrode_no</span><span class="p">,</span>
                           <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_src_ele_dists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate mesh with coordinates of sources and coordinates of electrodes</span>
<span class="sd">        for exact b_pot calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list, where list[0]: 1D source coordinates on the morphology loop,</span>
<span class="sd">        list[1]: 3D electrode coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">electrode_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">src_ele_help</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_src_ele_mesh</span><span class="p">(</span><span class="n">electrode_no</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span><span class="p">[</span><span class="n">src_ele_help</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">src_ele_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">src_ele_help</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">src_ele_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">src_ele_dists</span>
        
    <span class="k">def</span> <span class="nf">get_src_estm_dists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Euclidean distance between source position on the morphology</span>
<span class="sd">        loop and positions of estimation points on the morphology loop </span>
<span class="sd">        (segment ends).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array with distances of the shape (n_src, len(morphology))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">loop_pos</span><span class="p">,</span>
                              <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_src_estm_dists_pot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_pos</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">loop_pos</span><span class="p">,</span>
                           <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find cartesian coordinates of a point (v) on the morphology loop.</span>
<span class="sd">        Use morphology point cartesian coordinates (from the morphology file,</span>
<span class="sd">        self.est_xyz) for interpolation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of length 3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="p">,</span>
                                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">calculate_total_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates doubled total legth of the cell.</span>

<span class="sd">        Parameteres</span>
<span class="sd">        -----------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">xyz1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">xyz2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">total_dist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xyz2</span> <span class="o">-</span> <span class="n">xyz1</span><span class="p">)</span>
        <span class="n">total_dist</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">total_dist</span>

    <span class="k">def</span> <span class="nf">corrected_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function calculating x position if x is outside the bounds </span>
<span class="sd">        of the morphology loop</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xp : float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">xp</span> <span class="o">+</span> <span class="p">(</span><span class="n">xp</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span> <span class="o">-</span> <span class="p">(</span><span class="n">xp</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">max_dist</span>
    
    <span class="k">def</span> <span class="nf">points_in_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">last</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper for the Bresenheim algorythm, which accepts only 2D vector</span>
<span class="sd">        coordinates. The last point -- p0 is included in output</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p1, p0: sequence of length 3</span>
<span class="sd">        last : int</span>

<span class="sd">        Return</span>
<span class="sd">        -----</span>
<span class="sd">        np.array</span>
<span class="sd">        points between p0 and p1 including (last=True) or not including p0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># bresenhamline only works with 2D vectors with coordinates</span>
        <span class="k">if</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">p0</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p1</span><span class="p">)]</span>
        <span class="n">new_p1</span><span class="p">,</span> <span class="n">new_p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                                                                   <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">new_p1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">new_p0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">intermediate_points</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">bresenhamline</span><span class="p">(</span><span class="n">new_p0</span><span class="p">,</span> <span class="n">new_p1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">last</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">new_p0</span><span class="p">,</span> <span class="n">intermediate_points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">intermediate_points</span>

    <span class="k">def</span> <span class="nf">get_dxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate parameters of the 3D grid used to transform CSD</span>
<span class="sd">        (or potential) according to eq. (22). self.tolerance is used</span>
<span class="sd">        to specify smalles possible size of neurite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dxs: np.array of 3 floats</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">differences</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;tolerance = </span><span class="si">%f</span><span class="s1">, which is the minimum pixel width for 3D visiualizations, is too low. Exiting&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate size of the 3D grid used to transform CSD</span>
<span class="sd">        (or potential) according to eq. (22). self.tolerance is used</span>
<span class="sd">        to specify smalles possible size of neurite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dims: np.array of 3 ints</span>
<span class="sd">        CSD/potential array 3D coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dxs</span><span class="p">):</span>
            <span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">dx</span><span class="p">:</span>
                <span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dims</span>

    <span class="k">def</span> <span class="nf">point_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">morpho</span><span class="p">,</span> <span class="n">dxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate indices of points in morpho in the 3D grid calculated</span>
<span class="sd">        using self.get_grid()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        morpho : np.array</span>
<span class="sd">           array with a morphology (either segements or morphology loop)</span>
<span class="sd">        dxs : sequence of length 3</span>
<span class="sd">           size of the voxel</span>
<span class="sd">           </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coor_3D : np.array</span>
<span class="sd">        zero_coords : np.array</span>
<span class="sd">           indices of morpho&#39;s initial point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">minis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">])</span>
        <span class="n">zero_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">coor_3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">morpho</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">morpho</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dxs</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dxs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dx</span><span class="p">:</span>
                <span class="n">coor_3D</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">morpho</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span>
                <span class="n">zero_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">morpho</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coor_3D</span><span class="p">,</span> <span class="n">zero_coords</span>

    <span class="k">def</span> <span class="nf">coordinates_3D_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dxs1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points of each loop in 3D grid</span>
<span class="sd">        (for CSD/potential calculation in 3D).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dxs : sequence of length 3</span>
<span class="sd">           size of the voxel</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        segment_coordinates : np.array</span>
<span class="sd">           Indices of points of 3D grid for each loop</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coor_3D</span><span class="p">,</span> <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_xyz</span><span class="p">,</span> <span class="n">dxs</span><span class="o">=</span><span class="n">dxs1</span><span class="p">)</span>
        <span class="n">segment_coordinates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coor_3D</span><span class="p">):</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor_3D</span><span class="p">))</span>
            <span class="n">segment_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_in_between</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>
            
        <span class="k">return</span> <span class="n">segment_coordinates</span>

    <span class="k">def</span> <span class="nf">coordinates_3D_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dxs1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points of each segment in 3D grid</span>
<span class="sd">        (for CSD/potential calculation in 3D).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        segment_coordinates : np.array</span>
<span class="sd">           Indices of points of 3D grid for each segment</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coor_3D</span><span class="p">,</span> <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="n">dxs</span><span class="o">=</span><span class="n">dxs1</span><span class="p">)</span>
        <span class="n">segment_coordinates</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">parentage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">6</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">coor_3D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor_3D</span><span class="p">))</span>
            <span class="n">segment_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_in_between</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor_3D</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">p0_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parentage</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">coor_3D</span><span class="p">[</span><span class="n">p0_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">coor_3D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">segment_coordinates</span>

    <span class="k">def</span> <span class="nf">transform_to_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_estimate</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;loop&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform potential/csd/ground truth values in segment or loop space</span>
<span class="sd">        to 3D.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_estimate : np.array</span>
<span class="sd">        what : string</span>
<span class="sd">           &quot;loop&quot; -- estimated is in loop space</span>
<span class="sd">           &quot;morpho&quot; -- estimated in in segment space</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;loop&quot;</span><span class="p">:</span>
            <span class="n">coor_3D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_3D_loops</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;morpho&quot;</span><span class="p">:</span>
            <span class="n">coor_3D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_3D_segments</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Unknown type of neuron morphology </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">what</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor_3D</span><span class="p">)</span> <span class="o">==</span> <span class="n">to_estimate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">estimated</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">check_estimated_shape</span><span class="p">(</span><span class="n">to_estimate</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">estimated</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">n_time</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_dims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coor_3D</span><span class="p">:</span>
            <span class="n">coor</span> <span class="o">=</span> <span class="n">coor_3D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">coor</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">estimated</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">transform_to_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimated</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform potential/csd/ground truth values in loop space</span>
<span class="sd">        to segment space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        estimated : np.array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimated</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loops</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loop</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">seg_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">result</span><span class="p">[</span><span class="n">seg_no</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">estimated</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span>

    
    <span class="k">def</span> <span class="nf">draw_cell2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cell morphology in 3D grid in projection of axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int</span>
<span class="sd">          0: x axis, 1: y axis, 2: z axis</span>
<span class="sd">        resolution : sequence of length 3</span>
<span class="sd">          size of the 2D image depicting the morphology</span>
<span class="sd">          default None, in such case default neuron resolution, </span>
<span class="sd">          which is based on the smallest neurite in the morphology,</span>
<span class="sd">          is used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dxs</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">dxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">],</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">],</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">]</span>
            <span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dxs</span><span class="p">):</span>
                <span class="n">dxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">resolution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">segments</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">coor_3D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_3D_segments</span><span class="p">(</span><span class="n">dxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coor_3D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_3D_loops</span><span class="p">(</span><span class="n">dxs</span><span class="p">)</span>

        <span class="n">image_3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coor</span> <span class="ow">in</span> <span class="n">coor_3D</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">coor_3D</span><span class="p">[</span><span class="n">coor</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">point</span>
                <span class="n">image_3D</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image_3D</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;In drawing 2D morphology unknown axis </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">*</span><span class="mi">255</span>
        <span class="n">rgb_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rgb_image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rgb_image</span><span class="p">,</span> <span class="n">extent</span>


<div class="viewcode-block" id="sKCSD"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD">[docs]</a><span class="k">class</span> <span class="nc">sKCSD</span><span class="p">(</span><span class="n">KCSD1D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;sKCSD - Kernel Current Source Density method</span>
<span class="sd">    on a neuron morphology.</span>

<span class="sd">    This estimates the Current Source Density,</span>
<span class="sd">    using the skCSD method Cserpan et.al (2017).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="sKCSD.__init__"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ele_pos</span><span class="p">,</span> <span class="n">pots</span><span class="p">,</span> <span class="n">morphology</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize sKCSD Class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ele_pos : numpy array</span>
<span class="sd">            positions of electrodes</span>
<span class="sd">        pots : numpy array</span>
<span class="sd">            potentials measured by electrodes</span>
<span class="sd">        morphology: numpy array</span>
<span class="sd">            morphology of the cell</span>
<span class="sd">        **kwargs</span>
<span class="sd">            configuration parameters, that may contain the following keys:</span>
<span class="sd">            src_type : str</span>
<span class="sd">                basis function type (&#39;gauss&#39;, &#39;step&#39;, &#39;gauss_lim&#39;)</span>
<span class="sd">                Defaults to &#39;gauss&#39;</span>
<span class="sd">            sigma : float</span>
<span class="sd">                space conductance of the medium</span>
<span class="sd">                Defaults to 1.</span>
<span class="sd">            h : float</span>
<span class="sd">                tissue thickness, unused in sKCSD</span>
<span class="sd">                Defaults to 10 um</span>
<span class="sd">            n_src_init : int</span>
<span class="sd">                requested number of sources</span>
<span class="sd">                Defaults to 1000</span>
<span class="sd">            R_init : float</span>
<span class="sd">                demanded thickness of the basis element</span>
<span class="sd">                Defaults to 23 um</span>
<span class="sd">            lambd : float</span>
<span class="sd">                regularization parameter for ridge regression</span>
<span class="sd">                Defaults to 0.</span>
<span class="sd">            dist_table_density : int</span>
<span class="sd">                size of the potential interpolation table</span>
<span class="sd">                Defaults to 20</span>
<span class="sd">            tolerance : float</span>
<span class="sd">                minimum neurite size used for 3D tranformation of CSD</span>
<span class="sd">                and potential</span>
<span class="sd">                Defaults to 2 um</span>
<span class="sd">            exact : bool</span>
<span class="sd">                switch for exact computation of b_pot instead of </span>
<span class="sd">                interpolating results </span>
<span class="sd">                (a faster solution for lower number of electrodes and less</span>
<span class="sd">                 complicated morphology)</span>
<span class="sd">                Defaults to False</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        LinAlgError</span>
<span class="sd">            Could not invert the matrix,</span>
<span class="sd">            try changing the ele_pos slightly</span>
<span class="sd">        KeyError</span>
<span class="sd">            Basis function (src_type) not implemented.</span>
<span class="sd">            See basis_functions.py for available</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span> <span class="o">=</span> <span class="n">morphology</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">sKCSD</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ele_pos</span><span class="p">,</span> <span class="n">pots</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="sKCSD.parameters"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.parameters">[docs]</a>    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;src_type&#39;</span><span class="p">,</span> <span class="s1">&#39;gauss&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_src_init</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_src_init&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambd</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;lambd&#39;</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R_init</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;R_init&#39;</span><span class="p">,</span> <span class="mf">2.3e-5</span><span class="p">)</span>  <span class="c1"># microns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_table_density</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist_table_density&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="s1">&#39;skCSD&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="mf">2e-06</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exact&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_xyz_auto</span> <span class="o">=</span>  <span class="kc">False</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid keyword arguments:&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="sKCSD.estimate_at"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.estimate_at">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_at</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defines locations where the estimation is wanted</span>
<span class="sd">        This is done while construction of morphology loop in sKCSDcell</span>
<span class="sd">        Defines:</span>
<span class="sd">        self.n_estm = len(self.cell.estm_x)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">sKCSDcell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">n_src_init</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_estm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">loop_pos</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="sKCSD.place_basis"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.place_basis">[docs]</a>    <span class="k">def</span> <span class="nf">place_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Places basis sources of the defined type.</span>
<span class="sd">        Checks if a given source_type is defined, if so then defines it</span>
<span class="sd">        self.basis, This function gives locations of the basis sources,</span>
<span class="sd">        Defines</span>
<span class="sd">        source_type : basis_fuctions.basis_2D.keys()</span>
<span class="sd">        self.R based on R_init</span>
<span class="sd">        self.src_x: Locations at which basis sources are placed.</span>
<span class="sd">        self.n_src: amount of placed basis sources</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_init</span>
        <span class="n">source_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">basis_1D</span><span class="p">[</span><span class="n">source_type</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid source_type for basis! available are:&#39;</span><span class="p">,</span>
                  <span class="n">basis</span><span class="o">.</span><span class="n">basis_1D</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">source_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">n_src</span></div>

    <span class="k">def</span> <span class="nf">get_src_ele_dists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_ele_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">get_src_ele_dists</span><span class="p">()</span>
        
<div class="viewcode-block" id="sKCSD.create_src_dist_tables"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.create_src_dist_tables">[docs]</a>    <span class="k">def</span> <span class="nf">create_src_dist_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates distance tables between sources, electrode and estm points</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">src_estm_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">get_src_estm_dists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_estm_dists_pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">get_src_estm_dists_pot</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_src_ele_dists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span></div>
    
<div class="viewcode-block" id="sKCSD.forward_model_1D"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.forward_model_1D">[docs]</a>    <span class="k">def</span> <span class="nf">forward_model_1D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">src_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;FWD model functions</span>

<span class="sd">        Evaluates potential at point (x,0) by a basis source located at (0,0)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">        R : float</span>
<span class="sd">        sigma : float</span>
<span class="sd">        src_type : basis_3D.key</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pot : float</span>
<span class="sd">            value of potential at specified distance from the source</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pot</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">int_pot_1D</span><span class="p">,</span>
                                  <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">max_dist</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">src_type</span><span class="p">))</span>
           
        <span class="k">return</span> <span class="n">pot</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="sKCSD.forward_model_3D"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.forward_model_3D">[docs]</a>    <span class="k">def</span> <span class="nf">forward_model_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span>  <span class="n">sigma</span><span class="p">,</span> <span class="n">src_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;FWD model functions</span>

<span class="sd">        Evaluates potential at point (x,0) by a basis source located at (0,0)</span>
<span class="sd"> </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">        R : float</span>
<span class="sd">        sigma : float</span>
<span class="sd">        src_type : basis_3D.key</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pot : float</span>
<span class="sd">            value of potential at specified distance from the source</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pot</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">int_pot_3D</span><span class="p">,</span>
                                  <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">max_dist</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">,</span>
                                        <span class="n">src_type</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">pot</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="sKCSD.create_lookup"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.create_lookup">[docs]</a>    <span class="k">def</span> <span class="nf">create_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create two lookup tables for easy potential and CSD estimation.</span>
<span class="sd">        Because maximum source-electrode distance can be two orders</span>
<span class="sd">        of maginutude lower than maximum source-estimation table (</span>
<span class="sd">        source-estimation table lives on the morphology loop</span>
<span class="sd">        and distance between the furthest source and segment (estimation point)</span>
<span class="sd">        can be of an order of mm), we create two separate look-up tables</span>
<span class="sd">        one for b_pot and one for b_interp_pot.</span>

<span class="sd">        In case of exact calculations (self.exact=True) the interpolation table </span>
<span class="sd">        for b_interp_pot is not created.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">max_dist</span>
        
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_max</span><span class="o">+</span><span class="mf">1.</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">dist_table_density</span><span class="p">)</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">-</span> <span class="mf">1.</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">dist_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
               <span class="n">dist_table</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_model_1D</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                                                        <span class="n">positions</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_pot_at</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span>
                                                                  <span class="n">xs</span><span class="p">,</span>
                                                                  <span class="n">dist_table</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact</span><span class="p">:</span>
            <span class="n">interpolate_at_electrode</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ele_pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span><span class="p">:</span>
                <span class="n">dist_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
                    <span class="n">dist_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_model_3D</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span>
                                                          <span class="n">ele_pos</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                <span class="n">interpolate_at_electrode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">dist_table</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_at_electrode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interpolate_at_electrode</span><span class="p">)</span></div>
                
<div class="viewcode-block" id="sKCSD.update_R"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.update_R">[docs]</a>    <span class="k">def</span> <span class="nf">update_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the width of the basis fuction - Used in Cross validation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">R</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">()</span></div>

<div class="viewcode-block" id="sKCSD.update_b_pot"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.update_b_pot">[docs]</a>    <span class="k">def</span> <span class="nf">update_b_pot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates the b_pot  - array is (#_basis_sources, #_electrodes)</span>
<span class="sd">        Updates the  k_pot - array is (#_electrodes, #_electrodes) K(x,x&#39;)</span>
<span class="sd">        Eq9,Jan2012</span>
<span class="sd">        Calculates b_pot - matrix containing the values of all</span>
<span class="sd">        the potential basis functions in all the electrode positions</span>
<span class="sd">        (essential for calculating the cross_matrix).</span>

<span class="sd">        If self.exact is False, an interpolation table created </span>
<span class="sd">        by self.create_lookup() is used, otherwise the potential</span>
<span class="sd">        is calculated for every source and electrode position.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_src</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_pos</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_at_electrode</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">src_x</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_ele_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_model_3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_ele_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">src_ele_dists</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_pot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span><span class="p">)</span>  <span class="c1"># K(x,x&#39;) Eq9,Jan2012</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_pot</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_src</span></div>
        

<div class="viewcode-block" id="sKCSD.update_b_interp_pot"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.update_b_interp_pot">[docs]</a>    <span class="k">def</span> <span class="nf">update_b_interp_pot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the matrix of potentials generated by every source</span>
<span class="sd">        basis function at every position in the interpolated space.</span>
<span class="sd">        Updates b_interp_pot</span>
<span class="sd">        Updates k_interp_pot</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_estm_dists_pot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_estm_dists_pot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">est_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_estm_dists_pot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">b_interp_pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_pot_at</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">est_points</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_interp_pot</span> <span class="o">=</span> <span class="n">b_interp_pot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_interp_pot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_interp_pot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_pot</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_interp_pot</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_src</span></div>


<div class="viewcode-block" id="sKCSD.potential_at_the_electrodes"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.potential_at_the_electrodes">[docs]</a>    <span class="k">def</span> <span class="nf">potential_at_the_electrodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruction from CSD of potentials measured at the electrodes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimation : np.array</span>
<span class="sd">            Potential generated by the CSD measured at the electrodes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">estimation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ele</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_time</span><span class="p">))</span>
        <span class="n">k_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_pot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambd</span> <span class="o">*</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_pot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_time</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k_inv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pots</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ele</span><span class="p">):</span>
                <span class="n">estimation</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_pot</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># C*(x) Eq 18</span>
        <span class="k">return</span> <span class="n">estimation</span></div>

<div class="viewcode-block" id="sKCSD.values"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimate</span><span class="o">=</span><span class="s1">&#39;CSD&#39;</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="s1">&#39;3D&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Computes the values of the quantity of interest</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        estimate: &#39;CSD&#39; or &#39;POT&#39;</span>
<span class="sd">            What quantity is to be estimated</span>
<span class="sd">            Defaults to &#39;CSD&#39;</span>
<span class="sd">        transformation: &#39;3D&#39;, &#39;segments&#39;, None</span>
<span class="sd">            Specify representation of the estimated quantity</span>
<span class="sd">            &#39;3D&#39; -- quantity is represented in cartesian coordinate system</span>
<span class="sd">            &#39;segments&#39; -- quantity is represented insegments</span>
<span class="sd">            None -- quantity is represented in the morphology loop</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimation : np.array</span>
<span class="sd">            estimated quantity</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">estimated</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">sKCSD</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">estimate</span><span class="o">=</span><span class="n">estimate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">estimated</span>
        <span class="k">if</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">transform_to_segments</span><span class="p">(</span><span class="n">estimated</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s1">&#39;3D&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">transform_to_3D</span><span class="p">(</span><span class="n">estimated</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;loop&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown transformation </span><span class="si">%s</span><span class="s2"> of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="n">estimate</span><span class="p">))</span></div>

<div class="viewcode-block" id="sKCSD.int_pot_3D"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.int_pot_3D">[docs]</a>    <span class="k">def</span> <span class="nf">int_pot_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">basis_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;FWD model function.</span>
<span class="sd">        Returns contribution of a point xp, belonging to a basis source</span>
<span class="sd">        support centered at src to the potential measured at (x,y,z),</span>
<span class="sd">        integrated over xp gives the potential generated by a</span>
<span class="sd">        basis source element centered at (src) at point (x, y, z)</span>
<span class="sd">        Eq 26 kCSD by Jan,2012</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xp : floats or np.arrays</span>
<span class="sd">            point or set of points where function should be calculated</span>
<span class="sd">        x, y, z :  float</span>
<span class="sd">            position at which potential is being measured</span>
<span class="sd">        R : float</span>
<span class="sd">            The size of the basis function</span>
<span class="sd">        basis_func : method</span>
<span class="sd">            Fuction of the basis source</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pot : float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp_coor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">corrected_x</span><span class="p">(</span><span class="n">xp</span><span class="p">))</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">calculate_distance</span><span class="p">(</span><span class="n">xp_coor</span><span class="p">,</span> <span class="n">new_x</span><span class="p">)</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="n">basis_func</span><span class="p">(</span><span class="n">xp</span><span class="o">-</span><span class="n">src</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">/</span><span class="n">dist</span>
        <span class="k">return</span> <span class="n">pot</span></div>

    
<div class="viewcode-block" id="sKCSD.int_pot_1D"><a class="viewcode-back" href="../../DOCUMENTATION.html#kcsd.sKCSD.int_pot_1D">[docs]</a>    <span class="k">def</span> <span class="nf">int_pot_1D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">basis_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;FWD model function.</span>
<span class="sd">        Returns contribution of a point xp belonging to a basis source</span>
<span class="sd">        support centered at src to the potential measured at x,</span>
<span class="sd">        integrated over xp gives the potential generated by a</span>
<span class="sd">        basis source element centered at (src) at point (x)</span>
<span class="sd">        Eq 26 kCSD by Jan,2012</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xp : floats or np.arrays</span>
<span class="sd">            point or set of points where function should be calculated</span>
<span class="sd">        x :  float</span>
<span class="sd">            position at which potential is being measured</span>
<span class="sd">        R : float</span>
<span class="sd">            The size of the basis function</span>
<span class="sd">        basis_func : method</span>
<span class="sd">            Fuction of the basis source</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pot : float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp_coor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">corrected_x</span><span class="p">(</span><span class="n">xp</span><span class="p">))</span>
        <span class="n">x_coor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">corrected_x</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">calculate_distance</span><span class="p">(</span><span class="n">xp_coor</span><span class="p">,</span> <span class="n">x_coor</span><span class="p">)</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="n">basis_func</span><span class="p">(</span><span class="n">xp</span><span class="o">-</span><span class="n">src</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">/</span><span class="n">dist</span>
        <span class="k">return</span> <span class="n">pot</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">kCSD-python</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DOCUMENTATION.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../TUTORIALS.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSE.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../AUTHORS.html#contributions">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../AUTHORS.html#contact">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../AUTHORS.html#contribute">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITE.html">Citation policy</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019-2023, Chintaluri et al.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>