import flags
import numpy
import pydrake.multibody.plant
import pydrake.symbolic
import pydrake.systems.analysis
import pydrake.systems.framework
import pydrake.systems.primitives
import pydrake.trajectories
from _typeshed import Incomplete
from typing import Any, ClassVar, overload

class DynamicProgrammingOptions:
    class PeriodicBoundaryCondition:
        high: float
        low: float
        state_index: int
        def __init__(self, state_index: int, low: float, high: float) -> None: ...
    assume_non_continuous_states_are_fixed: Any
    convergence_tol: Incomplete
    discount_factor: Incomplete
    input_port_index: Incomplete
    periodic_boundary_conditions: List[DynamicProgrammingOptions.PeriodicBoundaryCondition]
    visualization_callback: Incomplete
    def __init__(self) -> None: ...

class FiniteHorizonLinearQuadraticRegulatorOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    N: Incomplete
    Qf: Incomplete
    input_port_index: Incomplete
    simulator_config: Incomplete
    u0: Incomplete
    ud: Incomplete
    use_square_root_method: Incomplete
    x0: Incomplete
    xd: pydrake.trajectories.Trajectory
    def __init__(self) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...

class FiniteHorizonLinearQuadraticRegulatorResult:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def K(self) -> Note: ...
    @property
    def S(self) -> pydrake.trajectories.Trajectory: ...
    @property
    def k0(self) -> pydrake.trajectories.Trajectory: ...
    @property
    def s0(self) -> pydrake.trajectories.Trajectory: ...
    @property
    def sx(self) -> pydrake.trajectories.Trajectory: ...
    @property
    def u0(self) -> pydrake.trajectories.Trajectory: ...
    @property
    def x0(self) -> pydrake.trajectories.Trajectory: ...

class InverseDynamics(pydrake.systems.framework.LeafSystem):
    class InverseDynamicsMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kGravityCompensation: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
        kInverseDynamics: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kGravityCompensation: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
    kInverseDynamics: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, mode: InverseDynamics.InverseDynamicsMode = ...) -> None: ...
    def get_input_port_desired_acceleration(self) -> pydrake.systems.framework.InputPort: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_output_port_force(self) -> pydrake.systems.framework.OutputPort: ...
    def get_output_port_generalized_force(self) -> pydrake.systems.framework.OutputPort: ...
    def is_pure_gravity_compensation(self) -> bool: ...

class InverseDynamicsController(pydrake.systems.framework.Diagram):
    def __init__(self, robot: pydrake.multibody.plant.MultibodyPlant, kp: numpy.ndarray[numpy.float64[m, 1]], ki: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]], has_reference_acceleration: bool) -> None: ...
    def get_input_port_desired_acceleration(self) -> pydrake.systems.framework.InputPort: ...
    def get_input_port_desired_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_multibody_plant_for_control(self) -> pydrake.multibody.plant.MultibodyPlant: ...
    def get_output_port_control(self) -> pydrake.systems.framework.OutputPort: ...
    def set_integral_value(self, arg0: pydrake.systems.framework.Context, arg1: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...

class JointStiffnessController(pydrake.systems.framework.LeafSystem):
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, kp: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def get_input_port_desired_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_multibody_plant(self) -> pydrake.multibody.plant.MultibodyPlant: ...
    def get_output_port_generalized_force(self) -> pydrake.systems.framework.OutputPort: ...

class PeriodicBoundaryCondition:
    high: float
    low: float
    state_index: int
    def __init__(self, state_index: int, low: float, high: float) -> None: ...

class PidControlledSystem(pydrake.systems.framework.Diagram):
    @overload
    def __init__(self, plant: pydrake.systems.framework.System, kp: float, ki: float, kd: float, state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.systems.framework.System, kp: numpy.ndarray[numpy.float64[m, 1]], ki: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]], state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.systems.framework.System, feedback_selector: numpy.ndarray[numpy.float64[m, n]], kp: float, ki: float, kd: float, state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.systems.framework.System, feedback_selector: numpy.ndarray[numpy.float64[m, n]], kp: numpy.ndarray[numpy.float64[m, 1]], ki: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]], state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    def get_control_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_state_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort: ...

class PidController(pydrake.systems.framework.LeafSystem):
    @overload
    def __init__(self, kp: numpy.ndarray[numpy.float64[m, 1]], ki: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, state_projection: numpy.ndarray[numpy.float64[m, n]], kp: numpy.ndarray[numpy.float64[m, 1]], ki: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, state_projection: numpy.ndarray[numpy.float64[m, n]], output_projection: numpy.ndarray[numpy.float64[m, n]], kp: numpy.ndarray[numpy.float64[m, 1]], ki: numpy.ndarray[numpy.float64[m, 1]], kd: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def get_Kd_vector(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_Ki_vector(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_Kp_vector(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_input_port_desired_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort: ...
    def get_output_port_control(self) -> pydrake.systems.framework.OutputPort: ...

def DiscreteTimeLinearQuadraticRegulator(A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -> Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, n]]]: ...
def FiniteHorizonLinearQuadraticRegulator(system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, t0: float, tf: float, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], options: FiniteHorizonLinearQuadraticRegulatorOptions = ...) -> FiniteHorizonLinearQuadraticRegulatorResult: ...
def FittedValueIteration(arg0: pydrake.systems.analysis.Simulator, arg1: Callable[[pydrake.systems.framework.Context], float], arg2: List[Set[float]], arg3: List[Set[float]], arg4: float, arg5: DynamicProgrammingOptions) -> Tuple[pydrake.systems.primitives.BarycentricMeshSystem, numpy.ndarray[numpy.float64[1, n]]]: ...
def LinearProgrammingApproximateDynamicProgramming(arg0: pydrake.systems.analysis.Simulator, arg1: Callable[[pydrake.systems.framework.Context], float], arg2: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[object[m, 1]]], pydrake.symbolic.Expression], arg3: int, arg4: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg5: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg6: float, arg7: DynamicProgrammingOptions) -> numpy.ndarray[numpy.float64[m, 1]]: ...
@overload
def LinearQuadraticRegulator(A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], N: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous] = ..., F: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous] = ...) -> Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, n]]]: ...
@overload
def LinearQuadraticRegulator(system: pydrake.systems.primitives.LinearSystem, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], N: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous] = ...) -> pydrake.systems.primitives.LinearSystem: ...
@overload
def LinearQuadraticRegulator(system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], N: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous] = ..., input_port_index: int = ...) -> pydrake.systems.primitives.AffineSystem: ...
def MakeFiniteHorizonLinearQuadraticRegulator(system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, t0: float, tf: float, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], options: FiniteHorizonLinearQuadraticRegulatorOptions = ...) -> pydrake.systems.framework.System: ...
