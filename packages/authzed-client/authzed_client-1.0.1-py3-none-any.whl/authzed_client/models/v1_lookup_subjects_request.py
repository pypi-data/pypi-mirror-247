from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..models.lookup_subjects_request_wildcard_option import LookupSubjectsRequestWildcardOption
from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.v1_consistency import V1Consistency
    from ..models.v1_cursor import V1Cursor
    from ..models.v1_lookup_subjects_request_context_consists_of_named_values_that_are_injected_into_the_caveat_evaluation_context import (
        V1LookupSubjectsRequestContextConsistsOfNamedValuesThatAreInjectedIntoTheCaveatEvaluationContext,
    )
    from ..models.v1_object_reference import V1ObjectReference


T = TypeVar("T", bound="V1LookupSubjectsRequest")


@_attrs_define
class V1LookupSubjectsRequest:
    """LookupSubjectsRequest performs a lookup of all subjects of a particular
    kind for which the subject has the specified permission or the relation in
    which the subject exists, streaming back the IDs of those subjects.

        Attributes:
            consistency (Union[Unset, V1Consistency]): Consistency will define how a request is handled by the backend.
                By defining a consistency requirement, and a token at which those
                requirements should be applied, where applicable.
            resource (Union[Unset, V1ObjectReference]): ObjectReference is used to refer to a specific object in the system.
            permission (Union[Unset, str]): permission is the name of the permission (or relation) for which to find
                the subjects.
            subject_object_type (Union[Unset, str]): subject_object_type is the type of subject object for which the IDs
                will
                be returned.
            optional_subject_relation (Union[Unset, str]): optional_subject_relation is the optional relation for the
                subject.
            context (Union[Unset,
                V1LookupSubjectsRequestContextConsistsOfNamedValuesThatAreInjectedIntoTheCaveatEvaluationContext]):
            optional_concrete_limit (Union[Unset, int]): optional_concrete_limit, if non-zero, specifies the limit on the
                number of
                *concrete* (non-wildcard) subjects to return before the stream is closed on the
                server side. With the default value of zero, the stream will continue resolving
                concrete subjects until exhausted or the stream is closed due to the client or
                a network issue.

                NOTE: Wildcard subjects ("*") have special treatment when cursors and limits are used. Because
                wildcards can apply to *any* concrete subjects, if a wildcard subject is found within the dataset,
                a wildcard subject can be returned for *all* LookupSubjects calls, regardless of the cursor or
                limit.

                For example, if wildcards are requested, a wildcard subject exists, there is a specified limit
                of 10 concrete subjects, and at least 10 concrete subjects exist, the API will return 11 subjects
                in total: the 10 concrete + the wildcard

                Furthermore, if a wildcard has a set of exclusions generated by the dataset,
                the exclusions *will respect the cursor* and only a *partial* set of exclusions will be returned
                for each invocation of the API.

                ***IT IS UP TO THE CALLER IN THIS CASE TO COMBINE THE EXCLUSIONS IF DESIRED***
            optional_cursor (Union[Unset, V1Cursor]): Cursor is used to provide resumption of listing between calls to APIs
                such as LookupResources.
            wildcard_option (Union[Unset, LookupSubjectsRequestWildcardOption]):  Default:
                LookupSubjectsRequestWildcardOption.WILDCARD_OPTION_UNSPECIFIED.
    """

    consistency: Union[Unset, "V1Consistency"] = UNSET
    resource: Union[Unset, "V1ObjectReference"] = UNSET
    permission: Union[Unset, str] = UNSET
    subject_object_type: Union[Unset, str] = UNSET
    optional_subject_relation: Union[Unset, str] = UNSET
    context: Union[
        Unset, "V1LookupSubjectsRequestContextConsistsOfNamedValuesThatAreInjectedIntoTheCaveatEvaluationContext"
    ] = UNSET
    optional_concrete_limit: Union[Unset, int] = UNSET
    optional_cursor: Union[Unset, "V1Cursor"] = UNSET
    wildcard_option: Union[
        Unset, LookupSubjectsRequestWildcardOption
    ] = LookupSubjectsRequestWildcardOption.WILDCARD_OPTION_UNSPECIFIED
    additional_properties: Dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        consistency: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.consistency, Unset):
            consistency = self.consistency.to_dict()

        resource: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.resource, Unset):
            resource = self.resource.to_dict()

        permission = self.permission
        subject_object_type = self.subject_object_type
        optional_subject_relation = self.optional_subject_relation
        context: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.context, Unset):
            context = self.context.to_dict()

        optional_concrete_limit = self.optional_concrete_limit
        optional_cursor: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.optional_cursor, Unset):
            optional_cursor = self.optional_cursor.to_dict()

        wildcard_option: Union[Unset, str] = UNSET
        if not isinstance(self.wildcard_option, Unset):
            wildcard_option = self.wildcard_option.value

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if consistency is not UNSET:
            field_dict["consistency"] = consistency
        if resource is not UNSET:
            field_dict["resource"] = resource
        if permission is not UNSET:
            field_dict["permission"] = permission
        if subject_object_type is not UNSET:
            field_dict["subjectObjectType"] = subject_object_type
        if optional_subject_relation is not UNSET:
            field_dict["optionalSubjectRelation"] = optional_subject_relation
        if context is not UNSET:
            field_dict["context"] = context
        if optional_concrete_limit is not UNSET:
            field_dict["optionalConcreteLimit"] = optional_concrete_limit
        if optional_cursor is not UNSET:
            field_dict["optionalCursor"] = optional_cursor
        if wildcard_option is not UNSET:
            field_dict["wildcardOption"] = wildcard_option

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.v1_consistency import V1Consistency
        from ..models.v1_cursor import V1Cursor
        from ..models.v1_lookup_subjects_request_context_consists_of_named_values_that_are_injected_into_the_caveat_evaluation_context import (
            V1LookupSubjectsRequestContextConsistsOfNamedValuesThatAreInjectedIntoTheCaveatEvaluationContext,
        )
        from ..models.v1_object_reference import V1ObjectReference

        d = src_dict.copy()
        _consistency = d.pop("consistency", UNSET)
        consistency: Union[Unset, V1Consistency]
        if isinstance(_consistency, Unset):
            consistency = UNSET
        else:
            consistency = V1Consistency.from_dict(_consistency)

        _resource = d.pop("resource", UNSET)
        resource: Union[Unset, V1ObjectReference]
        if isinstance(_resource, Unset):
            resource = UNSET
        else:
            resource = V1ObjectReference.from_dict(_resource)

        permission = d.pop("permission", UNSET)

        subject_object_type = d.pop("subjectObjectType", UNSET)

        optional_subject_relation = d.pop("optionalSubjectRelation", UNSET)

        _context = d.pop("context", UNSET)
        context: Union[
            Unset, V1LookupSubjectsRequestContextConsistsOfNamedValuesThatAreInjectedIntoTheCaveatEvaluationContext
        ]
        if isinstance(_context, Unset):
            context = UNSET
        else:
            context = V1LookupSubjectsRequestContextConsistsOfNamedValuesThatAreInjectedIntoTheCaveatEvaluationContext.from_dict(
                _context
            )

        optional_concrete_limit = d.pop("optionalConcreteLimit", UNSET)

        _optional_cursor = d.pop("optionalCursor", UNSET)
        optional_cursor: Union[Unset, V1Cursor]
        if isinstance(_optional_cursor, Unset):
            optional_cursor = UNSET
        else:
            optional_cursor = V1Cursor.from_dict(_optional_cursor)

        _wildcard_option = d.pop("wildcardOption", UNSET)
        wildcard_option: Union[Unset, LookupSubjectsRequestWildcardOption]
        if isinstance(_wildcard_option, Unset):
            wildcard_option = UNSET
        else:
            wildcard_option = LookupSubjectsRequestWildcardOption(_wildcard_option)

        v1_lookup_subjects_request = cls(
            consistency=consistency,
            resource=resource,
            permission=permission,
            subject_object_type=subject_object_type,
            optional_subject_relation=optional_subject_relation,
            context=context,
            optional_concrete_limit=optional_concrete_limit,
            optional_cursor=optional_cursor,
            wildcard_option=wildcard_option,
        )

        v1_lookup_subjects_request.additional_properties = d
        return v1_lookup_subjects_request

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
