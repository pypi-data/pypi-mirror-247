.format: 4

.import:
  Robotics: [Robot, RobotArm, Segment, RobotBase, Joint, HingeJoint, SignalType]
  Physics.Mechanics: [RigidBodyAttachment, HingeConnector]

MySegmentGeometry:
  .extends: Physics.Geometry.Cylinder
  radius: 0.1
  length: 0.8
  localTransform:
    position: Vec3(0,0,0.6)
    rotation: Quat.AngleAxis(90, Vec3(1,0,0))

MySegmentBody:
  .extends: Physics.Mechanics.RigidBody
  collisionGeometry: 
    .type: Physics.Geometry
    .value: MySegmentGeometry()
  mass: 2

MySegment:
  .extends: Segment
  body: MySegmentBody()
  inputAttachment:
    localTransform:
      position: Vec3(0,0,0)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))
  outputAttachment:
    localTransform:
      position: Vec3(0,0,1)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))

HingeWithInitialAngle:
  .extends: HingeConnector
  angle: 0

MyRobotArm:
  .extends: RobotArm
  wantInternalPositioning: false
  joint1:
    .type: HingeJoint
    hingeConnector: 
      .type: HingeWithInitialAngle
      mainInteraction:
        name: segment_connection
      motor:
        speed: 0
        constrainDof: true
    segment1: this.segment1
    segment2: this.segment2
    inputSignalType: SignalType.InputVelocitySignal

  segment1:
    .type: MySegment
    body:
      name: segment1

  segment2:
    .type: MySegment
    body:
      name: segment2

MyBaseGeometry:
  .extends: Physics.Geometry.Box
  lengths: Vec3(0.5,0.5,0.5)

MyBaseBody:
  .extends: Physics.Mechanics.RigidBody
  collisionGeometry: 
    .type: Physics.Geometry
    .value: MyBaseGeometry()
  mass: 2

MyBase:
  .extends: RobotBase

  body: MyBaseBody()

  attachment:
    .type: RigidBodyAttachment
    localPosition: Vec3(0.5,0,0)

  inputAttachment:
    localTransform:
      position: Vec3(0,0,0)
      rotation: Quat.TryFromToZXPair(Vec3(0,1,0),Vec3(0,0,1))
  outputAttachment:
    localTransform:
      position: Vec3(0,0,0.5)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))

# Put the two boxes together and add a lock connector to world
MyRobot:
  .extends: Robot
  wantInternalPositioning: true

  base:
    .value: MyBase

  arm1:
    .type: MyRobotArm
    .value: MyRobotArm

  joint:
    .type: HingeJoint
    hingeConnector:
      .type: HingeWithInitialAngle
      mainInteraction:
        name: base_connection

    segment1: this.base
    segment2: this.arm1.segment1
    inputSignalType: SignalType.InputPositionSignal
  
  jointAngleSensor:
    .type: Robotics.Sensor.JointSensor
    joint: this.joint
    protocolReference: /joint_angle_output
    outputSignalType: Robotics.SignalType.OutputPositionSignal

  worldAttachment:
    .type: Physics.Mechanics.LockJointAttachment
    .value: Physics.Mechanics.LockJointAttachment
    localTransform:
      rotation: Quat.TryFromToZXPair(Vec3(0,1,0),Vec3(0,0,1))

  worldConnector:
    .type: Physics.Mechanics.PrismaticConnector
    attachment1: this.base.inputAttachment
    attachment2: this.worldAttachment
    motor:
      speed: 0
      constrainDof: true

MyCupBody:
  .extends: Physics.Mechanics.RigidBody
  geometry:
    .type: Physics.Geometry.Trimesh
    enableCollisions: false
    filepath: suctioncup.obj
    scale: 0.25
    localTransform:
      position: Vec3(0,0,-0.06)
      rotation: Quat.AngleAxis(180, Vec3(1,0,0))
  cylinder:
    .type: Physics.Geometry.Cylinder
    radius: 0.05
    length: 0.01
    localTransform:
      position: Vec3(0,0,-0.005)
      rotation: Quat.AngleAxis(90,Vec3(1,0,0))
    
  attachment:
    .type: Physics.Mechanics.RigidBodyAttachment
    localTransform:
      position: Vec3(0,0,-0.06)

MyCup:
  .extends: AGXBrick.SuctionGripper.Cup
  body: 
    .value: MyCupBody
    localTransform:
      position: Vec3(0,0,0)
    cylinder:
      radius: this.lipRadius
      length: this.lipHeight
  lipRadius: 0.02
  localLineSensorVector: Vec3(0,0,0.1)
  deformingGeometryPath: this.body.geometry
  sealResolution: 10

MyHolderBody:
  .extends: Physics.Mechanics.RigidBody
  geometry:
    .type: Physics.Geometry.Cylinder
    radius: 0.075
    length: 0.01
    localTransform:
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))
  cupAttachment1:
    .type: Physics.Mechanics.RigidBodyAttachment
    localTransform:
      position: Vec3(0,0.04,0.005)
  cupAttachment2:
    .type: Physics.Mechanics.RigidBodyAttachment
    localTransform:
      position: Vec3(0,-0.04,0.005)

HolderSegment:
  .extends: Robotics.Segment
  body: MyHolderBody
  inputAttachment:
    localTransform:
      position: Vec3(0,0,-0.01)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))
  outputAttachment:
    localTransform:
      position: Vec3(0,0,1)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))

CupConnector:
  .extends: Physics.Mechanics.LockJointConnector
  mainInteraction:
    stiffness6D:
      defaultValue: 1E3
      aroundTangent: 1E1
      aroundNormal: 1E1
      aroundCross: 1E1
    damping6D:
      defaultValue: 1E2
      aroundTangent: 1E0
      aroundNormal: 1E0
      aroundCross: 1E0

Gripper:
  .extends: AGXBrick.SuctionGripper
  holderSegment: 
    .type: HolderSegment
    .value: HolderSegment
  holder: this.holderSegment.body
  cup1:
    .type: MyCup
    connector:
      .value: CupConnector
      attachment1: this.holder.cupAttachment1
      attachment2: this.cup1.body.attachment
  cup2:
    .type: MyCup
    connector:
      .value: CupConnector
      attachment1: this.holder.cupAttachment2
      attachment2: this.cup2.body.attachment  

MyRobotWithGripper:
  .extends: MyRobot

  gripper: 
    .type: Gripper
    .value: Gripper

  gripperJoint:
    .type: Robotics.Joint
    connector: Physics.Mechanics.LockJointConnector
    # Has to be arbitrary, otherwise we try to create an actuator for a lock
    inputSignalType: Robotics.SignalType.ArbitraryInputSignal
    segment1: this.arm1.segment2
    segment2: this.gripper.holderSegment