# This example demonstrates how to add Attachments and Connectors to a model. When this have
# been added, Brick will automatically try to position and align the bodies to make the joint
# equations be satisfied at the start of the simulation.

# OBSERVE
# The MyRobot model is used in a unit test
# python/test/test_position_and_rotation_sign.py
.format: 4

# Use imports to avoid having two write the whole name of the component
.import:
  Robotics: [Robot, RobotArm, Segment, RobotBase, Joint, HingeJoint, SignalType]
  Physics.Mechanics: [RigidBodyAttachment, HingeConnector]



# The positioning algorithm must have a static point of reference to have something to position
# the components relative to. Therefore we create a second box with an attachment which will be
# connected to the world.
WorldAttachment:
  .extends: RigidBodyAttachment
  worldLock:
    .type: NoDegreeOfFreedomRelativeParent
    .value: NoDegreeOfFreedomRelativeParent

MySegmentGeometry:
  .extends: Physics.Geometry.Cylinder
  radius: 0.1
  length: 0.8
  localTransform:
    position: Vec3(0,0,0.6)
    rotation: Quat.AngleAxis(90, Vec3(1,0,0))

MySegmentBody:
  .extends: Physics.Mechanics.RigidBody
  collisionGeometry: 
    .type: Physics.Geometry
    .value: MySegmentGeometry()
  mass: 2

MySegment:
  .extends: Segment
  body: MySegmentBody()
  inputAttachment:
    localTransform:
      position: Vec3(0,0,0)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))
  outputAttachment:
    localTransform:
      position: Vec3(0,0,1)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))
  

HingeWithInitialAngle:
  .extends: HingeConnector
  angle: 0



MyRobotArm:
  .extends: RobotArm
  wantInternalPositioning: false
  joint1:
    .type: HingeJoint
    hingeConnector: 
      .type: HingeWithInitialAngle
      mainInteraction:
        name: segment_connection
      motor:
        speed: 0
        constrainDof: true
    segment1: this.segment1
    segment2: this.segment2
    inputSignalType: SignalType.InputVelocitySignal

  segment1:
    .type: MySegment
    body:
      name: segment1


  segment2:
    .type: MySegment
    body:
      name: segment2

MyBaseGeometry:
  .extends: Physics.Geometry.Box
  lengths: Vec3(0.5,0.5,0.5)

MyBaseBody:
  .extends: Physics.Mechanics.RigidBody
  collisionGeometry: 
    .type: Physics.Geometry
    .value: MyBaseGeometry()
  mass: 2

MyBase:
  .extends: RobotBase

  body: MyBaseBody()

  attachment:
    .type: RigidBodyAttachment
    localPosition: Vec3(0.5,0,0)

  inputAttachment:
    localTransform:
      position: Vec3(0,0,0)
      rotation: Quat.TryFromToZXPair(Vec3(0,1,0),Vec3(0,0,1))
  outputAttachment:
    localTransform:
      position: Vec3(0,0,0.5)
      rotation: Quat.AngleAxis(90, Vec3(1,0,0))


# Put the two boxes together and add a lock connector to world
MyRobot:
  .extends: Robot
  wantInternalPositioning: true

  base:
    .value: MyBase

  arm1:
    .type: MyRobotArm
    .value: MyRobotArm

  joint:
    .type: HingeJoint
    hingeConnector:
      .type: HingeWithInitialAngle
      mainInteraction:
        name: base_connection

    segment1: this.base
    segment2: this.arm1.segment1
    inputSignalType: SignalType.InputPositionSignal
  
  jointAngleSensor:
    .type: Robotics.Sensor.JointSensor
    joint: this.joint
    protocolReference: /joint_angle_output
    outputSignalType: Robotics.SignalType.OutputPositionSignal

  worldAttachment:
    .type: Physics.Mechanics.LockJointAttachment
    .value: Physics.Mechanics.LockJointAttachment
    localTransform:
      rotation: Quat.TryFromToZXPair(Vec3(0,1,0),Vec3(0,0,1))

  worldConnector:
    .type: Physics.Mechanics.PrismaticConnector
    attachment1: this.base.inputAttachment
    attachment2: this.worldAttachment
    motor:
      speed: 0
      constrainDof: true

# Put the two boxes together and add a lock connector to world
MyRobotBatch:
  .extends: MyRobot

  joint:
    hingeConnector:
      lock:
        position: this.joint.initialPosition
        constrainDof: true
    initialPosition: 1000

  variableJointPosition:
    .type: Physics.ExperimentFactorialDimension
    name: variableJointPosition
    targets:
      - this.joint.initialPosition
      - this.joint.hingeConnector.lock.position
    model: this
    start: 1000
    stop: -1000
    numStep: 45
    
  parameterSpace:
    .type: Physics.ExperimentParameterSpace
    
    factorialDimensions:
      - this.variableJointPosition


MyTwoArmRobot:
  .extends: Robot

  wantInternalPositioning: true

  base:
    .value: MyBase

  arm1:
    .type: MyRobotArm
    .value: MyRobotArm

  arm2:
    .type: MyRobotArm
    .value: MyRobotArm

  joint:
    .type: HingeJoint
    hingeConnector: HingeWithInitialAngle
    segment1: this.base
    segment2: this.arm1.segment1


  joint2:
    .type: HingeJoint
    hingeConnector: HingeWithInitialAngle
    segment1: this.base
    segment2: this.arm2.segment1
    initialPosition: 50

  worldAttachment:
    .type: Physics.Mechanics.LockJointAttachment
    .value: Physics.Mechanics.LockJointAttachment

  worldConnector:
    .type: Physics.Mechanics.LockJointConnector
    attachment1: this.base.inputAttachment
    attachment2: this.worldAttachment

TwoMyRobot:
  .extends: Physics.Component
  wantInternalPositioning: true
  r1:
    .type: MyRobot
    .value: MyRobot

  r2:
    .type: MyRobot
    .value: MyRobot
    localTransform:
      position: Vec3(1,0,0)
