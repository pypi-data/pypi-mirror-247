

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_nostr_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)
class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value
 
    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("nostr_sdk_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 25
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_nostr_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_nostr_ffi_checksum_func_generate_shared_key() != 16959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_get_nip05_profile() != 40366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip04_decrypt() != 43832:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip04_encrypt() != 30892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip44_decrypt() != 45478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_nip44_encrypt() != 44460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_func_verify_nip05() != 27291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_alias() != 19227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_public_key() != 34202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_contact_relay_url() != 44747:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_as_json() != 13177:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_content() != 3434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_coordinates() != 955:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_created_at() != 30924:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_event_ids() != 3712:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_expiration() != 35230:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_id() != 63996:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_identifier() != 23430:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_ephemeral() != 21349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_expired() != 57175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_job_request() != 26053:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_job_result() != 54684:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable() != 17253:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_regular() != 8941:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_is_replaceable() != 57468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_kind() != 59997:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_pubkey() != 22045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_public_keys() != 60897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_signature() != 11666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_tags() != 52723:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify() != 11448:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify_id() != 58200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_event_verify_signature() != 63925:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event() != 50209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event() != 41869:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event() != 47176:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event() != 37944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes() != 42102:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32() != 64584:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_hex() != 61729:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri() != 46695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm() != 55682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash() != 35842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions() != 9884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet() != 41489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filemetadata_size() != 57454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_as_json() != 460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_author() != 4917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_authors() != 53178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_custom_tag() != 31744:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_event() != 59794:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_events() != 38326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_hashtag() != 50093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_hashtags() != 62694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_id() != 45833:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_identifier() != 20298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_identifiers() != 54889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_ids() != 55244:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_is_empty() != 26481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_kind() != 52242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_kinds() != 3094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_limit() != 4466:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_match_event() != 57404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_pubkey() != 31814:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_pubkeys() != 34042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_reference() != 56897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_references() != 4549:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_authors() != 33646:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag() != 48444:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_events() != 49125:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_hashtags() != 35531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_identifiers() != 49347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_ids() != 5421:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_kinds() != 61773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_limit() != 20675:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys() != 34681:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_references() != 5487:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_search() != 63633:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_since() != 1723:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_remove_until() != 9495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_search() != 14640:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_since() != 26072:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_filter_until() != 9880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_imagedimensions_height() != 33735:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_imagedimensions_width() != 1901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_public_key() != 11578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_secret_key() != 9033:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_keys_sign_schnorr() != 7507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_as_json() != 65508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_about() != 6408:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_banner() != 8981:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field() != 56748:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name() != 17403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06() != 2507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16() != 58234:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_name() != 23420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05() != 23082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_picture() != 40475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_get_website() != 33949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_about() != 3274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_banner() != 37978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field() != 10957:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name() != 42475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06() != 43495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16() != 48202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_name() != 28889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05() != 56573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_picture() != 61689:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_metadata_set_website() != 48106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_public_key() != 18567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_relays() != 40076:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32() != 6768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri() != 7355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description() != 40293:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name() != 44591:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key() != 5374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url() != 32058:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url() != 42493:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version() != 56065:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32() != 6908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_hex() != 28417:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri() != 23126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact() != 46735:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description() != 23135:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name() != 18381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey() != 58101:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software() != 10815:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips() != 15217:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version() != 8680:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32() != 37711:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex() != 26766:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost() != 1960:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_shippingmethod_name() != 4425:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_shippingmethod_regions() != 45072:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_as_enum() != 27944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_as_vec() != 44400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_tag_kind() != 45790:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs() != 12186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime() != 33432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature() != 50095:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json() != 632:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_content() != 59369:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at() != 14364:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_id() != 54089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind() != 49180:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey() != 27155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign() != 25171:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags() != 37002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount() != 46823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id() != 47057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl() != 51318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_contact_new() != 39020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_event_from_json() != 7211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay() != 51438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth() != 21486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge() != 56466:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge() != 60447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete() != 16936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata() != 58037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 6412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth() != 18302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback() != 56220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request() != 58728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result() != 28672:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event() != 55426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg() != 37436:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 61682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 6:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new() != 13099:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel() != 28447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg() != 45389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg() != 22581:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_product_data() != 33901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction() != 48872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_stall_data() != 13781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note() != 27760:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt() != 24299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_request() != 21272:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect() != 56662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges() != 32949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list() != 9523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report() != 38094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost() != 22762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata() != 31012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list() != 43227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata() != 33061:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32() != 30950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes() != 63467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex() != 28688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri() != 38461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_eventid_new() != 33385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new() != 49746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filter_from_json() != 29556:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_filter_new() != 52942:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new() != 12930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic() != 57901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str() != 31327:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key() != 25705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str() != 14146:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_generate() != 38677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_new() != 14520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_keys_vanity() != 19009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json() != 2104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_metadata_new() != 46492:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32() != 32898:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri() != 51607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nip19profile_new() != 57515:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string() != 27884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new() != 29464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32() != 691:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes() != 39862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex() != 36005:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri() != 29733:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get() != 3532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32() != 63087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes() != 49241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex() != 3323:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_shippingmethod_new() != 29131:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum() != 27753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_tag_parse() != 24378:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs() != 62064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_timestamp_now() != 25457:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json() != 62944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new() != 33304:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_nostr_ffi_fn_clone_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_contact.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_contact.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_event.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_coordinates.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_coordinates.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_event_ids.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_event_ids.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_expiration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_identifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_ephemeral.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_ephemeral.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_request.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_result.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_result.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_regular.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_regular.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_replaceable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_replaceable.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_event_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_event_public_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_public_keys.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_id.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_signature.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_product_data.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_product_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_stall_data.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_stall_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_eventid.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_eventid.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_filemetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_filter.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_filter.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtag.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifiers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifiers.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_match_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_match_event.restype = ctypes.c_int8
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_reference.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_reference.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_references.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_references.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_authors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_custom_tag.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_custom_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_hashtags.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_hashtags.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_identifiers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_identifiers.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_ids.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_kinds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_kinds.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_limit.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_pubkeys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_pubkeys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_references.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_references.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_search.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_since.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_until.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_imagedimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_imagedimensions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_clone_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_keys.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_keys.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_pk_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_pk_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_sk_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_sk_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_sign_schnorr.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_keys_sign_schnorr.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_metadata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nip19profile.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnecturi.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrlibrary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrlibrary.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrlibrary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_nostrlibrary.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrlibrary_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrlibrary_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_publickey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_relayinformationdocument.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_secretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_shippingmethod.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_shippingmethod.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_shippingmethod.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_shippingmethod.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_shippingmethod_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_double,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_shippingmethod_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_regions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_regions.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_clone_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_tag.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_timestamp.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_unsignedevent.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_clone_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_clone_zaprequestdata.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata.restype = None
_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile.restype = ctypes.c_void_p
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_decrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_encrypt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05.restype = None
_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_nostr_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_nostr_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_nostr_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_nostr_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_nostr_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_nostr_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_nostr_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_nostr_ffi_checksum_func_generate_shared_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_generate_shared_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_nip05_profile.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_get_nip05_profile.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip04_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_decrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_encrypt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_nip44_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_func_verify_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_alias.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_alias.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_contact_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_content.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_coordinates.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_coordinates.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_event_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_event_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_expiration.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_ephemeral.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_ephemeral.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_expired.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_result.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_job_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_regular.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_regular.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_replaceable.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_is_replaceable.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_public_keys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_public_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_event_verify_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_as_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_blurhash.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_dimensions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_magnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_size.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filemetadata_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_author.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_custom_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_custom_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_events.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifier.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifiers.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_identifiers.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_is_empty.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_match_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_match_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_reference.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_reference.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_references.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_references.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_authors.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_events.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_hashtags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_hashtags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_identifiers.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_identifiers.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_ids.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_kinds.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_kinds.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_limit.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_references.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_references.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_search.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_since.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_until.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_remove_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_search.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_search.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_since.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_since.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_until.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_filter_until.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_height.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_height.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_width.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_imagedimensions_width.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_secret_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_secret_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_sign_schnorr.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_keys_sign_schnorr.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_about.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_about.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_banner.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_banner.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_custom_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_display_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud06.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_picture.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_picture.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_website.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_get_website.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_about.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_about.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_banner.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_banner.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_custom_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_display_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud06.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_lud16.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_nip05.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_picture.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_picture.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_website.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_metadata_set_website.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_relays.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrconnecturi_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_software.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_relayinformationdocument_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_secretkey_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_name.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_regions.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_shippingmethod_regions.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_vec.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_as_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_tag_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_as_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_as_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_content.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_unsignedevent_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_contact_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_contact_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_event_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_event_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_product_data.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_product_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_stall_data.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_stall_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_request.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_report.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_eventid_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filemetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_filter_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_imagedimensions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_generate.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_vanity.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_keys_vanity.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_metadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nip19profile_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_shippingmethod_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_shippingmethod_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_from_enum.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_parse.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_tag_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_now.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_timestamp_now.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new.argtypes = (
)
_UniffiLib.uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new.restype = ctypes.c_uint16
_UniffiLib.ffi_nostr_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_nostr_ffi_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class ContactProtocol(typing.Protocol):
    def alias(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def relay_url(self, ):
        raise NotImplementedError

class Contact:

    _pointer: ctypes.c_void_p
    def __init__(self, pk: "PublicKey",relay_url: "typing.Optional[str]",alias: "typing.Optional[str]"):
        _UniffiConverterTypePublicKey.check_lower(pk)
        
        _UniffiConverterOptionalString.check_lower(relay_url)
        
        _UniffiConverterOptionalString.check_lower(alias)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_contact_new,
        _UniffiConverterTypePublicKey.lower(pk),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterOptionalString.lower(alias))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_contact, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_contact, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def alias(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_alias,self._uniffi_clone_pointer(),)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_public_key,self._uniffi_clone_pointer(),)
        )






    def relay_url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_contact_relay_url,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeContact:

    @staticmethod
    def lift(value: int):
        return Contact._make_instance_(value)

    @staticmethod
    def check_lower(value: Contact):
        if not isinstance(value, Contact):
            raise TypeError("Expected Contact instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ContactProtocol):
        if not isinstance(value, Contact):
            raise TypeError("Expected Contact instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ContactProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def content(self, ):
        raise NotImplementedError
    def coordinates(self, ):
        """Extract coordinates from tags (`a` tag)"""

        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def event_ids(self, ):
        """Extract event IDs from tags (`e` tag)"""

        raise NotImplementedError
    def expiration(self, ):
        """Get `Timestamp` expiration if set"""

        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def identifier(self, ):
        """Extract identifier (`d` tag), if exists."""

        raise NotImplementedError
    def is_ephemeral(self, ):
        """
        Check if event `Kind` is `Ephemeral`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_expired(self, ):
        """
        Returns `true` if the event has an expiration tag that is expired.
        If an event has no `Expiration` tag, then it will return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        raise NotImplementedError
    def is_job_request(self, ):
        """
        Check if `Kind` is a NIP90 job request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        raise NotImplementedError
    def is_job_result(self, ):
        """
        Check if `Kind` is a NIP90 job result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        raise NotImplementedError
    def is_parameterized_replaceable(self, ):
        """
        Check if event `Kind` is `Parameterized replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_regular(self, ):
        """
        Check if event `Kind` is `Regular`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def is_replaceable(self, ):
        """
        Check if event `Kind` is `Replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def pubkey(self, ):
        raise NotImplementedError
    def public_keys(self, ):
        """Extract public keys from tags (`p` tag)"""

        raise NotImplementedError
    def signature(self, ):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError
    def verify(self, ):
        """Verify both `EventId` and `Signature`"""

        raise NotImplementedError
    def verify_id(self, ):
        """Verify if the `EventId` it's composed correctly"""

        raise NotImplementedError
    def verify_signature(self, ):
        """Verify only event `Signature`"""

        raise NotImplementedError

class Event:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_event, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_event, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_event_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_as_json,self._uniffi_clone_pointer(),)
        )






    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_content,self._uniffi_clone_pointer(),)
        )






    def coordinates(self, ) -> "typing.List[Coordinate]":
        """Extract coordinates from tags (`a` tag)"""

        return _UniffiConverterSequenceTypeCoordinate.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_coordinates,self._uniffi_clone_pointer(),)
        )






    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_created_at,self._uniffi_clone_pointer(),)
        )






    def event_ids(self, ) -> "typing.List[EventId]":
        """Extract event IDs from tags (`e` tag)"""

        return _UniffiConverterSequenceTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_event_ids,self._uniffi_clone_pointer(),)
        )






    def expiration(self, ) -> "typing.Optional[Timestamp]":
        """Get `Timestamp` expiration if set"""

        return _UniffiConverterOptionalTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_expiration,self._uniffi_clone_pointer(),)
        )






    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_id,self._uniffi_clone_pointer(),)
        )






    def identifier(self, ) -> "typing.Optional[str]":
        """Extract identifier (`d` tag), if exists."""

        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_identifier,self._uniffi_clone_pointer(),)
        )






    def is_ephemeral(self, ) -> "bool":
        """
        Check if event `Kind` is `Ephemeral`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_ephemeral,self._uniffi_clone_pointer(),)
        )






    def is_expired(self, ) -> "bool":
        """
        Returns `true` if the event has an expiration tag that is expired.
        If an event has no `Expiration` tag, then it will return `false`.

        <https://github.com/nostr-protocol/nips/blob/master/40.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_expired,self._uniffi_clone_pointer(),)
        )






    def is_job_request(self, ) -> "bool":
        """
        Check if `Kind` is a NIP90 job request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_request,self._uniffi_clone_pointer(),)
        )






    def is_job_result(self, ) -> "bool":
        """
        Check if `Kind` is a NIP90 job result

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_job_result,self._uniffi_clone_pointer(),)
        )






    def is_parameterized_replaceable(self, ) -> "bool":
        """
        Check if event `Kind` is `Parameterized replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable,self._uniffi_clone_pointer(),)
        )






    def is_regular(self, ) -> "bool":
        """
        Check if event `Kind` is `Regular`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_regular,self._uniffi_clone_pointer(),)
        )






    def is_replaceable(self, ) -> "bool":
        """
        Check if event `Kind` is `Replaceable`

        <https://github.com/nostr-protocol/nips/blob/master/01.md>
        """

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_is_replaceable,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_kind,self._uniffi_clone_pointer(),)
        )






    def pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_pubkey,self._uniffi_clone_pointer(),)
        )






    def public_keys(self, ) -> "typing.List[PublicKey]":
        """Extract public keys from tags (`p` tag)"""

        return _UniffiConverterSequenceTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_public_keys,self._uniffi_clone_pointer(),)
        )






    def signature(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_signature,self._uniffi_clone_pointer(),)
        )






    def tags(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_tags,self._uniffi_clone_pointer(),)
        )






    def verify(self, ) -> "bool":
        """Verify both `EventId` and `Signature`"""

        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify,self._uniffi_clone_pointer(),)
        )






    def verify_id(self, ):
        """Verify if the `EventId` it's composed correctly"""

        _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_id,self._uniffi_clone_pointer(),)







    def verify_signature(self, ):
        """Verify only event `Signature`"""

        _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_event_verify_signature,self._uniffi_clone_pointer(),)






class _UniffiConverterTypeEvent:

    @staticmethod
    def lift(value: int):
        return Event._make_instance_(value)

    @staticmethod
    def check_lower(value: Event):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventProtocol):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventBuilderProtocol(typing.Protocol):
    def to_event(self, keys: "Keys"):
        raise NotImplementedError
    def to_pow_event(self, keys: "Keys",difficulty: "int"):
        raise NotImplementedError
    def to_unsigned_event(self, public_key: "PublicKey"):
        raise NotImplementedError
    def to_unsigned_pow_event(self, public_key: "PublicKey",difficulty: "int"):
        raise NotImplementedError

class EventBuilder:

    _pointer: ctypes.c_void_p
    def __init__(self, kind: "int",content: "str",tags: "typing.List[Tag]"):
        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new,
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_eventbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_eventbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def add_recommended_relay(cls, url: "str"):
        _UniffiConverterString.check_lower(url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay,
        _UniffiConverterString.lower(url))
        return cls._make_instance_(pointer)


    @classmethod
    def auth(cls, challenge: "str",relay_url: "str"):
        _UniffiConverterString.check_lower(challenge)
        
        _UniffiConverterString.check_lower(relay_url)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_auth,
        _UniffiConverterString.lower(challenge),
        _UniffiConverterString.lower(relay_url))
        return cls._make_instance_(pointer)


    @classmethod
    def award_badge(cls, badge_definition: "Event",awarded_pubkeys: "typing.List[Tag]"):
        _UniffiConverterTypeEvent.check_lower(badge_definition)
        
        _UniffiConverterSequenceTypeTag.check_lower(awarded_pubkeys)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge,
        _UniffiConverterTypeEvent.lower(badge_definition),
        _UniffiConverterSequenceTypeTag.lower(awarded_pubkeys))
        return cls._make_instance_(pointer)


    @classmethod
    def define_badge(cls, badge_id: "str",name: "typing.Optional[str]",description: "typing.Optional[str]",image: "typing.Optional[str]",image_dimensions: "typing.Optional[ImageDimensions]",thumbnails: "typing.List[Image]"):
        _UniffiConverterString.check_lower(badge_id)
        
        _UniffiConverterOptionalString.check_lower(name)
        
        _UniffiConverterOptionalString.check_lower(description)
        
        _UniffiConverterOptionalString.check_lower(image)
        
        _UniffiConverterOptionalTypeImageDimensions.check_lower(image_dimensions)
        
        _UniffiConverterSequenceTypeImage.check_lower(thumbnails)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge,
        _UniffiConverterString.lower(badge_id),
        _UniffiConverterOptionalString.lower(name),
        _UniffiConverterOptionalString.lower(description),
        _UniffiConverterOptionalString.lower(image),
        _UniffiConverterOptionalTypeImageDimensions.lower(image_dimensions),
        _UniffiConverterSequenceTypeImage.lower(thumbnails))
        return cls._make_instance_(pointer)


    @classmethod
    def delete(cls, ids: "typing.List[EventId]",reason: "typing.Optional[str]"):
        """Create delete event"""

        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_delete,
        _UniffiConverterSequenceTypeEventId.lower(ids),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def file_metadata(cls, description: "str",metadata: "FileMetadata"):
        _UniffiConverterString.check_lower(description)
        
        _UniffiConverterTypeFileMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata,
        _UniffiConverterString.lower(description),
        _UniffiConverterTypeFileMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def hide_channel_msg(cls, message_id: "EventId",reason: "typing.Optional[str]"):
        _UniffiConverterTypeEventId.check_lower(message_id)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg,
        _UniffiConverterTypeEventId.lower(message_id),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def http_auth(cls, data: "HttpData"):
        _UniffiConverterTypeHttpData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth,
        _UniffiConverterTypeHttpData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def job_feedback(cls, job_request: "Event",status: "DataVendingMachineStatus",extra_info: "typing.Optional[str]",amount_millisats: "int",bolt11: "typing.Optional[str]",payload: "typing.Optional[str]"):
        _UniffiConverterTypeEvent.check_lower(job_request)
        
        _UniffiConverterTypeDataVendingMachineStatus.check_lower(status)
        
        _UniffiConverterOptionalString.check_lower(extra_info)
        
        _UniffiConverterUInt64.check_lower(amount_millisats)
        
        _UniffiConverterOptionalString.check_lower(bolt11)
        
        _UniffiConverterOptionalString.check_lower(payload)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback,
        _UniffiConverterTypeEvent.lower(job_request),
        _UniffiConverterTypeDataVendingMachineStatus.lower(status),
        _UniffiConverterOptionalString.lower(extra_info),
        _UniffiConverterUInt64.lower(amount_millisats),
        _UniffiConverterOptionalString.lower(bolt11),
        _UniffiConverterOptionalString.lower(payload))
        return cls._make_instance_(pointer)


    @classmethod
    def job_request(cls, kind: "int",tags: "typing.List[Tag]"):
        """
        Data Vending Machine - Job Request

        <https://github.com/nostr-protocol/nips/blob/master/90.md>
        """

        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request,
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def job_result(cls, job_request: "Event",amount_millisats: "int",bolt11: "typing.Optional[str]"):
        _UniffiConverterTypeEvent.check_lower(job_request)
        
        _UniffiConverterUInt64.check_lower(amount_millisats)
        
        _UniffiConverterOptionalString.check_lower(bolt11)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result,
        _UniffiConverterTypeEvent.lower(job_request),
        _UniffiConverterUInt64.lower(amount_millisats),
        _UniffiConverterOptionalString.lower(bolt11))
        return cls._make_instance_(pointer)


    @classmethod
    def live_event(cls, live_event: "LiveEvent"):
        _UniffiConverterTypeLiveEvent.check_lower(live_event)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event,
        _UniffiConverterTypeLiveEvent.lower(live_event))
        return cls._make_instance_(pointer)


    @classmethod
    def live_event_msg(cls, live_event_id: "str",live_event_host: "PublicKey",content: "str",relay_url: "typing.Optional[str]",tags: "typing.List[Tag]"):
        _UniffiConverterString.check_lower(live_event_id)
        
        _UniffiConverterTypePublicKey.check_lower(live_event_host)
        
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterOptionalString.check_lower(relay_url)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg,
        _UniffiConverterString.lower(live_event_id),
        _UniffiConverterTypePublicKey.lower(live_event_host),
        _UniffiConverterString.lower(content),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def long_form_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note,
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def mute_channel_user(cls, public_key: "PublicKey",reason: "typing.Optional[str]"):
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def new_channel(cls, metadata: "Metadata"):
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def new_channel_msg(cls, channel_id: "EventId",relay_url: "str",content: "str"):
        _UniffiConverterTypeEventId.check_lower(channel_id)
        
        _UniffiConverterString.check_lower(relay_url)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg,
        _UniffiConverterTypeEventId.lower(channel_id),
        _UniffiConverterString.lower(relay_url),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def new_encrypted_direct_msg(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",content: "str",reply_to: "typing.Optional[EventId]"):
        """Create encrypted direct msg event"""

        _UniffiConverterTypeKeys.check_lower(sender_keys)
        
        _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
        
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterOptionalTypeEventId.check_lower(reply_to)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterString.lower(content),
        _UniffiConverterOptionalTypeEventId.lower(reply_to))
        return cls._make_instance_(pointer)


    @classmethod
    def new_product_data(cls, data: "ProductData"):
        _UniffiConverterTypeProductData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_product_data,
        _UniffiConverterTypeProductData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def new_reaction(cls, event_id: "EventId",public_key: "PublicKey",content: "str"):
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def new_stall_data(cls, data: "StallData"):
        _UniffiConverterTypeStallData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_stall_data,
        _UniffiConverterTypeStallData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def new_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        _UniffiConverterString.check_lower(content)
        
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note,
        _UniffiConverterString.lower(content),
        _UniffiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def new_zap_receipt(cls, bolt11: "str",preimage: "typing.Optional[str]",zap_request: "Event"):
        _UniffiConverterString.check_lower(bolt11)
        
        _UniffiConverterOptionalString.check_lower(preimage)
        
        _UniffiConverterTypeEvent.check_lower(zap_request)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt,
        _UniffiConverterString.lower(bolt11),
        _UniffiConverterOptionalString.lower(preimage),
        _UniffiConverterTypeEvent.lower(zap_request))
        return cls._make_instance_(pointer)


    @classmethod
    def new_zap_request(cls, data: "ZapRequestData"):
        _UniffiConverterTypeZapRequestData.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_request,
        _UniffiConverterTypeZapRequestData.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def nostr_connect(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",msg: "NostrConnectMessage"):
        _UniffiConverterTypeKeys.check_lower(sender_keys)
        
        _UniffiConverterTypePublicKey.check_lower(receiver_pubkey)
        
        _UniffiConverterTypeNostrConnectMessage.check_lower(msg)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect,
        _UniffiConverterTypeKeys.lower(sender_keys),
        _UniffiConverterTypePublicKey.lower(receiver_pubkey),
        _UniffiConverterTypeNostrConnectMessage.lower(msg))
        return cls._make_instance_(pointer)


    @classmethod
    def profile_badges(cls, badge_definitions: "typing.List[Event]",badge_awards: "typing.List[Event]",pubkey_awarded: "PublicKey"):
        _UniffiConverterSequenceTypeEvent.check_lower(badge_definitions)
        
        _UniffiConverterSequenceTypeEvent.check_lower(badge_awards)
        
        _UniffiConverterTypePublicKey.check_lower(pubkey_awarded)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges,
        _UniffiConverterSequenceTypeEvent.lower(badge_definitions),
        _UniffiConverterSequenceTypeEvent.lower(badge_awards),
        _UniffiConverterTypePublicKey.lower(pubkey_awarded))
        return cls._make_instance_(pointer)


    @classmethod
    def relay_list(cls, list: "dict"):
        _UniffiConverterMapStringOptionalTypeRelayMetadata.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list,
        _UniffiConverterMapStringOptionalTypeRelayMetadata.lower(list))
        return cls._make_instance_(pointer)


    @classmethod
    def report(cls, tags: "typing.List[Tag]",content: "str"):
        _UniffiConverterSequenceTypeTag.check_lower(tags)
        
        _UniffiConverterString.check_lower(content)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_report,
        _UniffiConverterSequenceTypeTag.lower(tags),
        _UniffiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def repost(cls, event_id: "EventId",public_key: "PublicKey"):
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_repost,
        _UniffiConverterTypeEventId.lower(event_id),
        _UniffiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)


    @classmethod
    def set_channel_metadata(cls, channel_id: "EventId",relay_url: "typing.Optional[str]",metadata: "Metadata"):
        _UniffiConverterTypeEventId.check_lower(channel_id)
        
        _UniffiConverterOptionalString.check_lower(relay_url)
        
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata,
        _UniffiConverterTypeEventId.lower(channel_id),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def set_contact_list(cls, list: "typing.List[Contact]"):
        _UniffiConverterSequenceTypeContact.check_lower(list)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list,
        _UniffiConverterSequenceTypeContact.lower(list))
        return cls._make_instance_(pointer)


    @classmethod
    def set_metadata(cls, metadata: "Metadata"):
        _UniffiConverterTypeMetadata.check_lower(metadata)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata,
        _UniffiConverterTypeMetadata.lower(metadata))
        return cls._make_instance_(pointer)



    def to_event(self, keys: "Keys") -> "Event":
        _UniffiConverterTypeKeys.check_lower(keys)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys))
        )






    def to_pow_event(self, keys: "Keys",difficulty: "int") -> "Event":
        _UniffiConverterTypeKeys.check_lower(keys)
        
        _UniffiConverterUInt8.check_lower(difficulty)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys),
        _UniffiConverterUInt8.lower(difficulty))
        )






    def to_unsigned_event(self, public_key: "PublicKey") -> "UnsignedEvent":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(public_key))
        )






    def to_unsigned_pow_event(self, public_key: "PublicKey",difficulty: "int") -> "UnsignedEvent":
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterUInt8.check_lower(difficulty)
        
        return _UniffiConverterTypeUnsignedEvent.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(difficulty))
        )





class _UniffiConverterTypeEventBuilder:

    @staticmethod
    def lift(value: int):
        return EventBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: EventBuilder):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventBuilderProtocol):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventIdProtocol(typing.Protocol):
    def as_bytes(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class EventId:

    _pointer: ctypes.c_void_p
    def __init__(self, pubkey: "PublicKey",created_at: "Timestamp",kind: "int",tags: "typing.List[typing.List[str]]",content: "str"):
        _UniffiConverterTypePublicKey.check_lower(pubkey)
        
        _UniffiConverterTypeTimestamp.check_lower(created_at)
        
        _UniffiConverterUInt64.check_lower(kind)
        
        _UniffiConverterSequenceSequenceString.check_lower(tags)
        
        _UniffiConverterString.check_lower(content)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_new,
        _UniffiConverterTypePublicKey.lower(pubkey),
        _UniffiConverterTypeTimestamp.lower(created_at),
        _UniffiConverterUInt64.lower(kind),
        _UniffiConverterSequenceSequenceString.lower(tags),
        _UniffiConverterString.lower(content))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_eventid, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_eventid, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, id: "str"):
        _UniffiConverterString.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bech32,
        _UniffiConverterString.lower(id))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def as_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_as_bytes,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_hex,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeEventId:

    @staticmethod
    def lift(value: int):
        return EventId._make_instance_(value)

    @staticmethod
    def check_lower(value: EventId):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventIdProtocol):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventIdProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FileMetadataProtocol(typing.Protocol):
    def aes_256_gcm(self, key: "str",iv: "str"):
        raise NotImplementedError
    def blurhash(self, blurhash: "str"):
        """Add blurhash"""

        raise NotImplementedError
    def dimensions(self, dim: "ImageDimensions"):
        """Add file size (pixels)"""

        raise NotImplementedError
    def magnet(self, magnet: "str"):
        """Add magnet"""

        raise NotImplementedError
    def size(self, size: "int"):
        """Add file size (bytes)"""

        raise NotImplementedError

class FileMetadata:

    _pointer: ctypes.c_void_p
    def __init__(self, url: "str",mime_type: "str",hash: "str"):
        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterString.check_lower(mime_type)
        
        _UniffiConverterString.check_lower(hash)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_filemetadata_new,
        _UniffiConverterString.lower(url),
        _UniffiConverterString.lower(mime_type),
        _UniffiConverterString.lower(hash))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_filemetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_filemetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def aes_256_gcm(self, key: "str",iv: "str") -> "FileMetadata":
        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterString.check_lower(iv)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(iv))
        )






    def blurhash(self, blurhash: "str") -> "FileMetadata":
        """Add blurhash"""

        _UniffiConverterString.check_lower(blurhash)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_blurhash,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(blurhash))
        )






    def dimensions(self, dim: "ImageDimensions") -> "FileMetadata":
        """Add file size (pixels)"""

        _UniffiConverterTypeImageDimensions.check_lower(dim)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_dimensions,self._uniffi_clone_pointer(),
        _UniffiConverterTypeImageDimensions.lower(dim))
        )






    def magnet(self, magnet: "str") -> "FileMetadata":
        """Add magnet"""

        _UniffiConverterString.check_lower(magnet)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_magnet,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(magnet))
        )






    def size(self, size: "int") -> "FileMetadata":
        """Add file size (bytes)"""

        _UniffiConverterUInt64.check_lower(size)
        
        return _UniffiConverterTypeFileMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filemetadata_size,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(size))
        )





class _UniffiConverterTypeFileMetadata:

    @staticmethod
    def lift(value: int):
        return FileMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: FileMetadata):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FileMetadataProtocol):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FileMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FilterProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def author(self, author: "PublicKey"):
        """Add event author Public Key"""

        raise NotImplementedError
    def authors(self, authors: "typing.List[PublicKey]"):
        raise NotImplementedError
    def custom_tag(self, tag: "Alphabet",content: "typing.List[str]"):
        raise NotImplementedError
    def event(self, event_id: "EventId"):
        """Add event ID (`e` tag)"""

        raise NotImplementedError
    def events(self, ids: "typing.List[EventId]"):
        """Add event IDs (`e` tag)"""

        raise NotImplementedError
    def hashtag(self, hashtag: "str"):
        raise NotImplementedError
    def hashtags(self, hashtags: "typing.List[str]"):
        raise NotImplementedError
    def id(self, id: "EventId"):
        raise NotImplementedError
    def identifier(self, identifier: "str"):
        raise NotImplementedError
    def identifiers(self, identifiers: "typing.List[str]"):
        raise NotImplementedError
    def ids(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def is_empty(self, ):
        raise NotImplementedError
    def kind(self, kind: "int"):
        raise NotImplementedError
    def kinds(self, kinds: "typing.List[int]"):
        raise NotImplementedError
    def limit(self, limit: "int"):
        raise NotImplementedError
    def match_event(self, event: "Event"):
        raise NotImplementedError
    def pubkey(self, pubkey: "PublicKey"):
        """Add Public Key (`p` tag)"""

        raise NotImplementedError
    def pubkeys(self, pubkeys: "typing.List[PublicKey]"):
        """Add Public Keys (`p` tag)"""

        raise NotImplementedError
    def reference(self, reference: "str"):
        raise NotImplementedError
    def references(self, references: "typing.List[str]"):
        raise NotImplementedError
    def remove_authors(self, authors: "typing.List[PublicKey]"):
        raise NotImplementedError
    def remove_custom_tag(self, tag: "Alphabet",content: "typing.List[str]"):
        raise NotImplementedError
    def remove_events(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def remove_hashtags(self, hashtags: "typing.List[str]"):
        raise NotImplementedError
    def remove_identifiers(self, identifiers: "typing.List[str]"):
        raise NotImplementedError
    def remove_ids(self, ids: "typing.List[EventId]"):
        raise NotImplementedError
    def remove_kinds(self, kinds: "typing.List[int]"):
        raise NotImplementedError
    def remove_limit(self, ):
        raise NotImplementedError
    def remove_pubkeys(self, pubkeys: "typing.List[PublicKey]"):
        raise NotImplementedError
    def remove_references(self, references: "typing.List[str]"):
        raise NotImplementedError
    def remove_search(self, ):
        raise NotImplementedError
    def remove_since(self, ):
        raise NotImplementedError
    def remove_until(self, ):
        raise NotImplementedError
    def search(self, text: "str"):
        raise NotImplementedError
    def since(self, timestamp: "Timestamp"):
        raise NotImplementedError
    def until(self, timestamp: "Timestamp"):
        raise NotImplementedError

class Filter:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_filter, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_filter, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_filter_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_as_json,self._uniffi_clone_pointer(),)
        )






    def author(self, author: "PublicKey") -> "Filter":
        """Add event author Public Key"""

        _UniffiConverterTypePublicKey.check_lower(author)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_author,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(author))
        )






    def authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(authors)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_authors,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )






    def custom_tag(self, tag: "Alphabet",content: "typing.List[str]") -> "Filter":
        _UniffiConverterTypeAlphabet.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(content)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_custom_tag,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAlphabet.lower(tag),
        _UniffiConverterSequenceString.lower(content))
        )






    def event(self, event_id: "EventId") -> "Filter":
        """Add event ID (`e` tag)"""

        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(event_id))
        )






    def events(self, ids: "typing.List[EventId]") -> "Filter":
        """Add event IDs (`e` tag)"""

        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_events,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def hashtag(self, hashtag: "str") -> "Filter":
        _UniffiConverterString.check_lower(hashtag)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtag,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(hashtag))
        )






    def hashtags(self, hashtags: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_hashtags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(hashtags))
        )






    def id(self, id: "EventId") -> "Filter":
        _UniffiConverterTypeEventId.check_lower(id)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(id))
        )






    def identifier(self, identifier: "str") -> "Filter":
        _UniffiConverterString.check_lower(identifier)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifier,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(identifier))
        )






    def identifiers(self, identifiers: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(identifiers)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_identifiers,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(identifiers))
        )






    def ids(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_ids,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def is_empty(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_is_empty,self._uniffi_clone_pointer(),)
        )






    def kind(self, kind: "int") -> "Filter":
        _UniffiConverterUInt64.check_lower(kind)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kind,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(kind))
        )






    def kinds(self, kinds: "typing.List[int]") -> "Filter":
        _UniffiConverterSequenceUInt64.check_lower(kinds)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_kinds,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt64.lower(kinds))
        )






    def limit(self, limit: "int") -> "Filter":
        _UniffiConverterUInt64.check_lower(limit)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_limit,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(limit))
        )






    def match_event(self, event: "Event") -> "bool":
        _UniffiConverterTypeEvent.check_lower(event)
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_match_event,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEvent.lower(event))
        )






    def pubkey(self, pubkey: "PublicKey") -> "Filter":
        """Add Public Key (`p` tag)"""

        _UniffiConverterTypePublicKey.check_lower(pubkey)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkey,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(pubkey))
        )






    def pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        """Add Public Keys (`p` tag)"""

        _UniffiConverterSequenceTypePublicKey.check_lower(pubkeys)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_pubkeys,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )






    def reference(self, reference: "str") -> "Filter":
        _UniffiConverterString.check_lower(reference)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_reference,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(reference))
        )






    def references(self, references: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(references)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_references,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(references))
        )






    def remove_authors(self, authors: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(authors)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_authors,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(authors))
        )






    def remove_custom_tag(self, tag: "Alphabet",content: "typing.List[str]") -> "Filter":
        _UniffiConverterTypeAlphabet.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(content)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_custom_tag,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAlphabet.lower(tag),
        _UniffiConverterSequenceString.lower(content))
        )






    def remove_events(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_events,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def remove_hashtags(self, hashtags: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(hashtags)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_hashtags,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(hashtags))
        )






    def remove_identifiers(self, identifiers: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(identifiers)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_identifiers,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(identifiers))
        )






    def remove_ids(self, ids: "typing.List[EventId]") -> "Filter":
        _UniffiConverterSequenceTypeEventId.check_lower(ids)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_ids,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeEventId.lower(ids))
        )






    def remove_kinds(self, kinds: "typing.List[int]") -> "Filter":
        _UniffiConverterSequenceUInt64.check_lower(kinds)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_kinds,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt64.lower(kinds))
        )






    def remove_limit(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_limit,self._uniffi_clone_pointer(),)
        )






    def remove_pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        _UniffiConverterSequenceTypePublicKey.check_lower(pubkeys)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_pubkeys,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePublicKey.lower(pubkeys))
        )






    def remove_references(self, references: "typing.List[str]") -> "Filter":
        _UniffiConverterSequenceString.check_lower(references)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_references,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(references))
        )






    def remove_search(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_search,self._uniffi_clone_pointer(),)
        )






    def remove_since(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_since,self._uniffi_clone_pointer(),)
        )






    def remove_until(self, ) -> "Filter":
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_remove_until,self._uniffi_clone_pointer(),)
        )






    def search(self, text: "str") -> "Filter":
        _UniffiConverterString.check_lower(text)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_search,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text))
        )






    def since(self, timestamp: "Timestamp") -> "Filter":
        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_since,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )






    def until(self, timestamp: "Timestamp") -> "Filter":
        _UniffiConverterTypeTimestamp.check_lower(timestamp)
        
        return _UniffiConverterTypeFilter.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_filter_until,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTimestamp.lower(timestamp))
        )





class _UniffiConverterTypeFilter:

    @staticmethod
    def lift(value: int):
        return Filter._make_instance_(value)

    @staticmethod
    def check_lower(value: Filter):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FilterProtocol):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FilterProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ImageDimensionsProtocol(typing.Protocol):
    def height(self, ):
        raise NotImplementedError
    def width(self, ):
        raise NotImplementedError

class ImageDimensions:

    _pointer: ctypes.c_void_p
    def __init__(self, width: "int",height: "int"):
        _UniffiConverterUInt64.check_lower(width)
        
        _UniffiConverterUInt64.check_lower(height)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_imagedimensions_new,
        _UniffiConverterUInt64.lower(width),
        _UniffiConverterUInt64.lower(height))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_imagedimensions, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_imagedimensions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def height(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_height,self._uniffi_clone_pointer(),)
        )






    def width(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_imagedimensions_width,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeImageDimensions:

    @staticmethod
    def lift(value: int):
        return ImageDimensions._make_instance_(value)

    @staticmethod
    def check_lower(value: ImageDimensions):
        if not isinstance(value, ImageDimensions):
            raise TypeError("Expected ImageDimensions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ImageDimensionsProtocol):
        if not isinstance(value, ImageDimensions):
            raise TypeError("Expected ImageDimensions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ImageDimensionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class KeysProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def secret_key(self, ):
        raise NotImplementedError
    def sign_schnorr(self, message: "bytes"):
        raise NotImplementedError

class Keys:

    _pointer: ctypes.c_void_p
    def __init__(self, sk: "SecretKey"):
        _UniffiConverterTypeSecretKey.check_lower(sk)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_new,
        _UniffiConverterTypeSecretKey.lower(sk))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_keys, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_keys, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_mnemonic(cls, mnemonic: "str",passphrase: "typing.Optional[str]",account: "typing.Optional[int]"):
        """
        Derive `Keys` from BIP-39 mnemonics (ENGLISH wordlist).

        By default no passphrase is used and account is set to `0`.

        <https://github.com/nostr-protocol/nips/blob/master/06.md>
        """

        _UniffiConverterString.check_lower(mnemonic)
        
        _UniffiConverterOptionalString.check_lower(passphrase)
        
        _UniffiConverterOptionalUInt32.check_lower(account)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic,
        _UniffiConverterString.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase),
        _UniffiConverterOptionalUInt32.lower(account))
        return cls._make_instance_(pointer)


    @classmethod
    def from_pk_str(cls, pk: "str"):
        _UniffiConverterString.check_lower(pk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_pk_str,
        _UniffiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_public_key(cls, pk: "PublicKey"):
        _UniffiConverterTypePublicKey.check_lower(pk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_public_key,
        _UniffiConverterTypePublicKey.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_sk_str(cls, sk: "str"):
        _UniffiConverterString.check_lower(sk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_from_sk_str,
        _UniffiConverterString.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_generate,)
        return cls._make_instance_(pointer)


    @classmethod
    def vanity(cls, prefixes: "typing.List[str]",bech32: "bool",num_cores: "int"):
        _UniffiConverterSequenceString.check_lower(prefixes)
        
        _UniffiConverterBool.check_lower(bech32)
        
        _UniffiConverterUInt8.check_lower(num_cores)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_keys_vanity,
        _UniffiConverterSequenceString.lower(prefixes),
        _UniffiConverterBool.lower(bech32),
        _UniffiConverterUInt8.lower(num_cores))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_keys_public_key,self._uniffi_clone_pointer(),)
        )






    def secret_key(self, ) -> "SecretKey":
        return _UniffiConverterTypeSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_keys_secret_key,self._uniffi_clone_pointer(),)
        )






    def sign_schnorr(self, message: "bytes") -> "str":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_keys_sign_schnorr,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





class _UniffiConverterTypeKeys:

    @staticmethod
    def lift(value: int):
        return Keys._make_instance_(value)

    @staticmethod
    def check_lower(value: Keys):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: KeysProtocol):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: KeysProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class MetadataProtocol(typing.Protocol):
    def as_json(self, ):
        raise NotImplementedError
    def get_about(self, ):
        raise NotImplementedError
    def get_banner(self, ):
        raise NotImplementedError
    def get_custom_field(self, key: "str"):
        raise NotImplementedError
    def get_display_name(self, ):
        raise NotImplementedError
    def get_lud06(self, ):
        raise NotImplementedError
    def get_lud16(self, ):
        raise NotImplementedError
    def get_name(self, ):
        raise NotImplementedError
    def get_nip05(self, ):
        raise NotImplementedError
    def get_picture(self, ):
        raise NotImplementedError
    def get_website(self, ):
        raise NotImplementedError
    def set_about(self, about: "str"):
        raise NotImplementedError
    def set_banner(self, banner: "str"):
        raise NotImplementedError
    def set_custom_field(self, key: "str",value: "str"):
        raise NotImplementedError
    def set_display_name(self, display_name: "str"):
        raise NotImplementedError
    def set_lud06(self, lud06: "str"):
        raise NotImplementedError
    def set_lud16(self, lud16: "str"):
        raise NotImplementedError
    def set_name(self, name: "str"):
        raise NotImplementedError
    def set_nip05(self, nip05: "str"):
        raise NotImplementedError
    def set_picture(self, picture: "str"):
        raise NotImplementedError
    def set_website(self, website: "str"):
        raise NotImplementedError

class Metadata:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_metadata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_metadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_metadata_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_as_json,self._uniffi_clone_pointer(),)
        )






    def get_about(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_about,self._uniffi_clone_pointer(),)
        )






    def get_banner(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_banner,self._uniffi_clone_pointer(),)
        )






    def get_custom_field(self, key: "str") -> "typing.Optional[str]":
        _UniffiConverterString.check_lower(key)
        
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_custom_field,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key))
        )






    def get_display_name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_display_name,self._uniffi_clone_pointer(),)
        )






    def get_lud06(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud06,self._uniffi_clone_pointer(),)
        )






    def get_lud16(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_lud16,self._uniffi_clone_pointer(),)
        )






    def get_name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_name,self._uniffi_clone_pointer(),)
        )






    def get_nip05(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_nip05,self._uniffi_clone_pointer(),)
        )






    def get_picture(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_picture,self._uniffi_clone_pointer(),)
        )






    def get_website(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_get_website,self._uniffi_clone_pointer(),)
        )






    def set_about(self, about: "str") -> "Metadata":
        _UniffiConverterString.check_lower(about)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_about,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(about))
        )






    def set_banner(self, banner: "str") -> "Metadata":
        _UniffiConverterString.check_lower(banner)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_banner,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(banner))
        )






    def set_custom_field(self, key: "str",value: "str") -> "Metadata":
        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterString.check_lower(value)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_custom_field,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(value))
        )






    def set_display_name(self, display_name: "str") -> "Metadata":
        _UniffiConverterString.check_lower(display_name)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_display_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(display_name))
        )






    def set_lud06(self, lud06: "str") -> "Metadata":
        _UniffiConverterString.check_lower(lud06)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud06,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lud06))
        )






    def set_lud16(self, lud16: "str") -> "Metadata":
        _UniffiConverterString.check_lower(lud16)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_lud16,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lud16))
        )






    def set_name(self, name: "str") -> "Metadata":
        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name))
        )






    def set_nip05(self, nip05: "str") -> "Metadata":
        _UniffiConverterString.check_lower(nip05)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_nip05,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(nip05))
        )






    def set_picture(self, picture: "str") -> "Metadata":
        _UniffiConverterString.check_lower(picture)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_picture,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(picture))
        )






    def set_website(self, website: "str") -> "Metadata":
        _UniffiConverterString.check_lower(website)
        
        return _UniffiConverterTypeMetadata.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_metadata_set_website,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(website))
        )





class _UniffiConverterTypeMetadata:

    @staticmethod
    def lift(value: int):
        return Metadata._make_instance_(value)

    @staticmethod
    def check_lower(value: Metadata):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MetadataProtocol):
        if not isinstance(value, Metadata):
            raise TypeError("Expected Metadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Nip19ProfileProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def relays(self, ):
        raise NotImplementedError
    def to_bech32(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class Nip19Profile:

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        """New NIP19 profile"""

        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterSequenceString.check_lower(relays)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nip19profile, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nip19profile, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, bech32: "str"):
        _UniffiConverterString.check_lower(bech32)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32,
        _UniffiConverterString.lower(bech32))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_public_key,self._uniffi_clone_pointer(),)
        )






    def relays(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_relays,self._uniffi_clone_pointer(),)
        )






    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNip19Profile:

    @staticmethod
    def lift(value: int):
        return Nip19Profile._make_instance_(value)

    @staticmethod
    def check_lower(value: Nip19Profile):
        if not isinstance(value, Nip19Profile):
            raise TypeError("Expected Nip19Profile instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Nip19ProfileProtocol):
        if not isinstance(value, Nip19Profile):
            raise TypeError("Expected Nip19Profile instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Nip19ProfileProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NostrConnectUriProtocol(typing.Protocol):
    def description(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def relay_url(self, ):
        raise NotImplementedError
    def url(self, ):
        raise NotImplementedError

class NostrConnectUri:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrconnecturi, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrconnecturi, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_description,self._uniffi_clone_pointer(),)
        )






    def name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_name,self._uniffi_clone_pointer(),)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key,self._uniffi_clone_pointer(),)
        )






    def relay_url(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url,self._uniffi_clone_pointer(),)
        )






    def url(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrconnecturi_url,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNostrConnectURI:

    @staticmethod
    def lift(value: int):
        return NostrConnectUri._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrConnectUri):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrConnectUriProtocol):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrConnectUriProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NostrLibraryProtocol(typing.Protocol):
    def git_hash_version(self, ):
        raise NotImplementedError

class NostrLibrary:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_nostrlibrary_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_nostrlibrary, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_nostrlibrary, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def git_hash_version(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeNostrLibrary:

    @staticmethod
    def lift(value: int):
        return NostrLibrary._make_instance_(value)

    @staticmethod
    def check_lower(value: NostrLibrary):
        if not isinstance(value, NostrLibrary):
            raise TypeError("Expected NostrLibrary instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NostrLibraryProtocol):
        if not isinstance(value, NostrLibrary):
            raise TypeError("Expected NostrLibrary instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NostrLibraryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PublicKeyProtocol(typing.Protocol):
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_nostr_uri(self, ):
        raise NotImplementedError

class PublicKey:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, pk: "str"):
        _UniffiConverterString.check_lower(pk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bech32,
        _UniffiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        _UniffiConverterString.check_lower(uri)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri,
        _UniffiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_hex,self._uniffi_clone_pointer(),)
        )






    def to_nostr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypePublicKey:

    @staticmethod
    def lift(value: int):
        return PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: PublicKey):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PublicKeyProtocol):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RelayInformationDocumentProtocol(typing.Protocol):
    def contact(self, ):
        raise NotImplementedError
    def description(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def pubkey(self, ):
        raise NotImplementedError
    def software(self, ):
        raise NotImplementedError
    def supported_nips(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError

class RelayInformationDocument:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_relayinformationdocument, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_relayinformationdocument, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def get(cls, url: "str",proxy: "typing.Optional[str]"):
        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterOptionalString.check_lower(proxy)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get,
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalString.lower(proxy))
        return cls._make_instance_(pointer)



    def contact(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_contact,self._uniffi_clone_pointer(),)
        )






    def description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_description,self._uniffi_clone_pointer(),)
        )






    def name(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_name,self._uniffi_clone_pointer(),)
        )






    def pubkey(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey,self._uniffi_clone_pointer(),)
        )






    def software(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_software,self._uniffi_clone_pointer(),)
        )






    def supported_nips(self, ) -> "typing.Optional[typing.List[int]]":
        return _UniffiConverterOptionalSequenceUInt16.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips,self._uniffi_clone_pointer(),)
        )






    def version(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_relayinformationdocument_version,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeRelayInformationDocument:

    @staticmethod
    def lift(value: int):
        return RelayInformationDocument._make_instance_(value)

    @staticmethod
    def check_lower(value: RelayInformationDocument):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RelayInformationDocumentProtocol):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RelayInformationDocumentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SecretKeyProtocol(typing.Protocol):
    def to_bech32(self, ):
        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError

class SecretKey:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_secretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_secretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, sk: "str"):
        _UniffiConverterString.check_lower(sk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32,
        _UniffiConverterString.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_secretkey_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_bech32,self._uniffi_clone_pointer(),)
        )






    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_secretkey_to_hex,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeSecretKey:

    @staticmethod
    def lift(value: int):
        return SecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: SecretKey):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SecretKeyProtocol):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ShippingMethodProtocol(typing.Protocol):
    def get_shipping_cost(self, ):
        """Get the product shipping cost of the shipping method"""

        raise NotImplementedError
    def name(self, name: "str"):
        """Set the name of the shipping method"""

        raise NotImplementedError
    def regions(self, regions: "typing.List[str]"):
        """Add a region to the shipping method"""

        raise NotImplementedError

class ShippingMethod:

    _pointer: ctypes.c_void_p
    def __init__(self, id: "str",cost: "float"):
        """Create a new shipping method"""

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterDouble.check_lower(cost)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_shippingmethod_new,
        _UniffiConverterString.lower(id),
        _UniffiConverterDouble.lower(cost))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_shippingmethod, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_shippingmethod, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_shipping_cost(self, ) -> "ShippingCost":
        """Get the product shipping cost of the shipping method"""

        return _UniffiConverterTypeShippingCost.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost,self._uniffi_clone_pointer(),)
        )






    def name(self, name: "str") -> "ShippingMethod":
        """Set the name of the shipping method"""

        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeShippingMethod.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_name,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name))
        )






    def regions(self, regions: "typing.List[str]") -> "ShippingMethod":
        """Add a region to the shipping method"""

        _UniffiConverterSequenceString.check_lower(regions)
        
        return _UniffiConverterTypeShippingMethod.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_shippingmethod_regions,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceString.lower(regions))
        )





class _UniffiConverterTypeShippingMethod:

    @staticmethod
    def lift(value: int):
        return ShippingMethod._make_instance_(value)

    @staticmethod
    def check_lower(value: ShippingMethod):
        if not isinstance(value, ShippingMethod):
            raise TypeError("Expected ShippingMethod instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ShippingMethodProtocol):
        if not isinstance(value, ShippingMethod):
            raise TypeError("Expected ShippingMethod instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ShippingMethodProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TagProtocol(typing.Protocol):
    def as_enum(self, ):
        raise NotImplementedError
    def as_vec(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError

class Tag:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_tag, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_tag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_enum(cls, e: "TagEnum"):
        _UniffiConverterTypeTagEnum.check_lower(e)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_from_enum,
        _UniffiConverterTypeTagEnum.lower(e))
        return cls._make_instance_(pointer)


    @classmethod
    def parse(cls, data: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_tag_parse,
        _UniffiConverterSequenceString.lower(data))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "TagEnum":
        return _UniffiConverterTypeTagEnum.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_enum,self._uniffi_clone_pointer(),)
        )






    def as_vec(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_as_vec,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "TagKind":
        return _UniffiConverterTypeTagKind.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_tag_kind,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeTag:

    @staticmethod
    def lift(value: int):
        return Tag._make_instance_(value)

    @staticmethod
    def check_lower(value: Tag):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TagProtocol):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TimestampProtocol(typing.Protocol):
    def as_secs(self, ):
        """Get timestamp as [`u64`]"""

        raise NotImplementedError
    def to_human_datetime(self, ):
        """Convert [`Timestamp`] to human datetime"""

        raise NotImplementedError

class Timestamp:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_timestamp, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_timestamp, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_secs(cls, secs: "int"):
        _UniffiConverterUInt64.check_lower(secs)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_from_secs,
        _UniffiConverterUInt64.lower(secs))
        return cls._make_instance_(pointer)


    @classmethod
    def now(cls, ):
        """Get UNIX timestamp"""

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_timestamp_now,)
        return cls._make_instance_(pointer)



    def as_secs(self, ) -> "int":
        """Get timestamp as [`u64`]"""

        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_as_secs,self._uniffi_clone_pointer(),)
        )






    def to_human_datetime(self, ) -> "str":
        """Convert [`Timestamp`] to human datetime"""

        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeTimestamp:

    @staticmethod
    def lift(value: int):
        return Timestamp._make_instance_(value)

    @staticmethod
    def check_lower(value: Timestamp):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TimestampProtocol):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TimestampProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class UnsignedEventProtocol(typing.Protocol):
    def add_signature(self, sig: "str"):
        """Add signature to [`UnsignedEvent`]"""

        raise NotImplementedError
    def as_json(self, ):
        raise NotImplementedError
    def content(self, ):
        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def pubkey(self, ):
        raise NotImplementedError
    def sign(self, keys: "Keys"):
        raise NotImplementedError
    def tags(self, ):
        raise NotImplementedError

class UnsignedEvent:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_unsignedevent, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_unsignedevent, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def add_signature(self, sig: "str") -> "Event":
        """Add signature to [`UnsignedEvent`]"""

        _UniffiConverterString.check_lower(sig)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_add_signature,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(sig))
        )






    def as_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_as_json,self._uniffi_clone_pointer(),)
        )






    def content(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_content,self._uniffi_clone_pointer(),)
        )






    def created_at(self, ) -> "Timestamp":
        return _UniffiConverterTypeTimestamp.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_created_at,self._uniffi_clone_pointer(),)
        )






    def id(self, ) -> "EventId":
        return _UniffiConverterTypeEventId.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_id,self._uniffi_clone_pointer(),)
        )






    def kind(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_kind,self._uniffi_clone_pointer(),)
        )






    def pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_pubkey,self._uniffi_clone_pointer(),)
        )






    def sign(self, keys: "Keys") -> "Event":
        _UniffiConverterTypeKeys.check_lower(keys)
        
        return _UniffiConverterTypeEvent.lift(
            _rust_call_with_error(
    _UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_sign,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeys.lower(keys))
        )






    def tags(self, ) -> "typing.List[Tag]":
        return _UniffiConverterSequenceTypeTag.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_unsignedevent_tags,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeUnsignedEvent:

    @staticmethod
    def lift(value: int):
        return UnsignedEvent._make_instance_(value)

    @staticmethod
    def check_lower(value: UnsignedEvent):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UnsignedEventProtocol):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UnsignedEventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ZapRequestDataProtocol(typing.Protocol):
    def amount(self, amount: "int"):
        raise NotImplementedError
    def event_id(self, event_id: "EventId"):
        raise NotImplementedError
    def lnurl(self, lnurl: "str"):
        raise NotImplementedError

class ZapRequestData:

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        _UniffiConverterTypePublicKey.check_lower(public_key)
        
        _UniffiConverterSequenceString.check_lower(relays)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_constructor_zaprequestdata_new,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_free_zaprequestdata, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_clone_zaprequestdata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def amount(self, amount: "int") -> "ZapRequestData":
        _UniffiConverterUInt64.check_lower(amount)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_amount,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount))
        )






    def event_id(self, event_id: "EventId") -> "ZapRequestData":
        _UniffiConverterTypeEventId.check_lower(event_id)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_event_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEventId.lower(event_id))
        )






    def lnurl(self, lnurl: "str") -> "ZapRequestData":
        _UniffiConverterString.check_lower(lnurl)
        
        return _UniffiConverterTypeZapRequestData.lift(
            _rust_call(_UniffiLib.uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lnurl))
        )





class _UniffiConverterTypeZapRequestData:

    @staticmethod
    def lift(value: int):
        return ZapRequestData._make_instance_(value)

    @staticmethod
    def check_lower(value: ZapRequestData):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZapRequestDataProtocol):
        if not isinstance(value, ZapRequestData):
            raise TypeError("Expected ZapRequestData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZapRequestDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class Coordinate:
    """Coordinate for event (`a` tag)"""

    kind: "int"
    """Kind"""

    pubkey: "PublicKey"
    """Public Key"""

    identifier: "str"
    """
    `d` tag identifier

    Needed for a parametrized replaceable event.
    Leave empty for a replaceable event.
    """

    relays: "typing.List[str]"
    """Relays"""

    @typing.no_type_check
    def __init__(self, kind: "int", pubkey: "PublicKey", identifier: "str", relays: "typing.List[str]"):
        self.kind = kind
        self.pubkey = pubkey
        self.identifier = identifier
        self.relays = relays

    def __str__(self):
        return "Coordinate(kind={}, pubkey={}, identifier={}, relays={})".format(self.kind, self.pubkey, self.identifier, self.relays)

    def __eq__(self, other):
        if self.kind != other.kind:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.identifier != other.identifier:
            return False
        if self.relays != other.relays:
            return False
        return True

class _UniffiConverterTypeCoordinate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Coordinate(
            kind=_UniffiConverterUInt64.read(buf),
            pubkey=_UniffiConverterTypePublicKey.read(buf),
            identifier=_UniffiConverterString.read(buf),
            relays=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.kind)
        _UniffiConverterTypePublicKey.check_lower(value.pubkey)
        _UniffiConverterString.check_lower(value.identifier)
        _UniffiConverterSequenceString.check_lower(value.relays)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.kind, buf)
        _UniffiConverterTypePublicKey.write(value.pubkey, buf)
        _UniffiConverterString.write(value.identifier, buf)
        _UniffiConverterSequenceString.write(value.relays, buf)


class HttpData:
    url: "str"
    method: "HttpMethod"
    payload: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, url: "str", method: "HttpMethod", payload: "typing.Optional[str]"):
        self.url = url
        self.method = method
        self.payload = payload

    def __str__(self):
        return "HttpData(url={}, method={}, payload={})".format(self.url, self.method, self.payload)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.method != other.method:
            return False
        if self.payload != other.payload:
            return False
        return True

class _UniffiConverterTypeHttpData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HttpData(
            url=_UniffiConverterString.read(buf),
            method=_UniffiConverterTypeHttpMethod.read(buf),
            payload=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterTypeHttpMethod.check_lower(value.method)
        _UniffiConverterOptionalString.check_lower(value.payload)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterTypeHttpMethod.write(value.method, buf)
        _UniffiConverterOptionalString.write(value.payload, buf)


class Identity:
    """A NIP-39 external identity"""

    platform: "ExternalIdentity"
    """The external identity provider"""

    ident: "str"
    """The user's identity (username) on the provider"""

    proof: "str"
    """The user's proof on the provider"""

    @typing.no_type_check
    def __init__(self, platform: "ExternalIdentity", ident: "str", proof: "str"):
        self.platform = platform
        self.ident = ident
        self.proof = proof

    def __str__(self):
        return "Identity(platform={}, ident={}, proof={})".format(self.platform, self.ident, self.proof)

    def __eq__(self, other):
        if self.platform != other.platform:
            return False
        if self.ident != other.ident:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Identity(
            platform=_UniffiConverterTypeExternalIdentity.read(buf),
            ident=_UniffiConverterString.read(buf),
            proof=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalIdentity.check_lower(value.platform)
        _UniffiConverterString.check_lower(value.ident)
        _UniffiConverterString.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalIdentity.write(value.platform, buf)
        _UniffiConverterString.write(value.ident, buf)
        _UniffiConverterString.write(value.proof, buf)


class Image:
    url: "str"
    dimensions: "typing.Optional[ImageDimensions]"
    @typing.no_type_check
    def __init__(self, url: "str", dimensions: "typing.Optional[ImageDimensions]"):
        self.url = url
        self.dimensions = dimensions

    def __str__(self):
        return "Image(url={}, dimensions={})".format(self.url, self.dimensions)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.dimensions != other.dimensions:
            return False
        return True

class _UniffiConverterTypeImage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Image(
            url=_UniffiConverterString.read(buf),
            dimensions=_UniffiConverterOptionalTypeImageDimensions.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)


class LiveEvent:
    id: "str"
    title: "typing.Optional[str]"
    summary: "typing.Optional[str]"
    image: "typing.Optional[Image]"
    hashtags: "typing.List[str]"
    streaming: "typing.Optional[str]"
    recording: "typing.Optional[str]"
    start: "typing.Optional[Timestamp]"
    ends: "typing.Optional[Timestamp]"
    status: "typing.Optional[LiveEventStatus]"
    current_participants: "typing.Optional[int]"
    total_participants: "typing.Optional[int]"
    relays: "typing.List[str]"
    host: "typing.Optional[LiveEventHost]"
    speakers: "typing.List[Person]"
    participants: "typing.List[Person]"
    @typing.no_type_check
    def __init__(self, id: "str", title: "typing.Optional[str]", summary: "typing.Optional[str]", image: "typing.Optional[Image]", hashtags: "typing.List[str]", streaming: "typing.Optional[str]", recording: "typing.Optional[str]", start: "typing.Optional[Timestamp]", ends: "typing.Optional[Timestamp]", status: "typing.Optional[LiveEventStatus]", current_participants: "typing.Optional[int]", total_participants: "typing.Optional[int]", relays: "typing.List[str]", host: "typing.Optional[LiveEventHost]", speakers: "typing.List[Person]", participants: "typing.List[Person]"):
        self.id = id
        self.title = title
        self.summary = summary
        self.image = image
        self.hashtags = hashtags
        self.streaming = streaming
        self.recording = recording
        self.start = start
        self.ends = ends
        self.status = status
        self.current_participants = current_participants
        self.total_participants = total_participants
        self.relays = relays
        self.host = host
        self.speakers = speakers
        self.participants = participants

    def __str__(self):
        return "LiveEvent(id={}, title={}, summary={}, image={}, hashtags={}, streaming={}, recording={}, start={}, ends={}, status={}, current_participants={}, total_participants={}, relays={}, host={}, speakers={}, participants={})".format(self.id, self.title, self.summary, self.image, self.hashtags, self.streaming, self.recording, self.start, self.ends, self.status, self.current_participants, self.total_participants, self.relays, self.host, self.speakers, self.participants)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.title != other.title:
            return False
        if self.summary != other.summary:
            return False
        if self.image != other.image:
            return False
        if self.hashtags != other.hashtags:
            return False
        if self.streaming != other.streaming:
            return False
        if self.recording != other.recording:
            return False
        if self.start != other.start:
            return False
        if self.ends != other.ends:
            return False
        if self.status != other.status:
            return False
        if self.current_participants != other.current_participants:
            return False
        if self.total_participants != other.total_participants:
            return False
        if self.relays != other.relays:
            return False
        if self.host != other.host:
            return False
        if self.speakers != other.speakers:
            return False
        if self.participants != other.participants:
            return False
        return True

class _UniffiConverterTypeLiveEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiveEvent(
            id=_UniffiConverterString.read(buf),
            title=_UniffiConverterOptionalString.read(buf),
            summary=_UniffiConverterOptionalString.read(buf),
            image=_UniffiConverterOptionalTypeImage.read(buf),
            hashtags=_UniffiConverterSequenceString.read(buf),
            streaming=_UniffiConverterOptionalString.read(buf),
            recording=_UniffiConverterOptionalString.read(buf),
            start=_UniffiConverterOptionalTypeTimestamp.read(buf),
            ends=_UniffiConverterOptionalTypeTimestamp.read(buf),
            status=_UniffiConverterOptionalTypeLiveEventStatus.read(buf),
            current_participants=_UniffiConverterOptionalUInt64.read(buf),
            total_participants=_UniffiConverterOptionalUInt64.read(buf),
            relays=_UniffiConverterSequenceString.read(buf),
            host=_UniffiConverterOptionalTypeLiveEventHost.read(buf),
            speakers=_UniffiConverterSequenceTypePerson.read(buf),
            participants=_UniffiConverterSequenceTypePerson.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterOptionalString.check_lower(value.title)
        _UniffiConverterOptionalString.check_lower(value.summary)
        _UniffiConverterOptionalTypeImage.check_lower(value.image)
        _UniffiConverterSequenceString.check_lower(value.hashtags)
        _UniffiConverterOptionalString.check_lower(value.streaming)
        _UniffiConverterOptionalString.check_lower(value.recording)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.start)
        _UniffiConverterOptionalTypeTimestamp.check_lower(value.ends)
        _UniffiConverterOptionalTypeLiveEventStatus.check_lower(value.status)
        _UniffiConverterOptionalUInt64.check_lower(value.current_participants)
        _UniffiConverterOptionalUInt64.check_lower(value.total_participants)
        _UniffiConverterSequenceString.check_lower(value.relays)
        _UniffiConverterOptionalTypeLiveEventHost.check_lower(value.host)
        _UniffiConverterSequenceTypePerson.check_lower(value.speakers)
        _UniffiConverterSequenceTypePerson.check_lower(value.participants)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.title, buf)
        _UniffiConverterOptionalString.write(value.summary, buf)
        _UniffiConverterOptionalTypeImage.write(value.image, buf)
        _UniffiConverterSequenceString.write(value.hashtags, buf)
        _UniffiConverterOptionalString.write(value.streaming, buf)
        _UniffiConverterOptionalString.write(value.recording, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.start, buf)
        _UniffiConverterOptionalTypeTimestamp.write(value.ends, buf)
        _UniffiConverterOptionalTypeLiveEventStatus.write(value.status, buf)
        _UniffiConverterOptionalUInt64.write(value.current_participants, buf)
        _UniffiConverterOptionalUInt64.write(value.total_participants, buf)
        _UniffiConverterSequenceString.write(value.relays, buf)
        _UniffiConverterOptionalTypeLiveEventHost.write(value.host, buf)
        _UniffiConverterSequenceTypePerson.write(value.speakers, buf)
        _UniffiConverterSequenceTypePerson.write(value.participants, buf)


class LiveEventHost:
    public_key: "PublicKey"
    relay_url: "typing.Optional[str]"
    proof: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, public_key: "PublicKey", relay_url: "typing.Optional[str]", proof: "typing.Optional[str]"):
        self.public_key = public_key
        self.relay_url = relay_url
        self.proof = proof

    def __str__(self):
        return "LiveEventHost(public_key={}, relay_url={}, proof={})".format(self.public_key, self.relay_url, self.proof)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.relay_url != other.relay_url:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeLiveEventHost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiveEventHost(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalString.read(buf),
            proof=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalString.check_lower(value.relay_url)
        _UniffiConverterOptionalString.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalString.write(value.relay_url, buf)
        _UniffiConverterOptionalString.write(value.proof, buf)


class Person:
    public_key: "PublicKey"
    url: "typing.Optional[str]"
    @typing.no_type_check
    def __init__(self, public_key: "PublicKey", url: "typing.Optional[str]"):
        self.public_key = public_key
        self.url = url

    def __str__(self):
        return "Person(public_key={}, url={})".format(self.public_key, self.url)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.url != other.url:
            return False
        return True

class _UniffiConverterTypePerson(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Person(
            public_key=_UniffiConverterTypePublicKey.read(buf),
            url=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.public_key)
        _UniffiConverterOptionalString.check_lower(value.url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.public_key, buf)
        _UniffiConverterOptionalString.write(value.url, buf)


class ProductData:
    """Payload for creating or updating product"""

    id: "str"
    """UUID of the product generated by merchant"""

    stall_id: "str"
    """Id of the stall that this product belongs to"""

    name: "str"
    """Product name"""

    description: "typing.Optional[str]"
    """Description of the product"""

    images: "typing.Optional[typing.List[str]]"
    """Image urls of the product"""

    currency: "str"
    """Currency used"""

    price: "float"
    """Price of the product"""

    quantity: "int"
    """Available items"""

    specs: "typing.Optional[typing.List[typing.List[str]]]"
    """Specifications of the product"""

    shipping: "typing.List[ShippingCost]"
    """Shipping method costs"""

    categories: "typing.Optional[typing.List[str]]"
    """Categories of the product (will be added to tags)"""

    @typing.no_type_check
    def __init__(self, id: "str", stall_id: "str", name: "str", description: "typing.Optional[str]", images: "typing.Optional[typing.List[str]]", currency: "str", price: "float", quantity: "int", specs: "typing.Optional[typing.List[typing.List[str]]]", shipping: "typing.List[ShippingCost]", categories: "typing.Optional[typing.List[str]]"):
        self.id = id
        self.stall_id = stall_id
        self.name = name
        self.description = description
        self.images = images
        self.currency = currency
        self.price = price
        self.quantity = quantity
        self.specs = specs
        self.shipping = shipping
        self.categories = categories

    def __str__(self):
        return "ProductData(id={}, stall_id={}, name={}, description={}, images={}, currency={}, price={}, quantity={}, specs={}, shipping={}, categories={})".format(self.id, self.stall_id, self.name, self.description, self.images, self.currency, self.price, self.quantity, self.specs, self.shipping, self.categories)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.stall_id != other.stall_id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.images != other.images:
            return False
        if self.currency != other.currency:
            return False
        if self.price != other.price:
            return False
        if self.quantity != other.quantity:
            return False
        if self.specs != other.specs:
            return False
        if self.shipping != other.shipping:
            return False
        if self.categories != other.categories:
            return False
        return True

class _UniffiConverterTypeProductData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProductData(
            id=_UniffiConverterString.read(buf),
            stall_id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            images=_UniffiConverterOptionalSequenceString.read(buf),
            currency=_UniffiConverterString.read(buf),
            price=_UniffiConverterDouble.read(buf),
            quantity=_UniffiConverterUInt64.read(buf),
            specs=_UniffiConverterOptionalSequenceSequenceString.read(buf),
            shipping=_UniffiConverterSequenceTypeShippingCost.read(buf),
            categories=_UniffiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.stall_id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalSequenceString.check_lower(value.images)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterDouble.check_lower(value.price)
        _UniffiConverterUInt64.check_lower(value.quantity)
        _UniffiConverterOptionalSequenceSequenceString.check_lower(value.specs)
        _UniffiConverterSequenceTypeShippingCost.check_lower(value.shipping)
        _UniffiConverterOptionalSequenceString.check_lower(value.categories)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.stall_id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalSequenceString.write(value.images, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterDouble.write(value.price, buf)
        _UniffiConverterUInt64.write(value.quantity, buf)
        _UniffiConverterOptionalSequenceSequenceString.write(value.specs, buf)
        _UniffiConverterSequenceTypeShippingCost.write(value.shipping, buf)
        _UniffiConverterOptionalSequenceString.write(value.categories, buf)


class ShippingCost:
    """Delivery cost for shipping method as defined by the merchant in the product"""

    id: "str"
    """Id of the shipping method"""

    cost: "float"
    """Cost to use this shipping method"""

    @typing.no_type_check
    def __init__(self, id: "str", cost: "float"):
        self.id = id
        self.cost = cost

    def __str__(self):
        return "ShippingCost(id={}, cost={})".format(self.id, self.cost)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.cost != other.cost:
            return False
        return True

class _UniffiConverterTypeShippingCost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ShippingCost(
            id=_UniffiConverterString.read(buf),
            cost=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterDouble.check_lower(value.cost)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterDouble.write(value.cost, buf)


class StallData:
    """Payload for creating or updating stall"""

    id: "str"
    """UUID of the stall generated by merchant"""

    name: "str"
    """Stall name"""

    description: "typing.Optional[str]"
    """Stall description"""

    currency: "str"
    """Currency used"""

    shipping: "typing.List[ShippingMethod]"
    """Available shipping methods"""

    @typing.no_type_check
    def __init__(self, id: "str", name: "str", description: "typing.Optional[str]", currency: "str", shipping: "typing.List[ShippingMethod]"):
        self.id = id
        self.name = name
        self.description = description
        self.currency = currency
        self.shipping = shipping

    def __str__(self):
        return "StallData(id={}, name={}, description={}, currency={}, shipping={})".format(self.id, self.name, self.description, self.currency, self.shipping)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.currency != other.currency:
            return False
        if self.shipping != other.shipping:
            return False
        return True

class _UniffiConverterTypeStallData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StallData(
            id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            currency=_UniffiConverterString.read(buf),
            shipping=_UniffiConverterSequenceTypeShippingMethod.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterSequenceTypeShippingMethod.check_lower(value.shipping)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterSequenceTypeShippingMethod.write(value.shipping, buf)





class Alphabet(enum.Enum):
    A = 1
    
    B = 2
    
    C = 3
    
    D = 4
    
    E = 5
    
    F = 6
    
    G = 7
    
    H = 8
    
    I = 9
    
    J = 10
    
    K = 11
    
    L = 12
    
    M = 13
    
    N = 14
    
    O = 15
    
    P = 16
    
    Q = 17
    
    R = 18
    
    S = 19
    
    T = 20
    
    U = 21
    
    V = 22
    
    W = 23
    
    X = 24
    
    Y = 25
    
    Z = 26
    


class _UniffiConverterTypeAlphabet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Alphabet.A
        if variant == 2:
            return Alphabet.B
        if variant == 3:
            return Alphabet.C
        if variant == 4:
            return Alphabet.D
        if variant == 5:
            return Alphabet.E
        if variant == 6:
            return Alphabet.F
        if variant == 7:
            return Alphabet.G
        if variant == 8:
            return Alphabet.H
        if variant == 9:
            return Alphabet.I
        if variant == 10:
            return Alphabet.J
        if variant == 11:
            return Alphabet.K
        if variant == 12:
            return Alphabet.L
        if variant == 13:
            return Alphabet.M
        if variant == 14:
            return Alphabet.N
        if variant == 15:
            return Alphabet.O
        if variant == 16:
            return Alphabet.P
        if variant == 17:
            return Alphabet.Q
        if variant == 18:
            return Alphabet.R
        if variant == 19:
            return Alphabet.S
        if variant == 20:
            return Alphabet.T
        if variant == 21:
            return Alphabet.U
        if variant == 22:
            return Alphabet.V
        if variant == 23:
            return Alphabet.W
        if variant == 24:
            return Alphabet.X
        if variant == 25:
            return Alphabet.Y
        if variant == 26:
            return Alphabet.Z
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Alphabet.A:
            return
        if value == Alphabet.B:
            return
        if value == Alphabet.C:
            return
        if value == Alphabet.D:
            return
        if value == Alphabet.E:
            return
        if value == Alphabet.F:
            return
        if value == Alphabet.G:
            return
        if value == Alphabet.H:
            return
        if value == Alphabet.I:
            return
        if value == Alphabet.J:
            return
        if value == Alphabet.K:
            return
        if value == Alphabet.L:
            return
        if value == Alphabet.M:
            return
        if value == Alphabet.N:
            return
        if value == Alphabet.O:
            return
        if value == Alphabet.P:
            return
        if value == Alphabet.Q:
            return
        if value == Alphabet.R:
            return
        if value == Alphabet.S:
            return
        if value == Alphabet.T:
            return
        if value == Alphabet.U:
            return
        if value == Alphabet.V:
            return
        if value == Alphabet.W:
            return
        if value == Alphabet.X:
            return
        if value == Alphabet.Y:
            return
        if value == Alphabet.Z:
            return

    @staticmethod
    def write(value, buf):
        if value == Alphabet.A:
            buf.write_i32(1)
        if value == Alphabet.B:
            buf.write_i32(2)
        if value == Alphabet.C:
            buf.write_i32(3)
        if value == Alphabet.D:
            buf.write_i32(4)
        if value == Alphabet.E:
            buf.write_i32(5)
        if value == Alphabet.F:
            buf.write_i32(6)
        if value == Alphabet.G:
            buf.write_i32(7)
        if value == Alphabet.H:
            buf.write_i32(8)
        if value == Alphabet.I:
            buf.write_i32(9)
        if value == Alphabet.J:
            buf.write_i32(10)
        if value == Alphabet.K:
            buf.write_i32(11)
        if value == Alphabet.L:
            buf.write_i32(12)
        if value == Alphabet.M:
            buf.write_i32(13)
        if value == Alphabet.N:
            buf.write_i32(14)
        if value == Alphabet.O:
            buf.write_i32(15)
        if value == Alphabet.P:
            buf.write_i32(16)
        if value == Alphabet.Q:
            buf.write_i32(17)
        if value == Alphabet.R:
            buf.write_i32(18)
        if value == Alphabet.S:
            buf.write_i32(19)
        if value == Alphabet.T:
            buf.write_i32(20)
        if value == Alphabet.U:
            buf.write_i32(21)
        if value == Alphabet.V:
            buf.write_i32(22)
        if value == Alphabet.W:
            buf.write_i32(23)
        if value == Alphabet.X:
            buf.write_i32(24)
        if value == Alphabet.Y:
            buf.write_i32(25)
        if value == Alphabet.Z:
            buf.write_i32(26)






class ClientMessage:
    """Messages sent by clients, received by relays"""

    def __init__(self):
        raise RuntimeError("ClientMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_MSG:
        event: "Event"

        @typing.no_type_check
        def __init__(self,event: "Event"):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.EVENT_MSG(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_event_msg():
                return False
            if self.event != other.event:
                return False
            return True
    class REQ:
        subscription_id: "str"
        filters: "typing.List[Filter]"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filters: "typing.List[Filter]"):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.REQ(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_req():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class COUNT:
        subscription_id: "str"
        filters: "typing.List[Filter]"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filters: "typing.List[Filter]"):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.COUNT(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class CLOSE:
        subscription_id: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "ClientMessage.CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_close():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class AUTH:
        event: "Event"

        @typing.no_type_check
        def __init__(self,event: "Event"):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.AUTH(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.event != other.event:
                return False
            return True
    class NEG_OPEN:
        """Negentropy Open"""

        subscription_id: "str"
        filter: "Filter"
        id_size: "int"
        """ID size (MUST be between 8 and 32, inclusive)"""

        initial_message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", filter: "Filter", id_size: "int", initial_message: "str"):
            
            self.subscription_id = subscription_id
            self.filter = filter
            self.id_size = id_size
            self.initial_message = initial_message
            

        def __str__(self):
            return "ClientMessage.NEG_OPEN(subscription_id={}, filter={}, id_size={}, initial_message={})".format(self.subscription_id, self.filter, self.id_size, self.initial_message)

        def __eq__(self, other):
            if not other.is_neg_open():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filter != other.filter:
                return False
            if self.id_size != other.id_size:
                return False
            if self.initial_message != other.initial_message:
                return False
            return True
    class NEG_MSG:
        """Negentropy Message"""

        subscription_id: "str"
        message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "ClientMessage.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_neg_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class NEG_CLOSE:
        """Negentropy Close"""

        subscription_id: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "ClientMessage.NEG_CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_neg_close():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_event_msg(self) -> bool:
        return isinstance(self, ClientMessage.EVENT_MSG)
    def is_req(self) -> bool:
        return isinstance(self, ClientMessage.REQ)
    def is_count(self) -> bool:
        return isinstance(self, ClientMessage.COUNT)
    def is_close(self) -> bool:
        return isinstance(self, ClientMessage.CLOSE)
    def is_auth(self) -> bool:
        return isinstance(self, ClientMessage.AUTH)
    def is_neg_open(self) -> bool:
        return isinstance(self, ClientMessage.NEG_OPEN)
    def is_neg_msg(self) -> bool:
        return isinstance(self, ClientMessage.NEG_MSG)
    def is_neg_close(self) -> bool:
        return isinstance(self, ClientMessage.NEG_CLOSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClientMessage.EVENT_MSG = type("ClientMessage.EVENT_MSG", (ClientMessage.EVENT_MSG, ClientMessage,), {})  # type: ignore
ClientMessage.REQ = type("ClientMessage.REQ", (ClientMessage.REQ, ClientMessage,), {})  # type: ignore
ClientMessage.COUNT = type("ClientMessage.COUNT", (ClientMessage.COUNT, ClientMessage,), {})  # type: ignore
ClientMessage.CLOSE = type("ClientMessage.CLOSE", (ClientMessage.CLOSE, ClientMessage,), {})  # type: ignore
ClientMessage.AUTH = type("ClientMessage.AUTH", (ClientMessage.AUTH, ClientMessage,), {})  # type: ignore
ClientMessage.NEG_OPEN = type("ClientMessage.NEG_OPEN", (ClientMessage.NEG_OPEN, ClientMessage,), {})  # type: ignore
ClientMessage.NEG_MSG = type("ClientMessage.NEG_MSG", (ClientMessage.NEG_MSG, ClientMessage,), {})  # type: ignore
ClientMessage.NEG_CLOSE = type("ClientMessage.NEG_CLOSE", (ClientMessage.NEG_CLOSE, ClientMessage,), {})  # type: ignore




class _UniffiConverterTypeClientMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClientMessage.EVENT_MSG(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 2:
            return ClientMessage.REQ(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeFilter.read(buf),
            )
        if variant == 3:
            return ClientMessage.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeFilter.read(buf),
            )
        if variant == 4:
            return ClientMessage.CLOSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ClientMessage.AUTH(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 6:
            return ClientMessage.NEG_OPEN(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeFilter.read(buf),
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ClientMessage.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ClientMessage.NEG_CLOSE(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_event_msg():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_req():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterSequenceTypeFilter.check_lower(value.filters)
            return
        if value.is_count():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterSequenceTypeFilter.check_lower(value.filters)
            return
        if value.is_close():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        if value.is_auth():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_neg_open():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeFilter.check_lower(value.filter)
            _UniffiConverterUInt8.check_lower(value.id_size)
            _UniffiConverterString.check_lower(value.initial_message)
            return
        if value.is_neg_msg():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_neg_close():
            _UniffiConverterString.check_lower(value.subscription_id)
            return

    @staticmethod
    def write(value, buf):
        if value.is_event_msg():
            buf.write_i32(1)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_req():
            buf.write_i32(2)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceTypeFilter.write(value.filters, buf)
        if value.is_count():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterSequenceTypeFilter.write(value.filters, buf)
        if value.is_close():
            buf.write_i32(4)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_auth():
            buf.write_i32(5)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_neg_open():
            buf.write_i32(6)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeFilter.write(value.filter, buf)
            _UniffiConverterUInt8.write(value.id_size, buf)
            _UniffiConverterString.write(value.initial_message, buf)
        if value.is_neg_msg():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_neg_close():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)






class DataVendingMachineStatus(enum.Enum):
    PAYMENT_REQUIRED = 1
    
    PROCESSING = 2
    
    ERROR = 3
    
    SUCCESS = 4
    
    PARTIAL = 5
    


class _UniffiConverterTypeDataVendingMachineStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DataVendingMachineStatus.PAYMENT_REQUIRED
        if variant == 2:
            return DataVendingMachineStatus.PROCESSING
        if variant == 3:
            return DataVendingMachineStatus.ERROR
        if variant == 4:
            return DataVendingMachineStatus.SUCCESS
        if variant == 5:
            return DataVendingMachineStatus.PARTIAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DataVendingMachineStatus.PAYMENT_REQUIRED:
            return
        if value == DataVendingMachineStatus.PROCESSING:
            return
        if value == DataVendingMachineStatus.ERROR:
            return
        if value == DataVendingMachineStatus.SUCCESS:
            return
        if value == DataVendingMachineStatus.PARTIAL:
            return

    @staticmethod
    def write(value, buf):
        if value == DataVendingMachineStatus.PAYMENT_REQUIRED:
            buf.write_i32(1)
        if value == DataVendingMachineStatus.PROCESSING:
            buf.write_i32(2)
        if value == DataVendingMachineStatus.ERROR:
            buf.write_i32(3)
        if value == DataVendingMachineStatus.SUCCESS:
            buf.write_i32(4)
        if value == DataVendingMachineStatus.PARTIAL:
            buf.write_i32(5)






class ExternalIdentity(enum.Enum):
    """Supported external identity providers"""

    GIT_HUB = 1
    """github.com"""

    
    TWITTER = 2
    """twitter.com"""

    
    MASTODON = 3
    """mastodon.social"""

    
    TELEGRAM = 4
    """telegram.org"""

    


class _UniffiConverterTypeExternalIdentity(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExternalIdentity.GIT_HUB
        if variant == 2:
            return ExternalIdentity.TWITTER
        if variant == 3:
            return ExternalIdentity.MASTODON
        if variant == 4:
            return ExternalIdentity.TELEGRAM
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ExternalIdentity.GIT_HUB:
            return
        if value == ExternalIdentity.TWITTER:
            return
        if value == ExternalIdentity.MASTODON:
            return
        if value == ExternalIdentity.TELEGRAM:
            return

    @staticmethod
    def write(value, buf):
        if value == ExternalIdentity.GIT_HUB:
            buf.write_i32(1)
        if value == ExternalIdentity.TWITTER:
            buf.write_i32(2)
        if value == ExternalIdentity.MASTODON:
            buf.write_i32(3)
        if value == ExternalIdentity.TELEGRAM:
            buf.write_i32(4)






class HttpMethod(enum.Enum):
    GET = 1
    
    POST = 2
    
    PUT = 3
    
    PATCH = 4
    


class _UniffiConverterTypeHttpMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HttpMethod.GET
        if variant == 2:
            return HttpMethod.POST
        if variant == 3:
            return HttpMethod.PUT
        if variant == 4:
            return HttpMethod.PATCH
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == HttpMethod.GET:
            return
        if value == HttpMethod.POST:
            return
        if value == HttpMethod.PUT:
            return
        if value == HttpMethod.PATCH:
            return

    @staticmethod
    def write(value, buf):
        if value == HttpMethod.GET:
            buf.write_i32(1)
        if value == HttpMethod.POST:
            buf.write_i32(2)
        if value == HttpMethod.PUT:
            buf.write_i32(3)
        if value == HttpMethod.PATCH:
            buf.write_i32(4)






class JsonValue:
    def __init__(self):
        raise RuntimeError("JsonValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL:
        bool: "bool"

        @typing.no_type_check
        def __init__(self,bool: "bool"):
            
            self.bool = bool
            

        def __str__(self):
            return "JsonValue.BOOL(bool={})".format(self.bool)

        def __eq__(self, other):
            if not other.is_bool():
                return False
            if self.bool != other.bool:
                return False
            return True
    class NUMBER_POS_INT:
        number: "int"

        @typing.no_type_check
        def __init__(self,number: "int"):
            
            self.number = number
            

        def __str__(self):
            return "JsonValue.NUMBER_POS_INT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_number_pos_int():
                return False
            if self.number != other.number:
                return False
            return True
    class NUMBER_NEG_INT:
        number: "int"

        @typing.no_type_check
        def __init__(self,number: "int"):
            
            self.number = number
            

        def __str__(self):
            return "JsonValue.NUMBER_NEG_INT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_number_neg_int():
                return False
            if self.number != other.number:
                return False
            return True
    class NUMBER_FLOAT:
        number: "float"

        @typing.no_type_check
        def __init__(self,number: "float"):
            
            self.number = number
            

        def __str__(self):
            return "JsonValue.NUMBER_FLOAT(number={})".format(self.number)

        def __eq__(self, other):
            if not other.is_number_float():
                return False
            if self.number != other.number:
                return False
            return True
    class STR:
        s: "str"

        @typing.no_type_check
        def __init__(self,s: "str"):
            
            self.s = s
            

        def __str__(self):
            return "JsonValue.STR(s={})".format(self.s)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.s != other.s:
                return False
            return True
    class ARRAY:
        array: "typing.List[JsonValue]"

        @typing.no_type_check
        def __init__(self,array: "typing.List[JsonValue]"):
            
            self.array = array
            

        def __str__(self):
            return "JsonValue.ARRAY(array={})".format(self.array)

        def __eq__(self, other):
            if not other.is_array():
                return False
            if self.array != other.array:
                return False
            return True
    class OBJECT:
        map: "dict"

        @typing.no_type_check
        def __init__(self,map: "dict"):
            
            self.map = map
            

        def __str__(self):
            return "JsonValue.OBJECT(map={})".format(self.map)

        def __eq__(self, other):
            if not other.is_object():
                return False
            if self.map != other.map:
                return False
            return True
    class NULL:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "JsonValue.NULL()".format()

        def __eq__(self, other):
            if not other.is_null():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bool(self) -> bool:
        return isinstance(self, JsonValue.BOOL)
    def is_number_pos_int(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_POS_INT)
    def is_number_neg_int(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_NEG_INT)
    def is_number_float(self) -> bool:
        return isinstance(self, JsonValue.NUMBER_FLOAT)
    def is_str(self) -> bool:
        return isinstance(self, JsonValue.STR)
    def is_array(self) -> bool:
        return isinstance(self, JsonValue.ARRAY)
    def is_object(self) -> bool:
        return isinstance(self, JsonValue.OBJECT)
    def is_null(self) -> bool:
        return isinstance(self, JsonValue.NULL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
JsonValue.BOOL = type("JsonValue.BOOL", (JsonValue.BOOL, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_POS_INT = type("JsonValue.NUMBER_POS_INT", (JsonValue.NUMBER_POS_INT, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_NEG_INT = type("JsonValue.NUMBER_NEG_INT", (JsonValue.NUMBER_NEG_INT, JsonValue,), {})  # type: ignore
JsonValue.NUMBER_FLOAT = type("JsonValue.NUMBER_FLOAT", (JsonValue.NUMBER_FLOAT, JsonValue,), {})  # type: ignore
JsonValue.STR = type("JsonValue.STR", (JsonValue.STR, JsonValue,), {})  # type: ignore
JsonValue.ARRAY = type("JsonValue.ARRAY", (JsonValue.ARRAY, JsonValue,), {})  # type: ignore
JsonValue.OBJECT = type("JsonValue.OBJECT", (JsonValue.OBJECT, JsonValue,), {})  # type: ignore
JsonValue.NULL = type("JsonValue.NULL", (JsonValue.NULL, JsonValue,), {})  # type: ignore




class _UniffiConverterTypeJsonValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JsonValue.BOOL(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return JsonValue.NUMBER_POS_INT(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return JsonValue.NUMBER_NEG_INT(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 4:
            return JsonValue.NUMBER_FLOAT(
                _UniffiConverterDouble.read(buf),
            )
        if variant == 5:
            return JsonValue.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return JsonValue.ARRAY(
                _UniffiConverterSequenceTypeJsonValue.read(buf),
            )
        if variant == 7:
            return JsonValue.OBJECT(
                _UniffiConverterMapStringTypeJsonValue.read(buf),
            )
        if variant == 8:
            return JsonValue.NULL(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bool():
            _UniffiConverterBool.check_lower(value.bool)
            return
        if value.is_number_pos_int():
            _UniffiConverterUInt64.check_lower(value.number)
            return
        if value.is_number_neg_int():
            _UniffiConverterInt64.check_lower(value.number)
            return
        if value.is_number_float():
            _UniffiConverterDouble.check_lower(value.number)
            return
        if value.is_str():
            _UniffiConverterString.check_lower(value.s)
            return
        if value.is_array():
            _UniffiConverterSequenceTypeJsonValue.check_lower(value.array)
            return
        if value.is_object():
            _UniffiConverterMapStringTypeJsonValue.check_lower(value.map)
            return
        if value.is_null():
            return

    @staticmethod
    def write(value, buf):
        if value.is_bool():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.bool, buf)
        if value.is_number_pos_int():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.number, buf)
        if value.is_number_neg_int():
            buf.write_i32(3)
            _UniffiConverterInt64.write(value.number, buf)
        if value.is_number_float():
            buf.write_i32(4)
            _UniffiConverterDouble.write(value.number, buf)
        if value.is_str():
            buf.write_i32(5)
            _UniffiConverterString.write(value.s, buf)
        if value.is_array():
            buf.write_i32(6)
            _UniffiConverterSequenceTypeJsonValue.write(value.array, buf)
        if value.is_object():
            buf.write_i32(7)
            _UniffiConverterMapStringTypeJsonValue.write(value.map, buf)
        if value.is_null():
            buf.write_i32(8)






class LiveEventMarker(enum.Enum):
    """Live Event Marker"""

    HOST = 1
    """Host"""

    
    SPEAKER = 2
    """Speaker"""

    
    PARTICIPANT = 3
    """Participant"""

    


class _UniffiConverterTypeLiveEventMarker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventMarker.HOST
        if variant == 2:
            return LiveEventMarker.SPEAKER
        if variant == 3:
            return LiveEventMarker.PARTICIPANT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LiveEventMarker.HOST:
            return
        if value == LiveEventMarker.SPEAKER:
            return
        if value == LiveEventMarker.PARTICIPANT:
            return

    @staticmethod
    def write(value, buf):
        if value == LiveEventMarker.HOST:
            buf.write_i32(1)
        if value == LiveEventMarker.SPEAKER:
            buf.write_i32(2)
        if value == LiveEventMarker.PARTICIPANT:
            buf.write_i32(3)






class LiveEventStatus:
    def __init__(self):
        raise RuntimeError("LiveEventStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PLANNED:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LiveEventStatus.PLANNED()".format()

        def __eq__(self, other):
            if not other.is_planned():
                return False
            return True
    class LIVE:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LiveEventStatus.LIVE()".format()

        def __eq__(self, other):
            if not other.is_live():
                return False
            return True
    class ENDED:

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LiveEventStatus.ENDED()".format()

        def __eq__(self, other):
            if not other.is_ended():
                return False
            return True
    class CUSTOM:
        custom: "str"

        @typing.no_type_check
        def __init__(self,custom: "str"):
            
            self.custom = custom
            

        def __str__(self):
            return "LiveEventStatus.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.custom != other.custom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_planned(self) -> bool:
        return isinstance(self, LiveEventStatus.PLANNED)
    def is_live(self) -> bool:
        return isinstance(self, LiveEventStatus.LIVE)
    def is_ended(self) -> bool:
        return isinstance(self, LiveEventStatus.ENDED)
    def is_custom(self) -> bool:
        return isinstance(self, LiveEventStatus.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LiveEventStatus.PLANNED = type("LiveEventStatus.PLANNED", (LiveEventStatus.PLANNED, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.LIVE = type("LiveEventStatus.LIVE", (LiveEventStatus.LIVE, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.ENDED = type("LiveEventStatus.ENDED", (LiveEventStatus.ENDED, LiveEventStatus,), {})  # type: ignore
LiveEventStatus.CUSTOM = type("LiveEventStatus.CUSTOM", (LiveEventStatus.CUSTOM, LiveEventStatus,), {})  # type: ignore




class _UniffiConverterTypeLiveEventStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventStatus.PLANNED(
            )
        if variant == 2:
            return LiveEventStatus.LIVE(
            )
        if variant == 3:
            return LiveEventStatus.ENDED(
            )
        if variant == 4:
            return LiveEventStatus.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_planned():
            return
        if value.is_live():
            return
        if value.is_ended():
            return
        if value.is_custom():
            _UniffiConverterString.check_lower(value.custom)
            return

    @staticmethod
    def write(value, buf):
        if value.is_planned():
            buf.write_i32(1)
        if value.is_live():
            buf.write_i32(2)
        if value.is_ended():
            buf.write_i32(3)
        if value.is_custom():
            buf.write_i32(4)
            _UniffiConverterString.write(value.custom, buf)






class Marker:
    """Marker"""

    def __init__(self):
        raise RuntimeError("Marker cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ROOT:
        """Root"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Marker.ROOT()".format()

        def __eq__(self, other):
            if not other.is_root():
                return False
            return True
    class REPLY:
        """Reply"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Marker.REPLY()".format()

        def __eq__(self, other):
            if not other.is_reply():
                return False
            return True
    class CUSTOM:
        """Custom"""

        custom: "str"

        @typing.no_type_check
        def __init__(self,custom: "str"):
            
            self.custom = custom
            

        def __str__(self):
            return "Marker.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.custom != other.custom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_root(self) -> bool:
        return isinstance(self, Marker.ROOT)
    def is_reply(self) -> bool:
        return isinstance(self, Marker.REPLY)
    def is_custom(self) -> bool:
        return isinstance(self, Marker.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Marker.ROOT = type("Marker.ROOT", (Marker.ROOT, Marker,), {})  # type: ignore
Marker.REPLY = type("Marker.REPLY", (Marker.REPLY, Marker,), {})  # type: ignore
Marker.CUSTOM = type("Marker.CUSTOM", (Marker.CUSTOM, Marker,), {})  # type: ignore




class _UniffiConverterTypeMarker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Marker.ROOT(
            )
        if variant == 2:
            return Marker.REPLY(
            )
        if variant == 3:
            return Marker.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_root():
            return
        if value.is_reply():
            return
        if value.is_custom():
            _UniffiConverterString.check_lower(value.custom)
            return

    @staticmethod
    def write(value, buf):
        if value.is_root():
            buf.write_i32(1)
        if value.is_reply():
            buf.write_i32(2)
        if value.is_custom():
            buf.write_i32(3)
            _UniffiConverterString.write(value.custom, buf)






class Nip44Version(enum.Enum):
    """NIP44 Version"""

    DEPRECATED = 1
    """V1 (deprecated)"""

    
    V2 = 2
    """V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64"""

    


class _UniffiConverterTypeNip44Version(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Nip44Version.DEPRECATED
        if variant == 2:
            return Nip44Version.V2
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Nip44Version.DEPRECATED:
            return
        if value == Nip44Version.V2:
            return

    @staticmethod
    def write(value, buf):
        if value == Nip44Version.DEPRECATED:
            buf.write_i32(1)
        if value == Nip44Version.V2:
            buf.write_i32(2)






class NostrConnectMessage:
    def __init__(self):
        raise RuntimeError("NostrConnectMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class REQUEST:
        id: "str"
        method: "str"
        params: "typing.List[JsonValue]"

        @typing.no_type_check
        def __init__(self,id: "str", method: "str", params: "typing.List[JsonValue]"):
            
            self.id = id
            self.method = method
            self.params = params
            

        def __str__(self):
            return "NostrConnectMessage.REQUEST(id={}, method={}, params={})".format(self.id, self.method, self.params)

        def __eq__(self, other):
            if not other.is_request():
                return False
            if self.id != other.id:
                return False
            if self.method != other.method:
                return False
            if self.params != other.params:
                return False
            return True
    class RESPONSE:
        id: "str"
        result: "typing.Optional[JsonValue]"
        error: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,id: "str", result: "typing.Optional[JsonValue]", error: "typing.Optional[str]"):
            
            self.id = id
            self.result = result
            self.error = error
            

        def __str__(self):
            return "NostrConnectMessage.RESPONSE(id={}, result={}, error={})".format(self.id, self.result, self.error)

        def __eq__(self, other):
            if not other.is_response():
                return False
            if self.id != other.id:
                return False
            if self.result != other.result:
                return False
            if self.error != other.error:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_request(self) -> bool:
        return isinstance(self, NostrConnectMessage.REQUEST)
    def is_response(self) -> bool:
        return isinstance(self, NostrConnectMessage.RESPONSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NostrConnectMessage.REQUEST = type("NostrConnectMessage.REQUEST", (NostrConnectMessage.REQUEST, NostrConnectMessage,), {})  # type: ignore
NostrConnectMessage.RESPONSE = type("NostrConnectMessage.RESPONSE", (NostrConnectMessage.RESPONSE, NostrConnectMessage,), {})  # type: ignore




class _UniffiConverterTypeNostrConnectMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrConnectMessage.REQUEST(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterSequenceTypeJsonValue.read(buf),
            )
        if variant == 2:
            return NostrConnectMessage.RESPONSE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeJsonValue.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_request():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterString.check_lower(value.method)
            _UniffiConverterSequenceTypeJsonValue.check_lower(value.params)
            return
        if value.is_response():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterOptionalTypeJsonValue.check_lower(value.result)
            _UniffiConverterOptionalString.check_lower(value.error)
            return

    @staticmethod
    def write(value, buf):
        if value.is_request():
            buf.write_i32(1)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterString.write(value.method, buf)
            _UniffiConverterSequenceTypeJsonValue.write(value.params, buf)
        if value.is_response():
            buf.write_i32(2)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterOptionalTypeJsonValue.write(value.result, buf)
            _UniffiConverterOptionalString.write(value.error, buf)



# NostrError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NostrError(Exception):
    pass

_UniffiTempNostrError = NostrError

class NostrError:  # type: ignore
    class Generic(_UniffiTempNostrError):

        def __init__(self, err):
            super().__init__(", ".join([
                "err={!r}".format(err),
            ]))
            self.err = err
        def __repr__(self):
            return "NostrError.Generic({})".format(str(self))
    _UniffiTempNostrError.Generic = Generic # type: ignore

NostrError = _UniffiTempNostrError # type: ignore
del _UniffiTempNostrError


class _UniffiConverterTypeNostrError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NostrError.Generic(
                err=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, NostrError.Generic):
            _UniffiConverterString.check_lower(value.err)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, NostrError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value.err, buf)





class Protocol:
    """NIP48 Proxy Protocol"""

    def __init__(self):
        raise RuntimeError("Protocol cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACTIVITY_PUB:
        """ActivityPub"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.ACTIVITY_PUB()".format()

        def __eq__(self, other):
            if not other.is_activity_pub():
                return False
            return True
    class AT_PROTO:
        """AT Protocol"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.AT_PROTO()".format()

        def __eq__(self, other):
            if not other.is_at_proto():
                return False
            return True
    class RSS:
        """Rss"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.RSS()".format()

        def __eq__(self, other):
            if not other.is_rss():
                return False
            return True
    class WEB:
        """Web"""


        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Protocol.WEB()".format()

        def __eq__(self, other):
            if not other.is_web():
                return False
            return True
    class CUSTOM:
        """Custom"""

        custom: "str"

        @typing.no_type_check
        def __init__(self,custom: "str"):
            
            self.custom = custom
            

        def __str__(self):
            return "Protocol.CUSTOM(custom={})".format(self.custom)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.custom != other.custom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_activity_pub(self) -> bool:
        return isinstance(self, Protocol.ACTIVITY_PUB)
    def is_at_proto(self) -> bool:
        return isinstance(self, Protocol.AT_PROTO)
    def is_rss(self) -> bool:
        return isinstance(self, Protocol.RSS)
    def is_web(self) -> bool:
        return isinstance(self, Protocol.WEB)
    def is_custom(self) -> bool:
        return isinstance(self, Protocol.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Protocol.ACTIVITY_PUB = type("Protocol.ACTIVITY_PUB", (Protocol.ACTIVITY_PUB, Protocol,), {})  # type: ignore
Protocol.AT_PROTO = type("Protocol.AT_PROTO", (Protocol.AT_PROTO, Protocol,), {})  # type: ignore
Protocol.RSS = type("Protocol.RSS", (Protocol.RSS, Protocol,), {})  # type: ignore
Protocol.WEB = type("Protocol.WEB", (Protocol.WEB, Protocol,), {})  # type: ignore
Protocol.CUSTOM = type("Protocol.CUSTOM", (Protocol.CUSTOM, Protocol,), {})  # type: ignore




class _UniffiConverterTypeProtocol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Protocol.ACTIVITY_PUB(
            )
        if variant == 2:
            return Protocol.AT_PROTO(
            )
        if variant == 3:
            return Protocol.RSS(
            )
        if variant == 4:
            return Protocol.WEB(
            )
        if variant == 5:
            return Protocol.CUSTOM(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_activity_pub():
            return
        if value.is_at_proto():
            return
        if value.is_rss():
            return
        if value.is_web():
            return
        if value.is_custom():
            _UniffiConverterString.check_lower(value.custom)
            return

    @staticmethod
    def write(value, buf):
        if value.is_activity_pub():
            buf.write_i32(1)
        if value.is_at_proto():
            buf.write_i32(2)
        if value.is_rss():
            buf.write_i32(3)
        if value.is_web():
            buf.write_i32(4)
        if value.is_custom():
            buf.write_i32(5)
            _UniffiConverterString.write(value.custom, buf)






class RelayMessage:
    def __init__(self):
        raise RuntimeError("RelayMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EVENT_MSG:
        subscription_id: "str"
        event: "Event"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", event: "Event"):
            
            self.subscription_id = subscription_id
            self.event = event
            

        def __str__(self):
            return "RelayMessage.EVENT_MSG(subscription_id={}, event={})".format(self.subscription_id, self.event)

        def __eq__(self, other):
            if not other.is_event_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.event != other.event:
                return False
            return True
    class OK:
        event_id: "EventId"
        status: "bool"
        message: "str"

        @typing.no_type_check
        def __init__(self,event_id: "EventId", status: "bool", message: "str"):
            
            self.event_id = event_id
            self.status = status
            self.message = message
            

        def __str__(self):
            return "RelayMessage.OK(event_id={}, status={}, message={})".format(self.event_id, self.status, self.message)

        def __eq__(self, other):
            if not other.is_ok():
                return False
            if self.event_id != other.event_id:
                return False
            if self.status != other.status:
                return False
            if self.message != other.message:
                return False
            return True
    class END_OF_STORED_EVENTS:
        subscription_id: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str"):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "RelayMessage.END_OF_STORED_EVENTS(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_end_of_stored_events():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class NOTICE:
        message: "str"

        @typing.no_type_check
        def __init__(self,message: "str"):
            
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NOTICE(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_notice():
                return False
            if self.message != other.message:
                return False
            return True
    class CLOSED:
        subscription_id: "str"
        message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "RelayMessage.CLOSED(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_closed():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class AUTH:
        challenge: "str"

        @typing.no_type_check
        def __init__(self,challenge: "str"):
            
            self.challenge = challenge
            

        def __str__(self):
            return "RelayMessage.AUTH(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class COUNT:
        subscription_id: "str"
        count: "int"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", count: "int"):
            
            self.subscription_id = subscription_id
            self.count = count
            

        def __str__(self):
            return "RelayMessage.COUNT(subscription_id={}, count={})".format(self.subscription_id, self.count)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.count != other.count:
                return False
            return True
    class NEG_MSG:
        subscription_id: "str"
        message: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", message: "str"):
            
            self.subscription_id = subscription_id
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NEG_MSG(subscription_id={}, message={})".format(self.subscription_id, self.message)

        def __eq__(self, other):
            if not other.is_neg_msg():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.message != other.message:
                return False
            return True
    class NEG_ERR:
        subscription_id: "str"
        code: "str"

        @typing.no_type_check
        def __init__(self,subscription_id: "str", code: "str"):
            
            self.subscription_id = subscription_id
            self.code = code
            

        def __str__(self):
            return "RelayMessage.NEG_ERR(subscription_id={}, code={})".format(self.subscription_id, self.code)

        def __eq__(self, other):
            if not other.is_neg_err():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.code != other.code:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_event_msg(self) -> bool:
        return isinstance(self, RelayMessage.EVENT_MSG)
    def is_ok(self) -> bool:
        return isinstance(self, RelayMessage.OK)
    def is_end_of_stored_events(self) -> bool:
        return isinstance(self, RelayMessage.END_OF_STORED_EVENTS)
    def is_notice(self) -> bool:
        return isinstance(self, RelayMessage.NOTICE)
    def is_closed(self) -> bool:
        return isinstance(self, RelayMessage.CLOSED)
    def is_auth(self) -> bool:
        return isinstance(self, RelayMessage.AUTH)
    def is_count(self) -> bool:
        return isinstance(self, RelayMessage.COUNT)
    def is_neg_msg(self) -> bool:
        return isinstance(self, RelayMessage.NEG_MSG)
    def is_neg_err(self) -> bool:
        return isinstance(self, RelayMessage.NEG_ERR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RelayMessage.EVENT_MSG = type("RelayMessage.EVENT_MSG", (RelayMessage.EVENT_MSG, RelayMessage,), {})  # type: ignore
RelayMessage.OK = type("RelayMessage.OK", (RelayMessage.OK, RelayMessage,), {})  # type: ignore
RelayMessage.END_OF_STORED_EVENTS = type("RelayMessage.END_OF_STORED_EVENTS", (RelayMessage.END_OF_STORED_EVENTS, RelayMessage,), {})  # type: ignore
RelayMessage.NOTICE = type("RelayMessage.NOTICE", (RelayMessage.NOTICE, RelayMessage,), {})  # type: ignore
RelayMessage.CLOSED = type("RelayMessage.CLOSED", (RelayMessage.CLOSED, RelayMessage,), {})  # type: ignore
RelayMessage.AUTH = type("RelayMessage.AUTH", (RelayMessage.AUTH, RelayMessage,), {})  # type: ignore
RelayMessage.COUNT = type("RelayMessage.COUNT", (RelayMessage.COUNT, RelayMessage,), {})  # type: ignore
RelayMessage.NEG_MSG = type("RelayMessage.NEG_MSG", (RelayMessage.NEG_MSG, RelayMessage,), {})  # type: ignore
RelayMessage.NEG_ERR = type("RelayMessage.NEG_ERR", (RelayMessage.NEG_ERR, RelayMessage,), {})  # type: ignore




class _UniffiConverterTypeRelayMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMessage.EVENT_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 2:
            return RelayMessage.OK(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterBool.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RelayMessage.END_OF_STORED_EVENTS(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return RelayMessage.NOTICE(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return RelayMessage.CLOSED(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return RelayMessage.AUTH(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return RelayMessage.COUNT(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 8:
            return RelayMessage.NEG_MSG(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return RelayMessage.NEG_ERR(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_event_msg():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_ok():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterBool.check_lower(value.status)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_end_of_stored_events():
            _UniffiConverterString.check_lower(value.subscription_id)
            return
        if value.is_notice():
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_closed():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_auth():
            _UniffiConverterString.check_lower(value.challenge)
            return
        if value.is_count():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterUInt64.check_lower(value.count)
            return
        if value.is_neg_msg():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_neg_err():
            _UniffiConverterString.check_lower(value.subscription_id)
            _UniffiConverterString.check_lower(value.code)
            return

    @staticmethod
    def write(value, buf):
        if value.is_event_msg():
            buf.write_i32(1)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_ok():
            buf.write_i32(2)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterBool.write(value.status, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_end_of_stored_events():
            buf.write_i32(3)
            _UniffiConverterString.write(value.subscription_id, buf)
        if value.is_notice():
            buf.write_i32(4)
            _UniffiConverterString.write(value.message, buf)
        if value.is_closed():
            buf.write_i32(5)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_auth():
            buf.write_i32(6)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_count():
            buf.write_i32(7)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterUInt64.write(value.count, buf)
        if value.is_neg_msg():
            buf.write_i32(8)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_neg_err():
            buf.write_i32(9)
            _UniffiConverterString.write(value.subscription_id, buf)
            _UniffiConverterString.write(value.code, buf)






class RelayMetadata(enum.Enum):
    READ = 1
    """Read"""

    
    WRITE = 2
    """Write"""

    


class _UniffiConverterTypeRelayMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RelayMetadata.READ
        if variant == 2:
            return RelayMetadata.WRITE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == RelayMetadata.READ:
            return
        if value == RelayMetadata.WRITE:
            return

    @staticmethod
    def write(value, buf):
        if value == RelayMetadata.READ:
            buf.write_i32(1)
        if value == RelayMetadata.WRITE:
            buf.write_i32(2)






class Report(enum.Enum):
    """Report"""

    NUDITY = 1
    """Depictions of nudity, porn, etc"""

    
    PROFANITY = 2
    """Profanity, hateful speech, etc."""

    
    ILLEGAL = 3
    """
    Something which may be illegal in some jurisdiction

    Remember: there is what is right and there is the law.
    """

    
    SPAM = 4
    """Spam"""

    
    IMPERSONATION = 5
    """Someone pretending to be someone else"""

    


class _UniffiConverterTypeReport(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Report.NUDITY
        if variant == 2:
            return Report.PROFANITY
        if variant == 3:
            return Report.ILLEGAL
        if variant == 4:
            return Report.SPAM
        if variant == 5:
            return Report.IMPERSONATION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Report.NUDITY:
            return
        if value == Report.PROFANITY:
            return
        if value == Report.ILLEGAL:
            return
        if value == Report.SPAM:
            return
        if value == Report.IMPERSONATION:
            return

    @staticmethod
    def write(value, buf):
        if value == Report.NUDITY:
            buf.write_i32(1)
        if value == Report.PROFANITY:
            buf.write_i32(2)
        if value == Report.ILLEGAL:
            buf.write_i32(3)
        if value == Report.SPAM:
            buf.write_i32(4)
        if value == Report.IMPERSONATION:
            buf.write_i32(5)






class TagEnum:
    def __init__(self):
        raise RuntimeError("TagEnum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UNKNOWN:
        kind: "TagKind"
        data: "typing.List[str]"

        @typing.no_type_check
        def __init__(self,kind: "TagKind", data: "typing.List[str]"):
            
            self.kind = kind
            self.data = data
            

        def __str__(self):
            return "TagEnum.UNKNOWN(kind={}, data={})".format(self.kind, self.data)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.kind != other.kind:
                return False
            if self.data != other.data:
                return False
            return True
    class EVENT_TAG:
        event_id: "EventId"
        relay_url: "typing.Optional[str]"
        marker: "typing.Optional[Marker]"

        @typing.no_type_check
        def __init__(self,event_id: "EventId", relay_url: "typing.Optional[str]", marker: "typing.Optional[Marker]"):
            
            self.event_id = event_id
            self.relay_url = relay_url
            self.marker = marker
            

        def __str__(self):
            return "TagEnum.EVENT_TAG(event_id={}, relay_url={}, marker={})".format(self.event_id, self.relay_url, self.marker)

        def __eq__(self, other):
            if not other.is_event_tag():
                return False
            if self.event_id != other.event_id:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            return True
    class PUBLIC_KEY_TAG:
        public_key: "PublicKey"
        relay_url: "typing.Optional[str]"
        alias: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,public_key: "PublicKey", relay_url: "typing.Optional[str]", alias: "typing.Optional[str]"):
            
            self.public_key = public_key
            self.relay_url = relay_url
            self.alias = alias
            

        def __str__(self):
            return "TagEnum.PUBLIC_KEY_TAG(public_key={}, relay_url={}, alias={})".format(self.public_key, self.relay_url, self.alias)

        def __eq__(self, other):
            if not other.is_public_key_tag():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.alias != other.alias:
                return False
            return True
    class EVENT_REPORT:
        event_id: "EventId"
        report: "Report"

        @typing.no_type_check
        def __init__(self,event_id: "EventId", report: "Report"):
            
            self.event_id = event_id
            self.report = report
            

        def __str__(self):
            return "TagEnum.EVENT_REPORT(event_id={}, report={})".format(self.event_id, self.report)

        def __eq__(self, other):
            if not other.is_event_report():
                return False
            if self.event_id != other.event_id:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_REPORT:
        public_key: "PublicKey"
        report: "Report"

        @typing.no_type_check
        def __init__(self,public_key: "PublicKey", report: "Report"):
            
            self.public_key = public_key
            self.report = report
            

        def __str__(self):
            return "TagEnum.PUB_KEY_REPORT(public_key={}, report={})".format(self.public_key, self.report)

        def __eq__(self, other):
            if not other.is_pub_key_report():
                return False
            if self.public_key != other.public_key:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_LIVE_EVENT:
        public_key: "PublicKey"
        relay_url: "typing.Optional[str]"
        marker: "LiveEventMarker"
        proof: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,public_key: "PublicKey", relay_url: "typing.Optional[str]", marker: "LiveEventMarker", proof: "typing.Optional[str]"):
            
            self.public_key = public_key
            self.relay_url = relay_url
            self.marker = marker
            self.proof = proof
            

        def __str__(self):
            return "TagEnum.PUB_KEY_LIVE_EVENT(public_key={}, relay_url={}, marker={}, proof={})".format(self.public_key, self.relay_url, self.marker, self.proof)

        def __eq__(self, other):
            if not other.is_pub_key_live_event():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            if self.proof != other.proof:
                return False
            return True
    class REFERENCE:
        reference: "str"

        @typing.no_type_check
        def __init__(self,reference: "str"):
            
            self.reference = reference
            

        def __str__(self):
            return "TagEnum.REFERENCE(reference={})".format(self.reference)

        def __eq__(self, other):
            if not other.is_reference():
                return False
            if self.reference != other.reference:
                return False
            return True
    class RELAY_METADATA_TAG:
        relay_url: "str"
        rw: "typing.Optional[RelayMetadata]"

        @typing.no_type_check
        def __init__(self,relay_url: "str", rw: "typing.Optional[RelayMetadata]"):
            
            self.relay_url = relay_url
            self.rw = rw
            

        def __str__(self):
            return "TagEnum.RELAY_METADATA_TAG(relay_url={}, rw={})".format(self.relay_url, self.rw)

        def __eq__(self, other):
            if not other.is_relay_metadata_tag():
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.rw != other.rw:
                return False
            return True
    class HASHTAG:
        hashtag: "str"

        @typing.no_type_check
        def __init__(self,hashtag: "str"):
            
            self.hashtag = hashtag
            

        def __str__(self):
            return "TagEnum.HASHTAG(hashtag={})".format(self.hashtag)

        def __eq__(self, other):
            if not other.is_hashtag():
                return False
            if self.hashtag != other.hashtag:
                return False
            return True
    class GEOHASH:
        geohash: "str"

        @typing.no_type_check
        def __init__(self,geohash: "str"):
            
            self.geohash = geohash
            

        def __str__(self):
            return "TagEnum.GEOHASH(geohash={})".format(self.geohash)

        def __eq__(self, other):
            if not other.is_geohash():
                return False
            if self.geohash != other.geohash:
                return False
            return True
    class IDENTIFIER:
        identifier: "str"

        @typing.no_type_check
        def __init__(self,identifier: "str"):
            
            self.identifier = identifier
            

        def __str__(self):
            return "TagEnum.IDENTIFIER(identifier={})".format(self.identifier)

        def __eq__(self, other):
            if not other.is_identifier():
                return False
            if self.identifier != other.identifier:
                return False
            return True
    class EXTERNAL_IDENTITY_TAG:
        identity: "Identity"

        @typing.no_type_check
        def __init__(self,identity: "Identity"):
            
            self.identity = identity
            

        def __str__(self):
            return "TagEnum.EXTERNAL_IDENTITY_TAG(identity={})".format(self.identity)

        def __eq__(self, other):
            if not other.is_external_identity_tag():
                return False
            if self.identity != other.identity:
                return False
            return True
    class A:
        kind: "int"
        public_key: "PublicKey"
        identifier: "str"
        relay_url: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,kind: "int", public_key: "PublicKey", identifier: "str", relay_url: "typing.Optional[str]"):
            
            self.kind = kind
            self.public_key = public_key
            self.identifier = identifier
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.A(kind={}, public_key={}, identifier={}, relay_url={})".format(self.kind, self.public_key, self.identifier, self.relay_url)

        def __eq__(self, other):
            if not other.is_a():
                return False
            if self.kind != other.kind:
                return False
            if self.public_key != other.public_key:
                return False
            if self.identifier != other.identifier:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class RELAY_URL:
        relay_url: "str"

        @typing.no_type_check
        def __init__(self,relay_url: "str"):
            
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.RELAY_URL(relay_url={})".format(self.relay_url)

        def __eq__(self, other):
            if not other.is_relay_url():
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class POW:
        nonce: "str"
        difficulty: "int"

        @typing.no_type_check
        def __init__(self,nonce: "str", difficulty: "int"):
            
            self.nonce = nonce
            self.difficulty = difficulty
            

        def __str__(self):
            return "TagEnum.POW(nonce={}, difficulty={})".format(self.nonce, self.difficulty)

        def __eq__(self, other):
            if not other.is_pow():
                return False
            if self.nonce != other.nonce:
                return False
            if self.difficulty != other.difficulty:
                return False
            return True
    class DELEGATION:
        delegator: "PublicKey"
        conditions: "str"
        sig: "str"

        @typing.no_type_check
        def __init__(self,delegator: "PublicKey", conditions: "str", sig: "str"):
            
            self.delegator = delegator
            self.conditions = conditions
            self.sig = sig
            

        def __str__(self):
            return "TagEnum.DELEGATION(delegator={}, conditions={}, sig={})".format(self.delegator, self.conditions, self.sig)

        def __eq__(self, other):
            if not other.is_delegation():
                return False
            if self.delegator != other.delegator:
                return False
            if self.conditions != other.conditions:
                return False
            if self.sig != other.sig:
                return False
            return True
    class CONTENT_WARNING:
        reason: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,reason: "typing.Optional[str]"):
            
            self.reason = reason
            

        def __str__(self):
            return "TagEnum.CONTENT_WARNING(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_content_warning():
                return False
            if self.reason != other.reason:
                return False
            return True
    class EXPIRATION:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.EXPIRATION(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_expiration():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class SUBJECT:
        subject: "str"

        @typing.no_type_check
        def __init__(self,subject: "str"):
            
            self.subject = subject
            

        def __str__(self):
            return "TagEnum.SUBJECT(subject={})".format(self.subject)

        def __eq__(self, other):
            if not other.is_subject():
                return False
            if self.subject != other.subject:
                return False
            return True
    class CHALLENGE:
        challenge: "str"

        @typing.no_type_check
        def __init__(self,challenge: "str"):
            
            self.challenge = challenge
            

        def __str__(self):
            return "TagEnum.CHALLENGE(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_challenge():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class TITLE:
        title: "str"

        @typing.no_type_check
        def __init__(self,title: "str"):
            
            self.title = title
            

        def __str__(self):
            return "TagEnum.TITLE(title={})".format(self.title)

        def __eq__(self, other):
            if not other.is_title():
                return False
            if self.title != other.title:
                return False
            return True
    class IMAGE:
        url: "str"
        dimensions: "typing.Optional[ImageDimensions]"

        @typing.no_type_check
        def __init__(self,url: "str", dimensions: "typing.Optional[ImageDimensions]"):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.IMAGE(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_image():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class THUMB:
        url: "str"
        dimensions: "typing.Optional[ImageDimensions]"

        @typing.no_type_check
        def __init__(self,url: "str", dimensions: "typing.Optional[ImageDimensions]"):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.THUMB(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_thumb():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class SUMMARY:
        summary: "str"

        @typing.no_type_check
        def __init__(self,summary: "str"):
            
            self.summary = summary
            

        def __str__(self):
            return "TagEnum.SUMMARY(summary={})".format(self.summary)

        def __eq__(self, other):
            if not other.is_summary():
                return False
            if self.summary != other.summary:
                return False
            return True
    class DESCRIPTION:
        desc: "str"

        @typing.no_type_check
        def __init__(self,desc: "str"):
            
            self.desc = desc
            

        def __str__(self):
            return "TagEnum.DESCRIPTION(desc={})".format(self.desc)

        def __eq__(self, other):
            if not other.is_description():
                return False
            if self.desc != other.desc:
                return False
            return True
    class BOLT11:
        bolt11: "str"

        @typing.no_type_check
        def __init__(self,bolt11: "str"):
            
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.BOLT11(bolt11={})".format(self.bolt11)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class PREIMAGE:
        preimage: "str"

        @typing.no_type_check
        def __init__(self,preimage: "str"):
            
            self.preimage = preimage
            

        def __str__(self):
            return "TagEnum.PREIMAGE(preimage={})".format(self.preimage)

        def __eq__(self, other):
            if not other.is_preimage():
                return False
            if self.preimage != other.preimage:
                return False
            return True
    class RELAYS:
        urls: "typing.List[str]"

        @typing.no_type_check
        def __init__(self,urls: "typing.List[str]"):
            
            self.urls = urls
            

        def __str__(self):
            return "TagEnum.RELAYS(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_relays():
                return False
            if self.urls != other.urls:
                return False
            return True
    class AMOUNT:
        millisats: "int"
        bolt11: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,millisats: "int", bolt11: "typing.Optional[str]"):
            
            self.millisats = millisats
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.AMOUNT(millisats={}, bolt11={})".format(self.millisats, self.bolt11)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.millisats != other.millisats:
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class LNURL:
        lnurl: "str"

        @typing.no_type_check
        def __init__(self,lnurl: "str"):
            
            self.lnurl = lnurl
            

        def __str__(self):
            return "TagEnum.LNURL(lnurl={})".format(self.lnurl)

        def __eq__(self, other):
            if not other.is_lnurl():
                return False
            if self.lnurl != other.lnurl:
                return False
            return True
    class NAME:
        name: "str"

        @typing.no_type_check
        def __init__(self,name: "str"):
            
            self.name = name
            

        def __str__(self):
            return "TagEnum.NAME(name={})".format(self.name)

        def __eq__(self, other):
            if not other.is_name():
                return False
            if self.name != other.name:
                return False
            return True
    class PUBLISHED_AT:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.PUBLISHED_AT(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_published_at():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class URL_TAG:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.URL_TAG(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url_tag():
                return False
            if self.url != other.url:
                return False
            return True
    class MIME_TYPE:
        mime: "str"

        @typing.no_type_check
        def __init__(self,mime: "str"):
            
            self.mime = mime
            

        def __str__(self):
            return "TagEnum.MIME_TYPE(mime={})".format(self.mime)

        def __eq__(self, other):
            if not other.is_mime_type():
                return False
            if self.mime != other.mime:
                return False
            return True
    class AES256_GCM:
        key: "str"
        iv: "str"

        @typing.no_type_check
        def __init__(self,key: "str", iv: "str"):
            
            self.key = key
            self.iv = iv
            

        def __str__(self):
            return "TagEnum.AES256_GCM(key={}, iv={})".format(self.key, self.iv)

        def __eq__(self, other):
            if not other.is_aes256_gcm():
                return False
            if self.key != other.key:
                return False
            if self.iv != other.iv:
                return False
            return True
    class SHA256:
        hash: "str"

        @typing.no_type_check
        def __init__(self,hash: "str"):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.SHA256(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_sha256():
                return False
            if self.hash != other.hash:
                return False
            return True
    class SIZE:
        size: "int"

        @typing.no_type_check
        def __init__(self,size: "int"):
            
            self.size = size
            

        def __str__(self):
            return "TagEnum.SIZE(size={})".format(self.size)

        def __eq__(self, other):
            if not other.is_size():
                return False
            if self.size != other.size:
                return False
            return True
    class DIM:
        """Size of file in pixels"""

        dimensions: "ImageDimensions"

        @typing.no_type_check
        def __init__(self,dimensions: "ImageDimensions"):
            
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.DIM(dimensions={})".format(self.dimensions)

        def __eq__(self, other):
            if not other.is_dim():
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class MAGNET:
        uri: "str"

        @typing.no_type_check
        def __init__(self,uri: "str"):
            
            self.uri = uri
            

        def __str__(self):
            return "TagEnum.MAGNET(uri={})".format(self.uri)

        def __eq__(self, other):
            if not other.is_magnet():
                return False
            if self.uri != other.uri:
                return False
            return True
    class BLURHASH:
        blurhash: "str"

        @typing.no_type_check
        def __init__(self,blurhash: "str"):
            
            self.blurhash = blurhash
            

        def __str__(self):
            return "TagEnum.BLURHASH(blurhash={})".format(self.blurhash)

        def __eq__(self, other):
            if not other.is_blurhash():
                return False
            if self.blurhash != other.blurhash:
                return False
            return True
    class STREAMING:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.STREAMING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_streaming():
                return False
            if self.url != other.url:
                return False
            return True
    class RECORDING:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.RECORDING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_recording():
                return False
            if self.url != other.url:
                return False
            return True
    class STARTS:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.STARTS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_starts():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class ENDS:
        timestamp: "Timestamp"

        @typing.no_type_check
        def __init__(self,timestamp: "Timestamp"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.ENDS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_ends():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class LIVE_EVENT_STATUS_TAG:
        status: "LiveEventStatus"

        @typing.no_type_check
        def __init__(self,status: "LiveEventStatus"):
            
            self.status = status
            

        def __str__(self):
            return "TagEnum.LIVE_EVENT_STATUS_TAG(status={})".format(self.status)

        def __eq__(self, other):
            if not other.is_live_event_status_tag():
                return False
            if self.status != other.status:
                return False
            return True
    class CURRENT_PARTICIPANTS:
        num: "int"

        @typing.no_type_check
        def __init__(self,num: "int"):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.CURRENT_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_current_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class TOTAL_PARTICIPANTS:
        num: "int"

        @typing.no_type_check
        def __init__(self,num: "int"):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.TOTAL_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_total_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class ABSOLUTE_URL:
        url: "str"

        @typing.no_type_check
        def __init__(self,url: "str"):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.ABSOLUTE_URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_absolute_url():
                return False
            if self.url != other.url:
                return False
            return True
    class METHOD:
        method: "HttpMethod"

        @typing.no_type_check
        def __init__(self,method: "HttpMethod"):
            
            self.method = method
            

        def __str__(self):
            return "TagEnum.METHOD(method={})".format(self.method)

        def __eq__(self, other):
            if not other.is_method():
                return False
            if self.method != other.method:
                return False
            return True
    class PAYLOAD:
        hash: "str"

        @typing.no_type_check
        def __init__(self,hash: "str"):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.PAYLOAD(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_payload():
                return False
            if self.hash != other.hash:
                return False
            return True
    class ANON:
        msg: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,msg: "typing.Optional[str]"):
            
            self.msg = msg
            

        def __str__(self):
            return "TagEnum.ANON(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_anon():
                return False
            if self.msg != other.msg:
                return False
            return True
    class PROXY:
        id: "str"
        protocol: "Protocol"

        @typing.no_type_check
        def __init__(self,id: "str", protocol: "Protocol"):
            
            self.id = id
            self.protocol = protocol
            

        def __str__(self):
            return "TagEnum.PROXY(id={}, protocol={})".format(self.id, self.protocol)

        def __eq__(self, other):
            if not other.is_proxy():
                return False
            if self.id != other.id:
                return False
            if self.protocol != other.protocol:
                return False
            return True
    class EMOJI:
        shortcode: "str"
        url: "str"

        @typing.no_type_check
        def __init__(self,shortcode: "str", url: "str"):
            
            self.shortcode = shortcode
            self.url = url
            

        def __str__(self):
            return "TagEnum.EMOJI(shortcode={}, url={})".format(self.shortcode, self.url)

        def __eq__(self, other):
            if not other.is_emoji():
                return False
            if self.shortcode != other.shortcode:
                return False
            if self.url != other.url:
                return False
            return True
    class REQUEST:
        event: "Event"

        @typing.no_type_check
        def __init__(self,event: "Event"):
            
            self.event = event
            

        def __str__(self):
            return "TagEnum.REQUEST(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_request():
                return False
            if self.event != other.event:
                return False
            return True
    class DATA_VENDING_MACHINE_STATUS_TAG:
        status: "DataVendingMachineStatus"
        extra_info: "typing.Optional[str]"

        @typing.no_type_check
        def __init__(self,status: "DataVendingMachineStatus", extra_info: "typing.Optional[str]"):
            
            self.status = status
            self.extra_info = extra_info
            

        def __str__(self):
            return "TagEnum.DATA_VENDING_MACHINE_STATUS_TAG(status={}, extra_info={})".format(self.status, self.extra_info)

        def __eq__(self, other):
            if not other.is_data_vending_machine_status_tag():
                return False
            if self.status != other.status:
                return False
            if self.extra_info != other.extra_info:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_unknown(self) -> bool:
        return isinstance(self, TagEnum.UNKNOWN)
    def is_event_tag(self) -> bool:
        return isinstance(self, TagEnum.EVENT_TAG)
    def is_public_key_tag(self) -> bool:
        return isinstance(self, TagEnum.PUBLIC_KEY_TAG)
    def is_event_report(self) -> bool:
        return isinstance(self, TagEnum.EVENT_REPORT)
    def is_pub_key_report(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_REPORT)
    def is_pub_key_live_event(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_LIVE_EVENT)
    def is_reference(self) -> bool:
        return isinstance(self, TagEnum.REFERENCE)
    def is_relay_metadata_tag(self) -> bool:
        return isinstance(self, TagEnum.RELAY_METADATA_TAG)
    def is_hashtag(self) -> bool:
        return isinstance(self, TagEnum.HASHTAG)
    def is_geohash(self) -> bool:
        return isinstance(self, TagEnum.GEOHASH)
    def is_identifier(self) -> bool:
        return isinstance(self, TagEnum.IDENTIFIER)
    def is_external_identity_tag(self) -> bool:
        return isinstance(self, TagEnum.EXTERNAL_IDENTITY_TAG)
    def is_a(self) -> bool:
        return isinstance(self, TagEnum.A)
    def is_relay_url(self) -> bool:
        return isinstance(self, TagEnum.RELAY_URL)
    def is_pow(self) -> bool:
        return isinstance(self, TagEnum.POW)
    def is_delegation(self) -> bool:
        return isinstance(self, TagEnum.DELEGATION)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagEnum.CONTENT_WARNING)
    def is_expiration(self) -> bool:
        return isinstance(self, TagEnum.EXPIRATION)
    def is_subject(self) -> bool:
        return isinstance(self, TagEnum.SUBJECT)
    def is_challenge(self) -> bool:
        return isinstance(self, TagEnum.CHALLENGE)
    def is_title(self) -> bool:
        return isinstance(self, TagEnum.TITLE)
    def is_image(self) -> bool:
        return isinstance(self, TagEnum.IMAGE)
    def is_thumb(self) -> bool:
        return isinstance(self, TagEnum.THUMB)
    def is_summary(self) -> bool:
        return isinstance(self, TagEnum.SUMMARY)
    def is_description(self) -> bool:
        return isinstance(self, TagEnum.DESCRIPTION)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagEnum.BOLT11)
    def is_preimage(self) -> bool:
        return isinstance(self, TagEnum.PREIMAGE)
    def is_relays(self) -> bool:
        return isinstance(self, TagEnum.RELAYS)
    def is_amount(self) -> bool:
        return isinstance(self, TagEnum.AMOUNT)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagEnum.LNURL)
    def is_name(self) -> bool:
        return isinstance(self, TagEnum.NAME)
    def is_published_at(self) -> bool:
        return isinstance(self, TagEnum.PUBLISHED_AT)
    def is_url_tag(self) -> bool:
        return isinstance(self, TagEnum.URL_TAG)
    def is_mime_type(self) -> bool:
        return isinstance(self, TagEnum.MIME_TYPE)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagEnum.AES256_GCM)
    def is_sha256(self) -> bool:
        return isinstance(self, TagEnum.SHA256)
    def is_size(self) -> bool:
        return isinstance(self, TagEnum.SIZE)
    def is_dim(self) -> bool:
        return isinstance(self, TagEnum.DIM)
    def is_magnet(self) -> bool:
        return isinstance(self, TagEnum.MAGNET)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagEnum.BLURHASH)
    def is_streaming(self) -> bool:
        return isinstance(self, TagEnum.STREAMING)
    def is_recording(self) -> bool:
        return isinstance(self, TagEnum.RECORDING)
    def is_starts(self) -> bool:
        return isinstance(self, TagEnum.STARTS)
    def is_ends(self) -> bool:
        return isinstance(self, TagEnum.ENDS)
    def is_live_event_status_tag(self) -> bool:
        return isinstance(self, TagEnum.LIVE_EVENT_STATUS_TAG)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagEnum.CURRENT_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagEnum.TOTAL_PARTICIPANTS)
    def is_absolute_url(self) -> bool:
        return isinstance(self, TagEnum.ABSOLUTE_URL)
    def is_method(self) -> bool:
        return isinstance(self, TagEnum.METHOD)
    def is_payload(self) -> bool:
        return isinstance(self, TagEnum.PAYLOAD)
    def is_anon(self) -> bool:
        return isinstance(self, TagEnum.ANON)
    def is_proxy(self) -> bool:
        return isinstance(self, TagEnum.PROXY)
    def is_emoji(self) -> bool:
        return isinstance(self, TagEnum.EMOJI)
    def is_request(self) -> bool:
        return isinstance(self, TagEnum.REQUEST)
    def is_data_vending_machine_status_tag(self) -> bool:
        return isinstance(self, TagEnum.DATA_VENDING_MACHINE_STATUS_TAG)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagEnum.UNKNOWN = type("TagEnum.UNKNOWN", (TagEnum.UNKNOWN, TagEnum,), {})  # type: ignore
TagEnum.EVENT_TAG = type("TagEnum.EVENT_TAG", (TagEnum.EVENT_TAG, TagEnum,), {})  # type: ignore
TagEnum.PUBLIC_KEY_TAG = type("TagEnum.PUBLIC_KEY_TAG", (TagEnum.PUBLIC_KEY_TAG, TagEnum,), {})  # type: ignore
TagEnum.EVENT_REPORT = type("TagEnum.EVENT_REPORT", (TagEnum.EVENT_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_REPORT = type("TagEnum.PUB_KEY_REPORT", (TagEnum.PUB_KEY_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_LIVE_EVENT = type("TagEnum.PUB_KEY_LIVE_EVENT", (TagEnum.PUB_KEY_LIVE_EVENT, TagEnum,), {})  # type: ignore
TagEnum.REFERENCE = type("TagEnum.REFERENCE", (TagEnum.REFERENCE, TagEnum,), {})  # type: ignore
TagEnum.RELAY_METADATA_TAG = type("TagEnum.RELAY_METADATA_TAG", (TagEnum.RELAY_METADATA_TAG, TagEnum,), {})  # type: ignore
TagEnum.HASHTAG = type("TagEnum.HASHTAG", (TagEnum.HASHTAG, TagEnum,), {})  # type: ignore
TagEnum.GEOHASH = type("TagEnum.GEOHASH", (TagEnum.GEOHASH, TagEnum,), {})  # type: ignore
TagEnum.IDENTIFIER = type("TagEnum.IDENTIFIER", (TagEnum.IDENTIFIER, TagEnum,), {})  # type: ignore
TagEnum.EXTERNAL_IDENTITY_TAG = type("TagEnum.EXTERNAL_IDENTITY_TAG", (TagEnum.EXTERNAL_IDENTITY_TAG, TagEnum,), {})  # type: ignore
TagEnum.A = type("TagEnum.A", (TagEnum.A, TagEnum,), {})  # type: ignore
TagEnum.RELAY_URL = type("TagEnum.RELAY_URL", (TagEnum.RELAY_URL, TagEnum,), {})  # type: ignore
TagEnum.POW = type("TagEnum.POW", (TagEnum.POW, TagEnum,), {})  # type: ignore
TagEnum.DELEGATION = type("TagEnum.DELEGATION", (TagEnum.DELEGATION, TagEnum,), {})  # type: ignore
TagEnum.CONTENT_WARNING = type("TagEnum.CONTENT_WARNING", (TagEnum.CONTENT_WARNING, TagEnum,), {})  # type: ignore
TagEnum.EXPIRATION = type("TagEnum.EXPIRATION", (TagEnum.EXPIRATION, TagEnum,), {})  # type: ignore
TagEnum.SUBJECT = type("TagEnum.SUBJECT", (TagEnum.SUBJECT, TagEnum,), {})  # type: ignore
TagEnum.CHALLENGE = type("TagEnum.CHALLENGE", (TagEnum.CHALLENGE, TagEnum,), {})  # type: ignore
TagEnum.TITLE = type("TagEnum.TITLE", (TagEnum.TITLE, TagEnum,), {})  # type: ignore
TagEnum.IMAGE = type("TagEnum.IMAGE", (TagEnum.IMAGE, TagEnum,), {})  # type: ignore
TagEnum.THUMB = type("TagEnum.THUMB", (TagEnum.THUMB, TagEnum,), {})  # type: ignore
TagEnum.SUMMARY = type("TagEnum.SUMMARY", (TagEnum.SUMMARY, TagEnum,), {})  # type: ignore
TagEnum.DESCRIPTION = type("TagEnum.DESCRIPTION", (TagEnum.DESCRIPTION, TagEnum,), {})  # type: ignore
TagEnum.BOLT11 = type("TagEnum.BOLT11", (TagEnum.BOLT11, TagEnum,), {})  # type: ignore
TagEnum.PREIMAGE = type("TagEnum.PREIMAGE", (TagEnum.PREIMAGE, TagEnum,), {})  # type: ignore
TagEnum.RELAYS = type("TagEnum.RELAYS", (TagEnum.RELAYS, TagEnum,), {})  # type: ignore
TagEnum.AMOUNT = type("TagEnum.AMOUNT", (TagEnum.AMOUNT, TagEnum,), {})  # type: ignore
TagEnum.LNURL = type("TagEnum.LNURL", (TagEnum.LNURL, TagEnum,), {})  # type: ignore
TagEnum.NAME = type("TagEnum.NAME", (TagEnum.NAME, TagEnum,), {})  # type: ignore
TagEnum.PUBLISHED_AT = type("TagEnum.PUBLISHED_AT", (TagEnum.PUBLISHED_AT, TagEnum,), {})  # type: ignore
TagEnum.URL_TAG = type("TagEnum.URL_TAG", (TagEnum.URL_TAG, TagEnum,), {})  # type: ignore
TagEnum.MIME_TYPE = type("TagEnum.MIME_TYPE", (TagEnum.MIME_TYPE, TagEnum,), {})  # type: ignore
TagEnum.AES256_GCM = type("TagEnum.AES256_GCM", (TagEnum.AES256_GCM, TagEnum,), {})  # type: ignore
TagEnum.SHA256 = type("TagEnum.SHA256", (TagEnum.SHA256, TagEnum,), {})  # type: ignore
TagEnum.SIZE = type("TagEnum.SIZE", (TagEnum.SIZE, TagEnum,), {})  # type: ignore
TagEnum.DIM = type("TagEnum.DIM", (TagEnum.DIM, TagEnum,), {})  # type: ignore
TagEnum.MAGNET = type("TagEnum.MAGNET", (TagEnum.MAGNET, TagEnum,), {})  # type: ignore
TagEnum.BLURHASH = type("TagEnum.BLURHASH", (TagEnum.BLURHASH, TagEnum,), {})  # type: ignore
TagEnum.STREAMING = type("TagEnum.STREAMING", (TagEnum.STREAMING, TagEnum,), {})  # type: ignore
TagEnum.RECORDING = type("TagEnum.RECORDING", (TagEnum.RECORDING, TagEnum,), {})  # type: ignore
TagEnum.STARTS = type("TagEnum.STARTS", (TagEnum.STARTS, TagEnum,), {})  # type: ignore
TagEnum.ENDS = type("TagEnum.ENDS", (TagEnum.ENDS, TagEnum,), {})  # type: ignore
TagEnum.LIVE_EVENT_STATUS_TAG = type("TagEnum.LIVE_EVENT_STATUS_TAG", (TagEnum.LIVE_EVENT_STATUS_TAG, TagEnum,), {})  # type: ignore
TagEnum.CURRENT_PARTICIPANTS = type("TagEnum.CURRENT_PARTICIPANTS", (TagEnum.CURRENT_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.TOTAL_PARTICIPANTS = type("TagEnum.TOTAL_PARTICIPANTS", (TagEnum.TOTAL_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.ABSOLUTE_URL = type("TagEnum.ABSOLUTE_URL", (TagEnum.ABSOLUTE_URL, TagEnum,), {})  # type: ignore
TagEnum.METHOD = type("TagEnum.METHOD", (TagEnum.METHOD, TagEnum,), {})  # type: ignore
TagEnum.PAYLOAD = type("TagEnum.PAYLOAD", (TagEnum.PAYLOAD, TagEnum,), {})  # type: ignore
TagEnum.ANON = type("TagEnum.ANON", (TagEnum.ANON, TagEnum,), {})  # type: ignore
TagEnum.PROXY = type("TagEnum.PROXY", (TagEnum.PROXY, TagEnum,), {})  # type: ignore
TagEnum.EMOJI = type("TagEnum.EMOJI", (TagEnum.EMOJI, TagEnum,), {})  # type: ignore
TagEnum.REQUEST = type("TagEnum.REQUEST", (TagEnum.REQUEST, TagEnum,), {})  # type: ignore
TagEnum.DATA_VENDING_MACHINE_STATUS_TAG = type("TagEnum.DATA_VENDING_MACHINE_STATUS_TAG", (TagEnum.DATA_VENDING_MACHINE_STATUS_TAG, TagEnum,), {})  # type: ignore




class _UniffiConverterTypeTagEnum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagEnum.UNKNOWN(
                _UniffiConverterTypeTagKind.read(buf),
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 2:
            return TagEnum.EVENT_TAG(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalTypeMarker.read(buf),
            )
        if variant == 3:
            return TagEnum.PUBLIC_KEY_TAG(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 4:
            return TagEnum.EVENT_REPORT(
                _UniffiConverterTypeEventId.read(buf),
                _UniffiConverterTypeReport.read(buf),
            )
        if variant == 5:
            return TagEnum.PUB_KEY_REPORT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterTypeReport.read(buf),
            )
        if variant == 6:
            return TagEnum.PUB_KEY_LIVE_EVENT(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterTypeLiveEventMarker.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 7:
            return TagEnum.REFERENCE(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return TagEnum.RELAY_METADATA_TAG(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeRelayMetadata.read(buf),
            )
        if variant == 9:
            return TagEnum.HASHTAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return TagEnum.GEOHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return TagEnum.IDENTIFIER(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return TagEnum.EXTERNAL_IDENTITY_TAG(
                _UniffiConverterTypeIdentity.read(buf),
            )
        if variant == 13:
            return TagEnum.A(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 14:
            return TagEnum.RELAY_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return TagEnum.POW(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 16:
            return TagEnum.DELEGATION(
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return TagEnum.CONTENT_WARNING(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 18:
            return TagEnum.EXPIRATION(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 19:
            return TagEnum.SUBJECT(
                _UniffiConverterString.read(buf),
            )
        if variant == 20:
            return TagEnum.CHALLENGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return TagEnum.TITLE(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return TagEnum.IMAGE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeImageDimensions.read(buf),
            )
        if variant == 23:
            return TagEnum.THUMB(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeImageDimensions.read(buf),
            )
        if variant == 24:
            return TagEnum.SUMMARY(
                _UniffiConverterString.read(buf),
            )
        if variant == 25:
            return TagEnum.DESCRIPTION(
                _UniffiConverterString.read(buf),
            )
        if variant == 26:
            return TagEnum.BOLT11(
                _UniffiConverterString.read(buf),
            )
        if variant == 27:
            return TagEnum.PREIMAGE(
                _UniffiConverterString.read(buf),
            )
        if variant == 28:
            return TagEnum.RELAYS(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 29:
            return TagEnum.AMOUNT(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 30:
            return TagEnum.LNURL(
                _UniffiConverterString.read(buf),
            )
        if variant == 31:
            return TagEnum.NAME(
                _UniffiConverterString.read(buf),
            )
        if variant == 32:
            return TagEnum.PUBLISHED_AT(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 33:
            return TagEnum.URL_TAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 34:
            return TagEnum.MIME_TYPE(
                _UniffiConverterString.read(buf),
            )
        if variant == 35:
            return TagEnum.AES256_GCM(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 36:
            return TagEnum.SHA256(
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return TagEnum.SIZE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 38:
            return TagEnum.DIM(
                _UniffiConverterTypeImageDimensions.read(buf),
            )
        if variant == 39:
            return TagEnum.MAGNET(
                _UniffiConverterString.read(buf),
            )
        if variant == 40:
            return TagEnum.BLURHASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 41:
            return TagEnum.STREAMING(
                _UniffiConverterString.read(buf),
            )
        if variant == 42:
            return TagEnum.RECORDING(
                _UniffiConverterString.read(buf),
            )
        if variant == 43:
            return TagEnum.STARTS(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 44:
            return TagEnum.ENDS(
                _UniffiConverterTypeTimestamp.read(buf),
            )
        if variant == 45:
            return TagEnum.LIVE_EVENT_STATUS_TAG(
                _UniffiConverterTypeLiveEventStatus.read(buf),
            )
        if variant == 46:
            return TagEnum.CURRENT_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 47:
            return TagEnum.TOTAL_PARTICIPANTS(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 48:
            return TagEnum.ABSOLUTE_URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 49:
            return TagEnum.METHOD(
                _UniffiConverterTypeHttpMethod.read(buf),
            )
        if variant == 50:
            return TagEnum.PAYLOAD(
                _UniffiConverterString.read(buf),
            )
        if variant == 51:
            return TagEnum.ANON(
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 52:
            return TagEnum.PROXY(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeProtocol.read(buf),
            )
        if variant == 53:
            return TagEnum.EMOJI(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 54:
            return TagEnum.REQUEST(
                _UniffiConverterTypeEvent.read(buf),
            )
        if variant == 55:
            return TagEnum.DATA_VENDING_MACHINE_STATUS_TAG(
                _UniffiConverterTypeDataVendingMachineStatus.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_unknown():
            _UniffiConverterTypeTagKind.check_lower(value.kind)
            _UniffiConverterSequenceString.check_lower(value.data)
            return
        if value.is_event_tag():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            _UniffiConverterOptionalTypeMarker.check_lower(value.marker)
            return
        if value.is_public_key_tag():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            _UniffiConverterOptionalString.check_lower(value.alias)
            return
        if value.is_event_report():
            _UniffiConverterTypeEventId.check_lower(value.event_id)
            _UniffiConverterTypeReport.check_lower(value.report)
            return
        if value.is_pub_key_report():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterTypeReport.check_lower(value.report)
            return
        if value.is_pub_key_live_event():
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            _UniffiConverterTypeLiveEventMarker.check_lower(value.marker)
            _UniffiConverterOptionalString.check_lower(value.proof)
            return
        if value.is_reference():
            _UniffiConverterString.check_lower(value.reference)
            return
        if value.is_relay_metadata_tag():
            _UniffiConverterString.check_lower(value.relay_url)
            _UniffiConverterOptionalTypeRelayMetadata.check_lower(value.rw)
            return
        if value.is_hashtag():
            _UniffiConverterString.check_lower(value.hashtag)
            return
        if value.is_geohash():
            _UniffiConverterString.check_lower(value.geohash)
            return
        if value.is_identifier():
            _UniffiConverterString.check_lower(value.identifier)
            return
        if value.is_external_identity_tag():
            _UniffiConverterTypeIdentity.check_lower(value.identity)
            return
        if value.is_a():
            _UniffiConverterUInt64.check_lower(value.kind)
            _UniffiConverterTypePublicKey.check_lower(value.public_key)
            _UniffiConverterString.check_lower(value.identifier)
            _UniffiConverterOptionalString.check_lower(value.relay_url)
            return
        if value.is_relay_url():
            _UniffiConverterString.check_lower(value.relay_url)
            return
        if value.is_pow():
            _UniffiConverterString.check_lower(value.nonce)
            _UniffiConverterUInt8.check_lower(value.difficulty)
            return
        if value.is_delegation():
            _UniffiConverterTypePublicKey.check_lower(value.delegator)
            _UniffiConverterString.check_lower(value.conditions)
            _UniffiConverterString.check_lower(value.sig)
            return
        if value.is_content_warning():
            _UniffiConverterOptionalString.check_lower(value.reason)
            return
        if value.is_expiration():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_subject():
            _UniffiConverterString.check_lower(value.subject)
            return
        if value.is_challenge():
            _UniffiConverterString.check_lower(value.challenge)
            return
        if value.is_title():
            _UniffiConverterString.check_lower(value.title)
            return
        if value.is_image():
            _UniffiConverterString.check_lower(value.url)
            _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_thumb():
            _UniffiConverterString.check_lower(value.url)
            _UniffiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_summary():
            _UniffiConverterString.check_lower(value.summary)
            return
        if value.is_description():
            _UniffiConverterString.check_lower(value.desc)
            return
        if value.is_bolt11():
            _UniffiConverterString.check_lower(value.bolt11)
            return
        if value.is_preimage():
            _UniffiConverterString.check_lower(value.preimage)
            return
        if value.is_relays():
            _UniffiConverterSequenceString.check_lower(value.urls)
            return
        if value.is_amount():
            _UniffiConverterUInt64.check_lower(value.millisats)
            _UniffiConverterOptionalString.check_lower(value.bolt11)
            return
        if value.is_lnurl():
            _UniffiConverterString.check_lower(value.lnurl)
            return
        if value.is_name():
            _UniffiConverterString.check_lower(value.name)
            return
        if value.is_published_at():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_url_tag():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_mime_type():
            _UniffiConverterString.check_lower(value.mime)
            return
        if value.is_aes256_gcm():
            _UniffiConverterString.check_lower(value.key)
            _UniffiConverterString.check_lower(value.iv)
            return
        if value.is_sha256():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_size():
            _UniffiConverterUInt64.check_lower(value.size)
            return
        if value.is_dim():
            _UniffiConverterTypeImageDimensions.check_lower(value.dimensions)
            return
        if value.is_magnet():
            _UniffiConverterString.check_lower(value.uri)
            return
        if value.is_blurhash():
            _UniffiConverterString.check_lower(value.blurhash)
            return
        if value.is_streaming():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_recording():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_starts():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_ends():
            _UniffiConverterTypeTimestamp.check_lower(value.timestamp)
            return
        if value.is_live_event_status_tag():
            _UniffiConverterTypeLiveEventStatus.check_lower(value.status)
            return
        if value.is_current_participants():
            _UniffiConverterUInt64.check_lower(value.num)
            return
        if value.is_total_participants():
            _UniffiConverterUInt64.check_lower(value.num)
            return
        if value.is_absolute_url():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_method():
            _UniffiConverterTypeHttpMethod.check_lower(value.method)
            return
        if value.is_payload():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_anon():
            _UniffiConverterOptionalString.check_lower(value.msg)
            return
        if value.is_proxy():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterTypeProtocol.check_lower(value.protocol)
            return
        if value.is_emoji():
            _UniffiConverterString.check_lower(value.shortcode)
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_request():
            _UniffiConverterTypeEvent.check_lower(value.event)
            return
        if value.is_data_vending_machine_status_tag():
            _UniffiConverterTypeDataVendingMachineStatus.check_lower(value.status)
            _UniffiConverterOptionalString.check_lower(value.extra_info)
            return

    @staticmethod
    def write(value, buf):
        if value.is_unknown():
            buf.write_i32(1)
            _UniffiConverterTypeTagKind.write(value.kind, buf)
            _UniffiConverterSequenceString.write(value.data, buf)
        if value.is_event_tag():
            buf.write_i32(2)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterOptionalTypeMarker.write(value.marker, buf)
        if value.is_public_key_tag():
            buf.write_i32(3)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterOptionalString.write(value.alias, buf)
        if value.is_event_report():
            buf.write_i32(4)
            _UniffiConverterTypeEventId.write(value.event_id, buf)
            _UniffiConverterTypeReport.write(value.report, buf)
        if value.is_pub_key_report():
            buf.write_i32(5)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterTypeReport.write(value.report, buf)
        if value.is_pub_key_live_event():
            buf.write_i32(6)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
            _UniffiConverterTypeLiveEventMarker.write(value.marker, buf)
            _UniffiConverterOptionalString.write(value.proof, buf)
        if value.is_reference():
            buf.write_i32(7)
            _UniffiConverterString.write(value.reference, buf)
        if value.is_relay_metadata_tag():
            buf.write_i32(8)
            _UniffiConverterString.write(value.relay_url, buf)
            _UniffiConverterOptionalTypeRelayMetadata.write(value.rw, buf)
        if value.is_hashtag():
            buf.write_i32(9)
            _UniffiConverterString.write(value.hashtag, buf)
        if value.is_geohash():
            buf.write_i32(10)
            _UniffiConverterString.write(value.geohash, buf)
        if value.is_identifier():
            buf.write_i32(11)
            _UniffiConverterString.write(value.identifier, buf)
        if value.is_external_identity_tag():
            buf.write_i32(12)
            _UniffiConverterTypeIdentity.write(value.identity, buf)
        if value.is_a():
            buf.write_i32(13)
            _UniffiConverterUInt64.write(value.kind, buf)
            _UniffiConverterTypePublicKey.write(value.public_key, buf)
            _UniffiConverterString.write(value.identifier, buf)
            _UniffiConverterOptionalString.write(value.relay_url, buf)
        if value.is_relay_url():
            buf.write_i32(14)
            _UniffiConverterString.write(value.relay_url, buf)
        if value.is_pow():
            buf.write_i32(15)
            _UniffiConverterString.write(value.nonce, buf)
            _UniffiConverterUInt8.write(value.difficulty, buf)
        if value.is_delegation():
            buf.write_i32(16)
            _UniffiConverterTypePublicKey.write(value.delegator, buf)
            _UniffiConverterString.write(value.conditions, buf)
            _UniffiConverterString.write(value.sig, buf)
        if value.is_content_warning():
            buf.write_i32(17)
            _UniffiConverterOptionalString.write(value.reason, buf)
        if value.is_expiration():
            buf.write_i32(18)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_subject():
            buf.write_i32(19)
            _UniffiConverterString.write(value.subject, buf)
        if value.is_challenge():
            buf.write_i32(20)
            _UniffiConverterString.write(value.challenge, buf)
        if value.is_title():
            buf.write_i32(21)
            _UniffiConverterString.write(value.title, buf)
        if value.is_image():
            buf.write_i32(22)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        if value.is_thumb():
            buf.write_i32(23)
            _UniffiConverterString.write(value.url, buf)
            _UniffiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        if value.is_summary():
            buf.write_i32(24)
            _UniffiConverterString.write(value.summary, buf)
        if value.is_description():
            buf.write_i32(25)
            _UniffiConverterString.write(value.desc, buf)
        if value.is_bolt11():
            buf.write_i32(26)
            _UniffiConverterString.write(value.bolt11, buf)
        if value.is_preimage():
            buf.write_i32(27)
            _UniffiConverterString.write(value.preimage, buf)
        if value.is_relays():
            buf.write_i32(28)
            _UniffiConverterSequenceString.write(value.urls, buf)
        if value.is_amount():
            buf.write_i32(29)
            _UniffiConverterUInt64.write(value.millisats, buf)
            _UniffiConverterOptionalString.write(value.bolt11, buf)
        if value.is_lnurl():
            buf.write_i32(30)
            _UniffiConverterString.write(value.lnurl, buf)
        if value.is_name():
            buf.write_i32(31)
            _UniffiConverterString.write(value.name, buf)
        if value.is_published_at():
            buf.write_i32(32)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_url_tag():
            buf.write_i32(33)
            _UniffiConverterString.write(value.url, buf)
        if value.is_mime_type():
            buf.write_i32(34)
            _UniffiConverterString.write(value.mime, buf)
        if value.is_aes256_gcm():
            buf.write_i32(35)
            _UniffiConverterString.write(value.key, buf)
            _UniffiConverterString.write(value.iv, buf)
        if value.is_sha256():
            buf.write_i32(36)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_size():
            buf.write_i32(37)
            _UniffiConverterUInt64.write(value.size, buf)
        if value.is_dim():
            buf.write_i32(38)
            _UniffiConverterTypeImageDimensions.write(value.dimensions, buf)
        if value.is_magnet():
            buf.write_i32(39)
            _UniffiConverterString.write(value.uri, buf)
        if value.is_blurhash():
            buf.write_i32(40)
            _UniffiConverterString.write(value.blurhash, buf)
        if value.is_streaming():
            buf.write_i32(41)
            _UniffiConverterString.write(value.url, buf)
        if value.is_recording():
            buf.write_i32(42)
            _UniffiConverterString.write(value.url, buf)
        if value.is_starts():
            buf.write_i32(43)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_ends():
            buf.write_i32(44)
            _UniffiConverterTypeTimestamp.write(value.timestamp, buf)
        if value.is_live_event_status_tag():
            buf.write_i32(45)
            _UniffiConverterTypeLiveEventStatus.write(value.status, buf)
        if value.is_current_participants():
            buf.write_i32(46)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_total_participants():
            buf.write_i32(47)
            _UniffiConverterUInt64.write(value.num, buf)
        if value.is_absolute_url():
            buf.write_i32(48)
            _UniffiConverterString.write(value.url, buf)
        if value.is_method():
            buf.write_i32(49)
            _UniffiConverterTypeHttpMethod.write(value.method, buf)
        if value.is_payload():
            buf.write_i32(50)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_anon():
            buf.write_i32(51)
            _UniffiConverterOptionalString.write(value.msg, buf)
        if value.is_proxy():
            buf.write_i32(52)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterTypeProtocol.write(value.protocol, buf)
        if value.is_emoji():
            buf.write_i32(53)
            _UniffiConverterString.write(value.shortcode, buf)
            _UniffiConverterString.write(value.url, buf)
        if value.is_request():
            buf.write_i32(54)
            _UniffiConverterTypeEvent.write(value.event, buf)
        if value.is_data_vending_machine_status_tag():
            buf.write_i32(55)
            _UniffiConverterTypeDataVendingMachineStatus.write(value.status, buf)
            _UniffiConverterOptionalString.write(value.extra_info, buf)






class TagKind:
    def __init__(self):
        raise RuntimeError("TagKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class KNOWN:
        known: "TagKindKnown"

        @typing.no_type_check
        def __init__(self,known: "TagKindKnown"):
            
            self.known = known
            

        def __str__(self):
            return "TagKind.KNOWN(known={})".format(self.known)

        def __eq__(self, other):
            if not other.is_known():
                return False
            if self.known != other.known:
                return False
            return True
    class UNKNOWN:
        unknown: "str"

        @typing.no_type_check
        def __init__(self,unknown: "str"):
            
            self.unknown = unknown
            

        def __str__(self):
            return "TagKind.UNKNOWN(unknown={})".format(self.unknown)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.unknown != other.unknown:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_known(self) -> bool:
        return isinstance(self, TagKind.KNOWN)
    def is_unknown(self) -> bool:
        return isinstance(self, TagKind.UNKNOWN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagKind.KNOWN = type("TagKind.KNOWN", (TagKind.KNOWN, TagKind,), {})  # type: ignore
TagKind.UNKNOWN = type("TagKind.UNKNOWN", (TagKind.UNKNOWN, TagKind,), {})  # type: ignore




class _UniffiConverterTypeTagKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagKind.KNOWN(
                _UniffiConverterTypeTagKindKnown.read(buf),
            )
        if variant == 2:
            return TagKind.UNKNOWN(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_known():
            _UniffiConverterTypeTagKindKnown.check_lower(value.known)
            return
        if value.is_unknown():
            _UniffiConverterString.check_lower(value.unknown)
            return

    @staticmethod
    def write(value, buf):
        if value.is_known():
            buf.write_i32(1)
            _UniffiConverterTypeTagKindKnown.write(value.known, buf)
        if value.is_unknown():
            buf.write_i32(2)
            _UniffiConverterString.write(value.unknown, buf)






class TagKindKnown(enum.Enum):
    P = 1
    """Public key"""

    
    E = 2
    """Event id"""

    
    R = 3
    """Reference (URL, etc.)"""

    
    T = 4
    """Hashtag"""

    
    G = 5
    """Geohash"""

    
    D = 6
    """Identifier"""

    
    A = 7
    """Referencing and tagging"""

    
    I = 8
    """External Identities"""

    
    M = 9
    """MIME type"""

    
    U = 10
    """Absolute URL"""

    
    X = 11
    """SHA256"""

    
    RELAY_URL = 12
    """Relay"""

    
    NONCE = 13
    """Nonce"""

    
    DELEGATION = 14
    """Delegation"""

    
    CONTENT_WARNING = 15
    """Content warning"""

    
    EXPIRATION = 16
    """Expiration"""

    
    SUBJECT = 17
    """Subject"""

    
    CHALLENGE = 18
    """Auth challenge"""

    
    TITLE = 19
    """Title (NIP23)"""

    
    IMAGE = 20
    """Image (NIP23)"""

    
    THUMB = 21
    """Thumbnail"""

    
    SUMMARY = 22
    """Summary (NIP23)"""

    
    PUBLISHED_AT = 23
    """PublishedAt (NIP23)"""

    
    DESCRIPTION = 24
    """Description (NIP57)"""

    
    BOLT11 = 25
    """Bolt11 Invoice (NIP57)"""

    
    PREIMAGE = 26
    """Preimage (NIP57)"""

    
    RELAYS = 27
    """Relays (NIP57)"""

    
    AMOUNT = 28
    """Amount (NIP57)"""

    
    LNURL = 29
    """Lnurl (NIP57)"""

    
    NAME = 30
    """Name tag"""

    
    URL = 31
    """Url"""

    
    AES256_GCM = 32
    """AES 256 GCM"""

    
    SIZE = 33
    """Size of file in bytes"""

    
    DIM = 34
    """Size of file in pixels"""

    
    MAGNET = 35
    """Magnet"""

    
    BLURHASH = 36
    """Blurhash"""

    
    STREAMING = 37
    """Streaming"""

    
    RECORDING = 38
    """Recording"""

    
    STARTS = 39
    """Starts"""

    
    ENDS = 40
    """Ends"""

    
    STATUS = 41
    """Status"""

    
    CURRENT_PARTICIPANTS = 42
    """Current participants"""

    
    TOTAL_PARTICIPANTS = 43
    """Total participants"""

    
    METHOD = 44
    """HTTP Method Request"""

    
    PAYLOAD = 45
    """Payload HASH"""

    
    ANON = 46
    
    PROXY = 47
    
    EMOJI = 48
    
    REQUEST = 49
    


class _UniffiConverterTypeTagKindKnown(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TagKindKnown.P
        if variant == 2:
            return TagKindKnown.E
        if variant == 3:
            return TagKindKnown.R
        if variant == 4:
            return TagKindKnown.T
        if variant == 5:
            return TagKindKnown.G
        if variant == 6:
            return TagKindKnown.D
        if variant == 7:
            return TagKindKnown.A
        if variant == 8:
            return TagKindKnown.I
        if variant == 9:
            return TagKindKnown.M
        if variant == 10:
            return TagKindKnown.U
        if variant == 11:
            return TagKindKnown.X
        if variant == 12:
            return TagKindKnown.RELAY_URL
        if variant == 13:
            return TagKindKnown.NONCE
        if variant == 14:
            return TagKindKnown.DELEGATION
        if variant == 15:
            return TagKindKnown.CONTENT_WARNING
        if variant == 16:
            return TagKindKnown.EXPIRATION
        if variant == 17:
            return TagKindKnown.SUBJECT
        if variant == 18:
            return TagKindKnown.CHALLENGE
        if variant == 19:
            return TagKindKnown.TITLE
        if variant == 20:
            return TagKindKnown.IMAGE
        if variant == 21:
            return TagKindKnown.THUMB
        if variant == 22:
            return TagKindKnown.SUMMARY
        if variant == 23:
            return TagKindKnown.PUBLISHED_AT
        if variant == 24:
            return TagKindKnown.DESCRIPTION
        if variant == 25:
            return TagKindKnown.BOLT11
        if variant == 26:
            return TagKindKnown.PREIMAGE
        if variant == 27:
            return TagKindKnown.RELAYS
        if variant == 28:
            return TagKindKnown.AMOUNT
        if variant == 29:
            return TagKindKnown.LNURL
        if variant == 30:
            return TagKindKnown.NAME
        if variant == 31:
            return TagKindKnown.URL
        if variant == 32:
            return TagKindKnown.AES256_GCM
        if variant == 33:
            return TagKindKnown.SIZE
        if variant == 34:
            return TagKindKnown.DIM
        if variant == 35:
            return TagKindKnown.MAGNET
        if variant == 36:
            return TagKindKnown.BLURHASH
        if variant == 37:
            return TagKindKnown.STREAMING
        if variant == 38:
            return TagKindKnown.RECORDING
        if variant == 39:
            return TagKindKnown.STARTS
        if variant == 40:
            return TagKindKnown.ENDS
        if variant == 41:
            return TagKindKnown.STATUS
        if variant == 42:
            return TagKindKnown.CURRENT_PARTICIPANTS
        if variant == 43:
            return TagKindKnown.TOTAL_PARTICIPANTS
        if variant == 44:
            return TagKindKnown.METHOD
        if variant == 45:
            return TagKindKnown.PAYLOAD
        if variant == 46:
            return TagKindKnown.ANON
        if variant == 47:
            return TagKindKnown.PROXY
        if variant == 48:
            return TagKindKnown.EMOJI
        if variant == 49:
            return TagKindKnown.REQUEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TagKindKnown.P:
            return
        if value == TagKindKnown.E:
            return
        if value == TagKindKnown.R:
            return
        if value == TagKindKnown.T:
            return
        if value == TagKindKnown.G:
            return
        if value == TagKindKnown.D:
            return
        if value == TagKindKnown.A:
            return
        if value == TagKindKnown.I:
            return
        if value == TagKindKnown.M:
            return
        if value == TagKindKnown.U:
            return
        if value == TagKindKnown.X:
            return
        if value == TagKindKnown.RELAY_URL:
            return
        if value == TagKindKnown.NONCE:
            return
        if value == TagKindKnown.DELEGATION:
            return
        if value == TagKindKnown.CONTENT_WARNING:
            return
        if value == TagKindKnown.EXPIRATION:
            return
        if value == TagKindKnown.SUBJECT:
            return
        if value == TagKindKnown.CHALLENGE:
            return
        if value == TagKindKnown.TITLE:
            return
        if value == TagKindKnown.IMAGE:
            return
        if value == TagKindKnown.THUMB:
            return
        if value == TagKindKnown.SUMMARY:
            return
        if value == TagKindKnown.PUBLISHED_AT:
            return
        if value == TagKindKnown.DESCRIPTION:
            return
        if value == TagKindKnown.BOLT11:
            return
        if value == TagKindKnown.PREIMAGE:
            return
        if value == TagKindKnown.RELAYS:
            return
        if value == TagKindKnown.AMOUNT:
            return
        if value == TagKindKnown.LNURL:
            return
        if value == TagKindKnown.NAME:
            return
        if value == TagKindKnown.URL:
            return
        if value == TagKindKnown.AES256_GCM:
            return
        if value == TagKindKnown.SIZE:
            return
        if value == TagKindKnown.DIM:
            return
        if value == TagKindKnown.MAGNET:
            return
        if value == TagKindKnown.BLURHASH:
            return
        if value == TagKindKnown.STREAMING:
            return
        if value == TagKindKnown.RECORDING:
            return
        if value == TagKindKnown.STARTS:
            return
        if value == TagKindKnown.ENDS:
            return
        if value == TagKindKnown.STATUS:
            return
        if value == TagKindKnown.CURRENT_PARTICIPANTS:
            return
        if value == TagKindKnown.TOTAL_PARTICIPANTS:
            return
        if value == TagKindKnown.METHOD:
            return
        if value == TagKindKnown.PAYLOAD:
            return
        if value == TagKindKnown.ANON:
            return
        if value == TagKindKnown.PROXY:
            return
        if value == TagKindKnown.EMOJI:
            return
        if value == TagKindKnown.REQUEST:
            return

    @staticmethod
    def write(value, buf):
        if value == TagKindKnown.P:
            buf.write_i32(1)
        if value == TagKindKnown.E:
            buf.write_i32(2)
        if value == TagKindKnown.R:
            buf.write_i32(3)
        if value == TagKindKnown.T:
            buf.write_i32(4)
        if value == TagKindKnown.G:
            buf.write_i32(5)
        if value == TagKindKnown.D:
            buf.write_i32(6)
        if value == TagKindKnown.A:
            buf.write_i32(7)
        if value == TagKindKnown.I:
            buf.write_i32(8)
        if value == TagKindKnown.M:
            buf.write_i32(9)
        if value == TagKindKnown.U:
            buf.write_i32(10)
        if value == TagKindKnown.X:
            buf.write_i32(11)
        if value == TagKindKnown.RELAY_URL:
            buf.write_i32(12)
        if value == TagKindKnown.NONCE:
            buf.write_i32(13)
        if value == TagKindKnown.DELEGATION:
            buf.write_i32(14)
        if value == TagKindKnown.CONTENT_WARNING:
            buf.write_i32(15)
        if value == TagKindKnown.EXPIRATION:
            buf.write_i32(16)
        if value == TagKindKnown.SUBJECT:
            buf.write_i32(17)
        if value == TagKindKnown.CHALLENGE:
            buf.write_i32(18)
        if value == TagKindKnown.TITLE:
            buf.write_i32(19)
        if value == TagKindKnown.IMAGE:
            buf.write_i32(20)
        if value == TagKindKnown.THUMB:
            buf.write_i32(21)
        if value == TagKindKnown.SUMMARY:
            buf.write_i32(22)
        if value == TagKindKnown.PUBLISHED_AT:
            buf.write_i32(23)
        if value == TagKindKnown.DESCRIPTION:
            buf.write_i32(24)
        if value == TagKindKnown.BOLT11:
            buf.write_i32(25)
        if value == TagKindKnown.PREIMAGE:
            buf.write_i32(26)
        if value == TagKindKnown.RELAYS:
            buf.write_i32(27)
        if value == TagKindKnown.AMOUNT:
            buf.write_i32(28)
        if value == TagKindKnown.LNURL:
            buf.write_i32(29)
        if value == TagKindKnown.NAME:
            buf.write_i32(30)
        if value == TagKindKnown.URL:
            buf.write_i32(31)
        if value == TagKindKnown.AES256_GCM:
            buf.write_i32(32)
        if value == TagKindKnown.SIZE:
            buf.write_i32(33)
        if value == TagKindKnown.DIM:
            buf.write_i32(34)
        if value == TagKindKnown.MAGNET:
            buf.write_i32(35)
        if value == TagKindKnown.BLURHASH:
            buf.write_i32(36)
        if value == TagKindKnown.STREAMING:
            buf.write_i32(37)
        if value == TagKindKnown.RECORDING:
            buf.write_i32(38)
        if value == TagKindKnown.STARTS:
            buf.write_i32(39)
        if value == TagKindKnown.ENDS:
            buf.write_i32(40)
        if value == TagKindKnown.STATUS:
            buf.write_i32(41)
        if value == TagKindKnown.CURRENT_PARTICIPANTS:
            buf.write_i32(42)
        if value == TagKindKnown.TOTAL_PARTICIPANTS:
            buf.write_i32(43)
        if value == TagKindKnown.METHOD:
            buf.write_i32(44)
        if value == TagKindKnown.PAYLOAD:
            buf.write_i32(45)
        if value == TagKindKnown.ANON:
            buf.write_i32(46)
        if value == TagKindKnown.PROXY:
            buf.write_i32(47)
        if value == TagKindKnown.EMOJI:
            buf.write_i32(48)
        if value == TagKindKnown.REQUEST:
            buf.write_i32(49)




class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEventId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEventId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEventId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeImageDimensions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeImageDimensions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeImageDimensions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeImageDimensions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTimestamp(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTimestamp.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTimestamp.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTimestamp.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeImage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeImage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeImage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeImage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLiveEventHost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLiveEventHost.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLiveEventHost.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLiveEventHost.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeJsonValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLiveEventStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLiveEventStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLiveEventStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLiveEventStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMarker(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMarker.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMarker.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMarker.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRelayMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRelayMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRelayMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRelayMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt16.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt16.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt16.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeContact(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeContact.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeContact.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeContact.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEventId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEventId.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEventId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEventId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFilter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePublicKey.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingMethod(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingMethod.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingMethod.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingMethod.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTag.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCoordinate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCoordinate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCoordinate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCoordinate.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeImage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeImage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeImage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeImage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePerson(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePerson.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePerson.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePerson.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeShippingCost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeShippingCost.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeShippingCost.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeShippingCost.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeJsonValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeJsonValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeJsonValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceString.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeJsonValue.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringOptionalTypeRelayMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterOptionalTypeRelayMetadata.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterOptionalTypeRelayMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterOptionalTypeRelayMetadata.read(buf)
            d[key] = val
        return d

def generate_shared_key(secret_key: "SecretKey",public_key: "PublicKey") -> "bytes":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    return _UniffiConverterBytes.lift(_rust_call(_UniffiLib.uniffi_nostr_ffi_fn_func_generate_shared_key,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key)))


def get_nip05_profile(nip05: "str",proxy: "typing.Optional[str]") -> "Nip19Profile":
    _UniffiConverterString.check_lower(nip05)
    
    _UniffiConverterOptionalString.check_lower(proxy)
    
    return _UniffiConverterTypeNip19Profile.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_get_nip05_profile,
        _UniffiConverterString.lower(nip05),
        _UniffiConverterOptionalString.lower(proxy)))


def nip04_decrypt(secret_key: "SecretKey",public_key: "PublicKey",encrypted_content: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(encrypted_content)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(encrypted_content)))


def nip04_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(content)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip04_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content)))


def nip44_decrypt(secret_key: "SecretKey",public_key: "PublicKey",payload: "str") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(payload)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_decrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(payload)))


def nip44_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str",version: "Nip44Version") -> "str":
    _UniffiConverterTypeSecretKey.check_lower(secret_key)
    
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(content)
    
    _UniffiConverterTypeNip44Version.check_lower(version)
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_nip44_encrypt,
        _UniffiConverterTypeSecretKey.lower(secret_key),
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(content),
        _UniffiConverterTypeNip44Version.lower(version)))


def verify_nip05(public_key: "PublicKey",nip05: "str",proxy: "typing.Optional[str]"):
    _UniffiConverterTypePublicKey.check_lower(public_key)
    
    _UniffiConverterString.check_lower(nip05)
    
    _UniffiConverterOptionalString.check_lower(proxy)
    
    _rust_call_with_error(_UniffiConverterTypeNostrError,_UniffiLib.uniffi_nostr_ffi_fn_func_verify_nip05,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterString.lower(nip05),
        _UniffiConverterOptionalString.lower(proxy))


__all__ = [
    "InternalError",
    "Alphabet",
    "ClientMessage",
    "DataVendingMachineStatus",
    "ExternalIdentity",
    "HttpMethod",
    "JsonValue",
    "LiveEventMarker",
    "LiveEventStatus",
    "Marker",
    "Nip44Version",
    "NostrConnectMessage",
    "NostrError",
    "Protocol",
    "RelayMessage",
    "RelayMetadata",
    "Report",
    "TagEnum",
    "TagKind",
    "TagKindKnown",
    "Coordinate",
    "HttpData",
    "Identity",
    "Image",
    "LiveEvent",
    "LiveEventHost",
    "Person",
    "ProductData",
    "ShippingCost",
    "StallData",
    "generate_shared_key",
    "get_nip05_profile",
    "nip04_decrypt",
    "nip04_encrypt",
    "nip44_decrypt",
    "nip44_encrypt",
    "verify_nip05",
    "Contact",
    "Event",
    "EventBuilder",
    "EventId",
    "FileMetadata",
    "Filter",
    "ImageDimensions",
    "Keys",
    "Metadata",
    "Nip19Profile",
    "NostrConnectUri",
    "NostrLibrary",
    "PublicKey",
    "RelayInformationDocument",
    "SecretKey",
    "ShippingMethod",
    "Tag",
    "Timestamp",
    "UnsignedEvent",
    "ZapRequestData",
]

